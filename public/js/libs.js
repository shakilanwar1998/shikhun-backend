(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 123);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./resources/assets/libs/bootstrap-select/bootstrap-select.js":
/*!********************************************************************!*\
  !*** ./resources/assets/libs/bootstrap-select/bootstrap-select.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(window,
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "/";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 27);
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "./node_modules/bootstrap-select/js/bootstrap-select.js":
  /*!**************************************************************!*\
    !*** ./node_modules/bootstrap-select/js/bootstrap-select.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesBootstrapSelectJsBootstrapSelectJs(module, exports) {
    (function ($) {
      'use strict';

      var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
      var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
      var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
      var DefaultWhitelist = {
        // Global attributes allowed on any supplied element below.
        '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],
        a: ['target', 'href', 'title', 'rel'],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ['src', 'alt', 'title', 'width', 'height'],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
      };
      /**
       * A pattern that recognizes a commonly useful subset of URLs that are safe.
       *
       * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
       */

      var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
      /**
       * A pattern that matches safe data URLs. Only matches image, video and audio types.
       *
       * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
       */

      var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

      function allowedAttribute(attr, allowedAttributeList) {
        var attrName = attr.nodeName.toLowerCase();

        if ($.inArray(attrName, allowedAttributeList) !== -1) {
          if ($.inArray(attrName, uriAttrs) !== -1) {
            return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
          }

          return true;
        }

        var regExp = $(allowedAttributeList).filter(function (index, value) {
          return value instanceof RegExp;
        }); // Check if a regular expression validates the attribute.

        for (var i = 0, l = regExp.length; i < l; i++) {
          if (attrName.match(regExp[i])) {
            return true;
          }
        }

        return false;
      }

      function sanitizeHtml(unsafeElements, whiteList, sanitizeFn) {
        if (sanitizeFn && typeof sanitizeFn === 'function') {
          return sanitizeFn(unsafeElements);
        }

        var whitelistKeys = Object.keys(whiteList);

        for (var i = 0, len = unsafeElements.length; i < len; i++) {
          var elements = unsafeElements[i].querySelectorAll('*');

          for (var j = 0, len2 = elements.length; j < len2; j++) {
            var el = elements[j];
            var elName = el.nodeName.toLowerCase();

            if (whitelistKeys.indexOf(elName) === -1) {
              el.parentNode.removeChild(el);
              continue;
            }

            var attributeList = [].slice.call(el.attributes);
            var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);

            for (var k = 0, len3 = attributeList.length; k < len3; k++) {
              var attr = attributeList[k];

              if (!allowedAttribute(attr, whitelistedAttributes)) {
                el.removeAttribute(attr.nodeName);
              }
            }
          }
        }
      } // Polyfill for browsers with no classList support
      // Remove in v2


      if (!('classList' in document.createElement('_'))) {
        (function (view) {
          if (!('Element' in view)) return;

          var classListProp = 'classList',
              protoProp = 'prototype',
              elemCtrProto = view.Element[protoProp],
              objCtr = Object,
              classListGetter = function classListGetter() {
            var $elem = $(this);
            return {
              add: function add(classes) {
                classes = Array.prototype.slice.call(arguments).join(' ');
                return $elem.addClass(classes);
              },
              remove: function remove(classes) {
                classes = Array.prototype.slice.call(arguments).join(' ');
                return $elem.removeClass(classes);
              },
              toggle: function toggle(classes, force) {
                return $elem.toggleClass(classes, force);
              },
              contains: function contains(classes) {
                return $elem.hasClass(classes);
              }
            };
          };

          if (objCtr.defineProperty) {
            var classListPropDesc = {
              get: classListGetter,
              enumerable: true,
              configurable: true
            };

            try {
              objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
            } catch (ex) {
              // IE 8 doesn't support enumerable:true
              // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
              // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
              if (ex.number === undefined || ex.number === -0x7FF5EC54) {
                classListPropDesc.enumerable = false;
                objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
              }
            }
          } else if (objCtr[protoProp].__defineGetter__) {
            elemCtrProto.__defineGetter__(classListProp, classListGetter);
          }
        })(window);
      }

      var testElement = document.createElement('_');
      testElement.classList.add('c1', 'c2');

      if (!testElement.classList.contains('c2')) {
        var _add = DOMTokenList.prototype.add,
            _remove = DOMTokenList.prototype.remove;

        DOMTokenList.prototype.add = function () {
          Array.prototype.forEach.call(arguments, _add.bind(this));
        };

        DOMTokenList.prototype.remove = function () {
          Array.prototype.forEach.call(arguments, _remove.bind(this));
        };
      }

      testElement.classList.toggle('c3', false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
      // support the second argument.

      if (testElement.classList.contains('c3')) {
        var _toggle = DOMTokenList.prototype.toggle;

        DOMTokenList.prototype.toggle = function (token, force) {
          if (1 in arguments && !this.contains(token) === !force) {
            return force;
          } else {
            return _toggle.call(this, token);
          }
        };
      }

      testElement = null; // shallow array comparison

      function isEqual(array1, array2) {
        return array1.length === array2.length && array1.every(function (element, index) {
          return element === array2[index];
        });
      }

      ; // <editor-fold desc="Shims">

      if (!String.prototype.startsWith) {
        (function () {
          'use strict'; // needed to support `apply`/`call` with `undefined`/`null`

          var defineProperty = function () {
            // IE 8 only supports `Object.defineProperty` on DOM elements
            try {
              var object = {};
              var $defineProperty = Object.defineProperty;
              var result = $defineProperty(object, object, object) && $defineProperty;
            } catch (error) {}

            return result;
          }();

          var toString = {}.toString;

          var startsWith = function startsWith(search) {
            if (this == null) {
              throw new TypeError();
            }

            var string = String(this);

            if (search && toString.call(search) == '[object RegExp]') {
              throw new TypeError();
            }

            var stringLength = string.length;
            var searchString = String(search);
            var searchLength = searchString.length;
            var position = arguments.length > 1 ? arguments[1] : undefined; // `ToInteger`

            var pos = position ? Number(position) : 0;

            if (pos != pos) {
              // better `isNaN`
              pos = 0;
            }

            var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible

            if (searchLength + start > stringLength) {
              return false;
            }

            var index = -1;

            while (++index < searchLength) {
              if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                return false;
              }
            }

            return true;
          };

          if (defineProperty) {
            defineProperty(String.prototype, 'startsWith', {
              'value': startsWith,
              'configurable': true,
              'writable': true
            });
          } else {
            String.prototype.startsWith = startsWith;
          }
        })();
      }

      if (!Object.keys) {
        Object.keys = function (o, // object
        k, // key
        r // result array
        ) {
          // initialize object and result
          r = []; // iterate over object keys

          for (k in o) {
            // fill result array with non-prototypical keys
            r.hasOwnProperty.call(o, k) && r.push(k);
          } // return result


          return r;
        };
      }

      if (HTMLSelectElement && !HTMLSelectElement.prototype.hasOwnProperty('selectedOptions')) {
        Object.defineProperty(HTMLSelectElement.prototype, 'selectedOptions', {
          get: function get() {
            return this.querySelectorAll(':checked');
          }
        });
      }

      function getSelectedOptions(select, ignoreDisabled) {
        var selectedOptions = select.selectedOptions,
            options = [],
            opt;

        if (ignoreDisabled) {
          for (var i = 0, len = selectedOptions.length; i < len; i++) {
            opt = selectedOptions[i];

            if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {
              options.push(opt);
            }
          }

          return options;
        }

        return selectedOptions;
      } // much faster than $.val()


      function getSelectValues(select, selectedOptions) {
        var value = [],
            options = selectedOptions || select.selectedOptions,
            opt;

        for (var i = 0, len = options.length; i < len; i++) {
          opt = options[i];

          if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {
            value.push(opt.value);
          }
        }

        if (!select.multiple) {
          return !value.length ? null : value[0];
        }

        return value;
      } // set data-selected on select element if the value has been programmatically selected
      // prior to initialization of bootstrap-select
      // * consider removing or replacing an alternative method *


      var valHooks = {
        useDefault: false,
        _set: $.valHooks.select.set
      };

      $.valHooks.select.set = function (elem, value) {
        if (value && !valHooks.useDefault) $(elem).data('selected', true);
        return valHooks._set.apply(this, arguments);
      };

      var changedArguments = null;

      var EventIsSupported = function () {
        try {
          new Event('change');
          return true;
        } catch (e) {
          return false;
        }
      }();

      $.fn.triggerNative = function (eventName) {
        var el = this[0],
            event;

        if (el.dispatchEvent) {
          // for modern browsers & IE9+
          if (EventIsSupported) {
            // For modern browsers
            event = new Event(eventName, {
              bubbles: true
            });
          } else {
            // For IE since it doesn't support Event constructor
            event = document.createEvent('Event');
            event.initEvent(eventName, true, false);
          }

          el.dispatchEvent(event);
        } else if (el.fireEvent) {
          // for IE8
          event = document.createEventObject();
          event.eventType = eventName;
          el.fireEvent('on' + eventName, event);
        } else {
          // fall back to jQuery.trigger
          this.trigger(eventName);
        }
      }; // </editor-fold>


      function stringSearch(li, searchString, method, normalize) {
        var stringTypes = ['display', 'subtext', 'tokens'],
            searchSuccess = false;

        for (var i = 0; i < stringTypes.length; i++) {
          var stringType = stringTypes[i],
              string = li[stringType];

          if (string) {
            string = string.toString(); // Strip HTML tags. This isn't perfect, but it's much faster than any other method

            if (stringType === 'display') {
              string = string.replace(/<[^>]+>/g, '');
            }

            if (normalize) string = normalizeToBase(string);
            string = string.toUpperCase();

            if (method === 'contains') {
              searchSuccess = string.indexOf(searchString) >= 0;
            } else {
              searchSuccess = string.startsWith(searchString);
            }

            if (searchSuccess) break;
          }
        }

        return searchSuccess;
      }

      function toInteger(value) {
        return parseInt(value, 10) || 0;
      } // Borrowed from Lodash (_.deburr)

      /** Used to map Latin Unicode letters to basic Latin letters. */


      var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcc': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xec': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        "\u0100": 'A',
        "\u0102": 'A',
        "\u0104": 'A',
        "\u0101": 'a',
        "\u0103": 'a',
        "\u0105": 'a',
        "\u0106": 'C',
        "\u0108": 'C',
        "\u010A": 'C',
        "\u010C": 'C',
        "\u0107": 'c',
        "\u0109": 'c',
        "\u010B": 'c',
        "\u010D": 'c',
        "\u010E": 'D',
        "\u0110": 'D',
        "\u010F": 'd',
        "\u0111": 'd',
        "\u0112": 'E',
        "\u0114": 'E',
        "\u0116": 'E',
        "\u0118": 'E',
        "\u011A": 'E',
        "\u0113": 'e',
        "\u0115": 'e',
        "\u0117": 'e',
        "\u0119": 'e',
        "\u011B": 'e',
        "\u011C": 'G',
        "\u011E": 'G',
        "\u0120": 'G',
        "\u0122": 'G',
        "\u011D": 'g',
        "\u011F": 'g',
        "\u0121": 'g',
        "\u0123": 'g',
        "\u0124": 'H',
        "\u0126": 'H',
        "\u0125": 'h',
        "\u0127": 'h',
        "\u0128": 'I',
        "\u012A": 'I',
        "\u012C": 'I',
        "\u012E": 'I',
        "\u0130": 'I',
        "\u0129": 'i',
        "\u012B": 'i',
        "\u012D": 'i',
        "\u012F": 'i',
        "\u0131": 'i',
        "\u0134": 'J',
        "\u0135": 'j',
        "\u0136": 'K',
        "\u0137": 'k',
        "\u0138": 'k',
        "\u0139": 'L',
        "\u013B": 'L',
        "\u013D": 'L',
        "\u013F": 'L',
        "\u0141": 'L',
        "\u013A": 'l',
        "\u013C": 'l',
        "\u013E": 'l',
        "\u0140": 'l',
        "\u0142": 'l',
        "\u0143": 'N',
        "\u0145": 'N',
        "\u0147": 'N',
        "\u014A": 'N',
        "\u0144": 'n',
        "\u0146": 'n',
        "\u0148": 'n',
        "\u014B": 'n',
        "\u014C": 'O',
        "\u014E": 'O',
        "\u0150": 'O',
        "\u014D": 'o',
        "\u014F": 'o',
        "\u0151": 'o',
        "\u0154": 'R',
        "\u0156": 'R',
        "\u0158": 'R',
        "\u0155": 'r',
        "\u0157": 'r',
        "\u0159": 'r',
        "\u015A": 'S',
        "\u015C": 'S',
        "\u015E": 'S',
        "\u0160": 'S',
        "\u015B": 's',
        "\u015D": 's',
        "\u015F": 's',
        "\u0161": 's',
        "\u0162": 'T',
        "\u0164": 'T',
        "\u0166": 'T',
        "\u0163": 't',
        "\u0165": 't',
        "\u0167": 't',
        "\u0168": 'U',
        "\u016A": 'U',
        "\u016C": 'U',
        "\u016E": 'U',
        "\u0170": 'U',
        "\u0172": 'U',
        "\u0169": 'u',
        "\u016B": 'u',
        "\u016D": 'u',
        "\u016F": 'u',
        "\u0171": 'u',
        "\u0173": 'u',
        "\u0174": 'W',
        "\u0175": 'w',
        "\u0176": 'Y',
        "\u0177": 'y',
        "\u0178": 'Y',
        "\u0179": 'Z',
        "\u017B": 'Z',
        "\u017D": 'Z',
        "\u017A": 'z',
        "\u017C": 'z',
        "\u017E": 'z',
        "\u0132": 'IJ',
        "\u0133": 'ij',
        "\u0152": 'Oe',
        "\u0153": 'oe',
        "\u0149": "'n",
        "\u017F": 's'
      };
      /** Used to match Latin Unicode letters (excluding mathematical operators). */

      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      /** Used to compose unicode character classes. */

      var rsComboMarksRange = "\\u0300-\\u036f",
          reComboHalfMarksRange = "\\ufe20-\\ufe2f",
          rsComboSymbolsRange = "\\u20d0-\\u20ff",
          rsComboMarksExtendedRange = "\\u1ab0-\\u1aff",
          rsComboMarksSupplementRange = "\\u1dc0-\\u1dff",
          rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;
      /** Used to compose unicode capture groups. */

      var rsCombo = '[' + rsComboRange + ']';
      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */

      var reComboMark = RegExp(rsCombo, 'g');

      function deburrLetter(key) {
        return deburredLetters[key];
      }

      ;

      function normalizeToBase(string) {
        string = string.toString();
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
      } // List of HTML entities for escaping.


      var escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;'
      }; // Functions for escaping and unescaping strings to/from HTML interpolation.

      var createEscaper = function createEscaper(map) {
        var escaper = function escaper(match) {
          return map[match];
        }; // Regexes for identifying a key that needs to be escaped.


        var source = '(?:' + Object.keys(map).join('|') + ')';
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, 'g');
        return function (string) {
          string = string == null ? '' : '' + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      };

      var htmlEscape = createEscaper(escapeMap);
      /**
       * ------------------------------------------------------------------------
       * Constants
       * ------------------------------------------------------------------------
       */

      var keyCodeMap = {
        32: ' ',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        59: ';',
        65: 'A',
        66: 'B',
        67: 'C',
        68: 'D',
        69: 'E',
        70: 'F',
        71: 'G',
        72: 'H',
        73: 'I',
        74: 'J',
        75: 'K',
        76: 'L',
        77: 'M',
        78: 'N',
        79: 'O',
        80: 'P',
        81: 'Q',
        82: 'R',
        83: 'S',
        84: 'T',
        85: 'U',
        86: 'V',
        87: 'W',
        88: 'X',
        89: 'Y',
        90: 'Z',
        96: '0',
        97: '1',
        98: '2',
        99: '3',
        100: '4',
        101: '5',
        102: '6',
        103: '7',
        104: '8',
        105: '9'
      };
      var keyCodes = {
        ESCAPE: 27,
        // KeyboardEvent.which value for Escape (Esc) key
        ENTER: 13,
        // KeyboardEvent.which value for Enter key
        SPACE: 32,
        // KeyboardEvent.which value for space key
        TAB: 9,
        // KeyboardEvent.which value for tab key
        ARROW_UP: 38,
        // KeyboardEvent.which value for up arrow key
        ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key

      };
      var version = {
        success: false,
        major: '3'
      };

      try {
        version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');
        version.major = version.full[0];
        version.success = true;
      } catch (err) {// do nothing
      }

      var selectId = 0;
      var EVENT_KEY = '.bs.select';
      var classNames = {
        DISABLED: 'disabled',
        DIVIDER: 'divider',
        SHOW: 'open',
        DROPUP: 'dropup',
        MENU: 'dropdown-menu',
        MENURIGHT: 'dropdown-menu-right',
        MENULEFT: 'dropdown-menu-left',
        // to-do: replace with more advanced template/customization options
        BUTTONCLASS: 'btn-default',
        POPOVERHEADER: 'popover-title',
        ICONBASE: 'glyphicon',
        TICKICON: 'glyphicon-ok'
      };
      var Selector = {
        MENU: '.' + classNames.MENU
      };
      var elementTemplates = {
        div: document.createElement('div'),
        span: document.createElement('span'),
        i: document.createElement('i'),
        subtext: document.createElement('small'),
        a: document.createElement('a'),
        li: document.createElement('li'),
        whitespace: document.createTextNode("\xA0"),
        fragment: document.createDocumentFragment()
      };
      elementTemplates.noResults = elementTemplates.li.cloneNode(false);
      elementTemplates.noResults.className = 'no-results';
      elementTemplates.a.setAttribute('role', 'option');
      elementTemplates.a.className = 'dropdown-item';
      elementTemplates.subtext.className = 'text-muted';
      elementTemplates.text = elementTemplates.span.cloneNode(false);
      elementTemplates.text.className = 'text';
      elementTemplates.checkMark = elementTemplates.span.cloneNode(false);
      var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);
      var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);
      var generateOption = {
        li: function li(content, classes, optgroup) {
          var li = elementTemplates.li.cloneNode(false);

          if (content) {
            if (content.nodeType === 1 || content.nodeType === 11) {
              li.appendChild(content);
            } else {
              li.innerHTML = content;
            }
          }

          if (typeof classes !== 'undefined' && classes !== '') li.className = classes;
          if (typeof optgroup !== 'undefined' && optgroup !== null) li.classList.add('optgroup-' + optgroup);
          return li;
        },
        a: function a(text, classes, inline) {
          var a = elementTemplates.a.cloneNode(true);

          if (text) {
            if (text.nodeType === 11) {
              a.appendChild(text);
            } else {
              a.insertAdjacentHTML('beforeend', text);
            }
          }

          if (typeof classes !== 'undefined' && classes !== '') a.classList.add.apply(a.classList, classes.split(/\s+/));
          if (inline) a.setAttribute('style', inline);
          return a;
        },
        text: function text(options, useFragment) {
          var textElement = elementTemplates.text.cloneNode(false),
              subtextElement,
              iconElement;

          if (options.content) {
            textElement.innerHTML = options.content;
          } else {
            textElement.textContent = options.text;

            if (options.icon) {
              var whitespace = elementTemplates.whitespace.cloneNode(false); // need to use <i> for icons in the button to prevent a breaking change
              // note: switch to span in next major release

              iconElement = (useFragment === true ? elementTemplates.i : elementTemplates.span).cloneNode(false);
              iconElement.className = this.options.iconBase + ' ' + options.icon;
              elementTemplates.fragment.appendChild(iconElement);
              elementTemplates.fragment.appendChild(whitespace);
            }

            if (options.subtext) {
              subtextElement = elementTemplates.subtext.cloneNode(false);
              subtextElement.textContent = options.subtext;
              textElement.appendChild(subtextElement);
            }
          }

          if (useFragment === true) {
            while (textElement.childNodes.length > 0) {
              elementTemplates.fragment.appendChild(textElement.childNodes[0]);
            }
          } else {
            elementTemplates.fragment.appendChild(textElement);
          }

          return elementTemplates.fragment;
        },
        label: function label(options) {
          var textElement = elementTemplates.text.cloneNode(false),
              subtextElement,
              iconElement;
          textElement.innerHTML = options.display;

          if (options.icon) {
            var whitespace = elementTemplates.whitespace.cloneNode(false);
            iconElement = elementTemplates.span.cloneNode(false);
            iconElement.className = this.options.iconBase + ' ' + options.icon;
            elementTemplates.fragment.appendChild(iconElement);
            elementTemplates.fragment.appendChild(whitespace);
          }

          if (options.subtext) {
            subtextElement = elementTemplates.subtext.cloneNode(false);
            subtextElement.textContent = options.subtext;
            textElement.appendChild(subtextElement);
          }

          elementTemplates.fragment.appendChild(textElement);
          return elementTemplates.fragment;
        }
      };

      function showNoResults(searchMatch, searchValue) {
        if (!searchMatch.length) {
          elementTemplates.noResults.innerHTML = this.options.noneResultsText.replace('{0}', '"' + htmlEscape(searchValue) + '"');
          this.$menuInner[0].firstChild.appendChild(elementTemplates.noResults);
        }
      }

      var Selectpicker = function Selectpicker(element, options) {
        var that = this; // bootstrap-select has been initialized - revert valHooks.select.set back to its original function

        if (!valHooks.useDefault) {
          $.valHooks.select.set = valHooks._set;
          valHooks.useDefault = true;
        }

        this.$element = $(element);
        this.$newElement = null;
        this.$button = null;
        this.$menu = null;
        this.options = options;
        this.selectpicker = {
          main: {},
          search: {},
          current: {},
          // current changes if a search is in progress
          view: {},
          isSearching: false,
          keydown: {
            keyHistory: '',
            resetKeyHistory: {
              start: function start() {
                return setTimeout(function () {
                  that.selectpicker.keydown.keyHistory = '';
                }, 800);
              }
            }
          }
        };
        this.sizeInfo = {}; // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a
        // data-attribute)

        if (this.options.title === null) {
          this.options.title = this.$element.attr('title');
        } // Format window padding


        var winPad = this.options.windowPadding;

        if (typeof winPad === 'number') {
          this.options.windowPadding = [winPad, winPad, winPad, winPad];
        } // Expose public methods


        this.val = Selectpicker.prototype.val;
        this.render = Selectpicker.prototype.render;
        this.refresh = Selectpicker.prototype.refresh;
        this.setStyle = Selectpicker.prototype.setStyle;
        this.selectAll = Selectpicker.prototype.selectAll;
        this.deselectAll = Selectpicker.prototype.deselectAll;
        this.destroy = Selectpicker.prototype.destroy;
        this.remove = Selectpicker.prototype.remove;
        this.show = Selectpicker.prototype.show;
        this.hide = Selectpicker.prototype.hide;
        this.init();
      };

      Selectpicker.VERSION = '1.13.18'; // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.

      Selectpicker.DEFAULTS = {
        noneSelectedText: 'Nothing selected',
        noneResultsText: 'No results matched {0}',
        countSelectedText: function countSelectedText(numSelected, numTotal) {
          return numSelected == 1 ? '{0} item selected' : '{0} items selected';
        },
        maxOptionsText: function maxOptionsText(numAll, numGroup) {
          return [numAll == 1 ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)', numGroup == 1 ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'];
        },
        selectAllText: 'Select All',
        deselectAllText: 'Deselect All',
        doneButton: false,
        doneButtonText: 'Close',
        multipleSeparator: ', ',
        styleBase: 'btn',
        style: classNames.BUTTONCLASS,
        size: 'auto',
        title: null,
        selectedTextFormat: 'values',
        width: false,
        container: false,
        hideDisabled: false,
        showSubtext: false,
        showIcon: true,
        showContent: true,
        dropupAuto: true,
        header: false,
        liveSearch: false,
        liveSearchPlaceholder: null,
        liveSearchNormalize: false,
        liveSearchStyle: 'contains',
        actionsBox: false,
        iconBase: classNames.ICONBASE,
        tickIcon: classNames.TICKICON,
        showTick: false,
        template: {
          caret: '<span class="caret"></span>'
        },
        maxOptions: false,
        mobile: false,
        selectOnTab: false,
        dropdownAlignRight: false,
        windowPadding: 0,
        virtualScroll: 600,
        display: false,
        sanitize: true,
        sanitizeFn: null,
        whiteList: DefaultWhitelist
      };
      Selectpicker.prototype = {
        constructor: Selectpicker,
        init: function init() {
          var that = this,
              id = this.$element.attr('id'),
              element = this.$element[0],
              form = element.form;
          selectId++;
          this.selectId = 'bs-select-' + selectId;
          element.classList.add('bs-select-hidden');
          this.multiple = this.$element.prop('multiple');
          this.autofocus = this.$element.prop('autofocus');

          if (element.classList.contains('show-tick')) {
            this.options.showTick = true;
          }

          this.$newElement = this.createDropdown();
          this.buildData();
          this.$element.after(this.$newElement).prependTo(this.$newElement); // ensure select is associated with form element if it got unlinked after moving it inside newElement

          if (form && element.form === null) {
            if (!form.id) form.id = 'form-' + this.selectId;
            element.setAttribute('form', form.id);
          }

          this.$button = this.$newElement.children('button');
          this.$menu = this.$newElement.children(Selector.MENU);
          this.$menuInner = this.$menu.children('.inner');
          this.$searchbox = this.$menu.find('input');
          element.classList.remove('bs-select-hidden');
          if (this.options.dropdownAlignRight === true) this.$menu[0].classList.add(classNames.MENURIGHT);

          if (typeof id !== 'undefined') {
            this.$button.attr('data-id', id);
          }

          this.checkDisabled();
          this.clickListener();

          if (this.options.liveSearch) {
            this.liveSearchListener();
            this.focusedParent = this.$searchbox[0];
          } else {
            this.focusedParent = this.$menuInner[0];
          }

          this.setStyle();
          this.render();
          this.setWidth();

          if (this.options.container) {
            this.selectPosition();
          } else {
            this.$element.on('hide' + EVENT_KEY, function () {
              if (that.isVirtual()) {
                // empty menu on close
                var menuInner = that.$menuInner[0],
                    emptyMenu = menuInner.firstChild.cloneNode(false); // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''

                menuInner.replaceChild(emptyMenu, menuInner.firstChild);
                menuInner.scrollTop = 0;
              }
            });
          }

          this.$menu.data('this', this);
          this.$newElement.data('this', this);
          if (this.options.mobile) this.mobile();
          this.$newElement.on({
            'hide.bs.dropdown': function hideBsDropdown(e) {
              that.$element.trigger('hide' + EVENT_KEY, e);
            },
            'hidden.bs.dropdown': function hiddenBsDropdown(e) {
              that.$element.trigger('hidden' + EVENT_KEY, e);
            },
            'show.bs.dropdown': function showBsDropdown(e) {
              that.$element.trigger('show' + EVENT_KEY, e);
            },
            'shown.bs.dropdown': function shownBsDropdown(e) {
              that.$element.trigger('shown' + EVENT_KEY, e);
            }
          });

          if (element.hasAttribute('required')) {
            this.$element.on('invalid' + EVENT_KEY, function () {
              that.$button[0].classList.add('bs-invalid');
              that.$element.on('shown' + EVENT_KEY + '.invalid', function () {
                that.$element.val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened
                .off('shown' + EVENT_KEY + '.invalid');
              }).on('rendered' + EVENT_KEY, function () {
                // if select is no longer invalid, remove the bs-invalid class
                if (this.validity.valid) that.$button[0].classList.remove('bs-invalid');
                that.$element.off('rendered' + EVENT_KEY);
              });
              that.$button.on('blur' + EVENT_KEY, function () {
                that.$element.trigger('focus').trigger('blur');
                that.$button.off('blur' + EVENT_KEY);
              });
            });
          }

          setTimeout(function () {
            that.buildList();
            that.$element.trigger('loaded' + EVENT_KEY);
          });
        },
        createDropdown: function createDropdown() {
          // Options
          // If we are multiple or showTick option is set, then add the show-tick class
          var showTick = this.multiple || this.options.showTick ? ' show-tick' : '',
              multiselectable = this.multiple ? ' aria-multiselectable="true"' : '',
              inputGroup = '',
              autofocus = this.autofocus ? ' autofocus' : '';

          if (version.major < 4 && this.$element.parent().hasClass('input-group')) {
            inputGroup = ' input-group-btn';
          } // Elements


          var drop,
              header = '',
              searchbox = '',
              actionsbox = '',
              donebutton = '';

          if (this.options.header) {
            header = '<div class="' + classNames.POPOVERHEADER + '">' + '<button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + '</div>';
          }

          if (this.options.liveSearch) {
            searchbox = '<div class="bs-searchbox">' + '<input type="search" class="form-control" autocomplete="off"' + (this.options.liveSearchPlaceholder === null ? '' : ' placeholder="' + htmlEscape(this.options.liveSearchPlaceholder) + '"') + ' role="combobox" aria-label="Search" aria-controls="' + this.selectId + '" aria-autocomplete="list">' + '</div>';
          }

          if (this.multiple && this.options.actionsBox) {
            actionsbox = '<div class="bs-actionsbox">' + '<div class="btn-group btn-group-sm btn-block">' + '<button type="button" class="actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '">' + this.options.selectAllText + '</button>' + '<button type="button" class="actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '">' + this.options.deselectAllText + '</button>' + '</div>' + '</div>';
          }

          if (this.multiple && this.options.doneButton) {
            donebutton = '<div class="bs-donebutton">' + '<div class="btn-group btn-block">' + '<button type="button" class="btn btn-sm ' + classNames.BUTTONCLASS + '">' + this.options.doneButtonText + '</button>' + '</div>' + '</div>';
          }

          drop = '<div class="dropdown bootstrap-select' + showTick + inputGroup + '">' + '<button type="button" tabindex="-1" class="' + this.options.styleBase + ' dropdown-toggle" ' + (this.options.display === 'static' ? 'data-display="static"' : '') + 'data-toggle="dropdown"' + autofocus + ' role="combobox" aria-owns="' + this.selectId + '" aria-haspopup="listbox" aria-expanded="false">' + '<div class="filter-option">' + '<div class="filter-option-inner">' + '<div class="filter-option-inner-inner"></div>' + '</div> ' + '</div>' + (version.major === '4' ? '' : '<span class="bs-caret">' + this.options.template.caret + '</span>') + '</button>' + '<div class="' + classNames.MENU + ' ' + (version.major === '4' ? '' : classNames.SHOW) + '">' + header + searchbox + actionsbox + '<div class="inner ' + classNames.SHOW + '" role="listbox" id="' + this.selectId + '" tabindex="-1" ' + multiselectable + '>' + '<ul class="' + classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '') + '" role="presentation">' + '</ul>' + '</div>' + donebutton + '</div>' + '</div>';
          return $(drop);
        },
        setPositionData: function setPositionData() {
          this.selectpicker.view.canHighlight = [];
          this.selectpicker.view.size = 0;
          this.selectpicker.view.firstHighlightIndex = false;

          for (var i = 0; i < this.selectpicker.current.data.length; i++) {
            var li = this.selectpicker.current.data[i],
                canHighlight = true;

            if (li.type === 'divider') {
              canHighlight = false;
              li.height = this.sizeInfo.dividerHeight;
            } else if (li.type === 'optgroup-label') {
              canHighlight = false;
              li.height = this.sizeInfo.dropdownHeaderHeight;
            } else {
              li.height = this.sizeInfo.liHeight;
            }

            if (li.disabled) canHighlight = false;
            this.selectpicker.view.canHighlight.push(canHighlight);

            if (canHighlight) {
              this.selectpicker.view.size++;
              li.posinset = this.selectpicker.view.size;
              if (this.selectpicker.view.firstHighlightIndex === false) this.selectpicker.view.firstHighlightIndex = i;
            }

            li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;
          }
        },
        isVirtual: function isVirtual() {
          return this.options.virtualScroll !== false && this.selectpicker.main.elements.length >= this.options.virtualScroll || this.options.virtualScroll === true;
        },
        createView: function createView(isSearching, setSize, refresh) {
          var that = this,
              scrollTop = 0,
              active = [],
              selected,
              prevActive;
          this.selectpicker.isSearching = isSearching;
          this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;
          this.setPositionData();

          if (setSize) {
            if (refresh) {
              scrollTop = this.$menuInner[0].scrollTop;
            } else if (!that.multiple) {
              var element = that.$element[0],
                  selectedIndex = (element.options[element.selectedIndex] || {}).liIndex;

              if (typeof selectedIndex === 'number' && that.options.size !== false) {
                var selectedData = that.selectpicker.main.data[selectedIndex],
                    position = selectedData && selectedData.position;

                if (position) {
                  scrollTop = position - (that.sizeInfo.menuInnerHeight + that.sizeInfo.liHeight) / 2;
                }
              }
            }
          }

          scroll(scrollTop, true);
          this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {
            if (!that.noScroll) scroll(this.scrollTop, updateValue);
            that.noScroll = false;
          });

          function scroll(scrollTop, init) {
            var size = that.selectpicker.current.elements.length,
                chunks = [],
                chunkSize,
                chunkCount,
                firstChunk,
                lastChunk,
                currentChunk,
                prevPositions,
                positionIsDifferent,
                previousElements,
                menuIsDifferent = true,
                isVirtual = that.isVirtual();
            that.selectpicker.view.scrollTop = scrollTop;
            chunkSize = Math.ceil(that.sizeInfo.menuInnerHeight / that.sizeInfo.liHeight * 1.5); // number of options in a chunk

            chunkCount = Math.round(size / chunkSize) || 1; // number of chunks

            for (var i = 0; i < chunkCount; i++) {
              var endOfChunk = (i + 1) * chunkSize;

              if (i === chunkCount - 1) {
                endOfChunk = size;
              }

              chunks[i] = [i * chunkSize + (!i ? 0 : 1), endOfChunk];
              if (!size) break;

              if (currentChunk === undefined && scrollTop - 1 <= that.selectpicker.current.data[endOfChunk - 1].position - that.sizeInfo.menuInnerHeight) {
                currentChunk = i;
              }
            }

            if (currentChunk === undefined) currentChunk = 0;
            prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1]; // always display previous, current, and next chunks

            firstChunk = Math.max(0, currentChunk - 1);
            lastChunk = Math.min(chunkCount - 1, currentChunk + 1);
            that.selectpicker.view.position0 = isVirtual === false ? 0 : Math.max(0, chunks[firstChunk][0]) || 0;
            that.selectpicker.view.position1 = isVirtual === false ? size : Math.min(size, chunks[lastChunk][1]) || 0;
            positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;

            if (that.activeIndex !== undefined) {
              prevActive = that.selectpicker.main.elements[that.prevActiveIndex];
              active = that.selectpicker.main.elements[that.activeIndex];
              selected = that.selectpicker.main.elements[that.selectedIndex];

              if (init) {
                if (that.activeIndex !== that.selectedIndex) {
                  that.defocusItem(active);
                }

                that.activeIndex = undefined;
              }

              if (that.activeIndex && that.activeIndex !== that.selectedIndex) {
                that.defocusItem(selected);
              }
            }

            if (that.prevActiveIndex !== undefined && that.prevActiveIndex !== that.activeIndex && that.prevActiveIndex !== that.selectedIndex) {
              that.defocusItem(prevActive);
            }

            if (init || positionIsDifferent) {
              previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];

              if (isVirtual === false) {
                that.selectpicker.view.visibleElements = that.selectpicker.current.elements;
              } else {
                that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);
              }

              that.setOptionStatus(); // if searching, check to make sure the list has actually been updated before updating DOM
              // this prevents unnecessary repaints

              if (isSearching || isVirtual === false && init) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements); // if virtual scroll is disabled and not searching,
              // menu should never need to be updated more than once

              if ((init || isVirtual === true) && menuIsDifferent) {
                var menuInner = that.$menuInner[0],
                    menuFragment = document.createDocumentFragment(),
                    emptyMenu = menuInner.firstChild.cloneNode(false),
                    marginTop,
                    marginBottom,
                    elements = that.selectpicker.view.visibleElements,
                    toSanitize = []; // replace the existing UL with an empty one - this is faster than $.empty()

                menuInner.replaceChild(emptyMenu, menuInner.firstChild);

                for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {
                  var element = elements[i],
                      elText,
                      elementData;

                  if (that.options.sanitize) {
                    elText = element.lastChild;

                    if (elText) {
                      elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0];

                      if (elementData && elementData.content && !elementData.sanitized) {
                        toSanitize.push(elText);
                        elementData.sanitized = true;
                      }
                    }
                  }

                  menuFragment.appendChild(element);
                }

                if (that.options.sanitize && toSanitize.length) {
                  sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);
                }

                if (isVirtual === true) {
                  marginTop = that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position;
                  marginBottom = that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position;
                  menuInner.firstChild.style.marginTop = marginTop + 'px';
                  menuInner.firstChild.style.marginBottom = marginBottom + 'px';
                } else {
                  menuInner.firstChild.style.marginTop = 0;
                  menuInner.firstChild.style.marginBottom = 0;
                }

                menuInner.firstChild.appendChild(menuFragment); // if an option is encountered that is wider than the current menu width, update the menu width accordingly
                // switch to ResizeObserver with increased browser support

                if (isVirtual === true && that.sizeInfo.hasScrollBar) {
                  var menuInnerInnerWidth = menuInner.firstChild.offsetWidth;

                  if (init && menuInnerInnerWidth < that.sizeInfo.menuInnerInnerWidth && that.sizeInfo.totalMenuWidth > that.sizeInfo.selectWidth) {
                    menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';
                  } else if (menuInnerInnerWidth > that.sizeInfo.menuInnerInnerWidth) {
                    // set to 0 to get actual width of menu
                    that.$menu[0].style.minWidth = 0;
                    var actualMenuWidth = menuInner.firstChild.offsetWidth;

                    if (actualMenuWidth > that.sizeInfo.menuInnerInnerWidth) {
                      that.sizeInfo.menuInnerInnerWidth = actualMenuWidth;
                      menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';
                    } // reset to default CSS styling


                    that.$menu[0].style.minWidth = '';
                  }
                }
              }
            }

            that.prevActiveIndex = that.activeIndex;

            if (!that.options.liveSearch) {
              that.$menuInner.trigger('focus');
            } else if (isSearching && init) {
              var index = 0,
                  newActive;

              if (!that.selectpicker.view.canHighlight[index]) {
                index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);
              }

              newActive = that.selectpicker.view.visibleElements[index];
              that.defocusItem(that.selectpicker.view.currentActive);
              that.activeIndex = (that.selectpicker.current.data[index] || {}).index;
              that.focusItem(newActive);
            }
          }

          $(window).off('resize' + EVENT_KEY + '.' + this.selectId + '.createView').on('resize' + EVENT_KEY + '.' + this.selectId + '.createView', function () {
            var isActive = that.$newElement.hasClass(classNames.SHOW);
            if (isActive) scroll(that.$menuInner[0].scrollTop);
          });
        },
        focusItem: function focusItem(li, liData, noStyle) {
          if (li) {
            liData = liData || this.selectpicker.main.data[this.activeIndex];
            var a = li.firstChild;

            if (a) {
              a.setAttribute('aria-setsize', this.selectpicker.view.size);
              a.setAttribute('aria-posinset', liData.posinset);

              if (noStyle !== true) {
                this.focusedParent.setAttribute('aria-activedescendant', a.id);
                li.classList.add('active');
                a.classList.add('active');
              }
            }
          }
        },
        defocusItem: function defocusItem(li) {
          if (li) {
            li.classList.remove('active');
            if (li.firstChild) li.firstChild.classList.remove('active');
          }
        },
        setPlaceholder: function setPlaceholder() {
          var that = this,
              updateIndex = false;

          if (this.options.title && !this.multiple) {
            if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option'); // this option doesn't create a new <li> element, but does add a new option at the start,
            // so startIndex should increase to prevent having to check every option for the bs-title-option class

            updateIndex = true;
            var element = this.$element[0],
                selectTitleOption = false,
                titleNotAppended = !this.selectpicker.view.titleOption.parentNode,
                selectedIndex = element.selectedIndex,
                selectedOption = element.options[selectedIndex],
                navigation = window.performance && window.performance.getEntriesByType('navigation'),
                // Safari doesn't support getEntriesByType('navigation') - fall back to performance.navigation
            isNotBackForward = navigation && navigation.length ? navigation[0].type !== 'back_forward' : window.performance.navigation.type !== 2;

            if (titleNotAppended) {
              // Use native JS to prepend option (faster)
              this.selectpicker.view.titleOption.className = 'bs-title-option';
              this.selectpicker.view.titleOption.value = ''; // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.
              // the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,
              // if so, the select will have the data-selected attribute

              selectTitleOption = !selectedOption || selectedIndex === 0 && selectedOption.defaultSelected === false && this.$element.data('selected') === undefined;
            }

            if (titleNotAppended || this.selectpicker.view.titleOption.index !== 0) {
              element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);
            } // Set selected *after* appending to select,
            // otherwise the option doesn't get selected in IE
            // set using selectedIndex, as setting the selected attr to true here doesn't work in IE11


            if (selectTitleOption && isNotBackForward) {
              element.selectedIndex = 0;
            } else if (document.readyState !== 'complete') {
              // if navigation type is back_forward, there's a chance the select will have its value set by BFCache
              // wait for that value to be set, then run render again
              window.addEventListener('pageshow', function () {
                if (that.selectpicker.view.displayedValue !== element.value) that.render();
              });
            }
          }

          return updateIndex;
        },
        buildData: function buildData() {
          var optionSelector = ':not([hidden]):not([data-hidden="true"])',
              mainData = [],
              optID = 0,
              startIndex = this.setPlaceholder() ? 1 : 0; // append the titleOption if necessary and skip the first option in the loop

          if (this.options.hideDisabled) optionSelector += ':not(:disabled)';
          var selectOptions = this.$element[0].querySelectorAll('select > *' + optionSelector);

          function addDivider(config) {
            var previousData = mainData[mainData.length - 1]; // ensure optgroup doesn't create back-to-back dividers

            if (previousData && previousData.type === 'divider' && (previousData.optID || config.optID)) {
              return;
            }

            config = config || {};
            config.type = 'divider';
            mainData.push(config);
          }

          function addOption(option, config) {
            config = config || {};
            config.divider = option.getAttribute('data-divider') === 'true';

            if (config.divider) {
              addDivider({
                optID: config.optID
              });
            } else {
              var liIndex = mainData.length,
                  cssText = option.style.cssText,
                  inlineStyle = cssText ? htmlEscape(cssText) : '',
                  optionClass = (option.className || '') + (config.optgroupClass || '');
              if (config.optID) optionClass = 'opt ' + optionClass;
              config.optionClass = optionClass.trim();
              config.inlineStyle = inlineStyle;
              config.text = option.textContent;
              config.content = option.getAttribute('data-content');
              config.tokens = option.getAttribute('data-tokens');
              config.subtext = option.getAttribute('data-subtext');
              config.icon = option.getAttribute('data-icon');
              option.liIndex = liIndex;
              config.display = config.content || config.text;
              config.type = 'option';
              config.index = liIndex;
              config.option = option;
              config.selected = !!option.selected;
              config.disabled = config.disabled || !!option.disabled;
              mainData.push(config);
            }
          }

          function addOptgroup(index, selectOptions) {
            var optgroup = selectOptions[index],
                // skip placeholder option
            previous = index - 1 < startIndex ? false : selectOptions[index - 1],
                next = selectOptions[index + 1],
                options = optgroup.querySelectorAll('option' + optionSelector);
            if (!options.length) return;
            var config = {
              display: htmlEscape(optgroup.label),
              subtext: optgroup.getAttribute('data-subtext'),
              icon: optgroup.getAttribute('data-icon'),
              type: 'optgroup-label',
              optgroupClass: ' ' + (optgroup.className || '')
            },
                headerIndex,
                lastIndex;
            optID++;

            if (previous) {
              addDivider({
                optID: optID
              });
            }

            config.optID = optID;
            mainData.push(config);

            for (var j = 0, len = options.length; j < len; j++) {
              var option = options[j];

              if (j === 0) {
                headerIndex = mainData.length - 1;
                lastIndex = headerIndex + len;
              }

              addOption(option, {
                headerIndex: headerIndex,
                lastIndex: lastIndex,
                optID: config.optID,
                optgroupClass: config.optgroupClass,
                disabled: optgroup.disabled
              });
            }

            if (next) {
              addDivider({
                optID: optID
              });
            }
          }

          for (var len = selectOptions.length, i = startIndex; i < len; i++) {
            var item = selectOptions[i];

            if (item.tagName !== 'OPTGROUP') {
              addOption(item, {});
            } else {
              addOptgroup(i, selectOptions);
            }
          }

          this.selectpicker.main.data = this.selectpicker.current.data = mainData;
        },
        buildList: function buildList() {
          var that = this,
              selectData = this.selectpicker.main.data,
              mainElements = [],
              widestOptionLength = 0;

          if ((that.options.showTick || that.multiple) && !elementTemplates.checkMark.parentNode) {
            elementTemplates.checkMark.className = this.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';
            elementTemplates.a.appendChild(elementTemplates.checkMark);
          }

          function buildElement(item) {
            var liElement,
                combinedLength = 0;

            switch (item.type) {
              case 'divider':
                liElement = generateOption.li(false, classNames.DIVIDER, item.optID ? item.optID + 'div' : undefined);
                break;

              case 'option':
                liElement = generateOption.li(generateOption.a(generateOption.text.call(that, item), item.optionClass, item.inlineStyle), '', item.optID);

                if (liElement.firstChild) {
                  liElement.firstChild.id = that.selectId + '-' + item.index;
                }

                break;

              case 'optgroup-label':
                liElement = generateOption.li(generateOption.label.call(that, item), 'dropdown-header' + item.optgroupClass, item.optID);
                break;
            }

            item.element = liElement;
            mainElements.push(liElement); // count the number of characters in the option - not perfect, but should work in most cases

            if (item.display) combinedLength += item.display.length;
            if (item.subtext) combinedLength += item.subtext.length; // if there is an icon, ensure this option's width is checked

            if (item.icon) combinedLength += 1;

            if (combinedLength > widestOptionLength) {
              widestOptionLength = combinedLength; // guess which option is the widest
              // use this when calculating menu width
              // not perfect, but it's fast, and the width will be updating accordingly when scrolling

              that.selectpicker.view.widestOption = mainElements[mainElements.length - 1];
            }
          }

          for (var len = selectData.length, i = 0; i < len; i++) {
            var item = selectData[i];
            buildElement(item);
          }

          this.selectpicker.main.elements = this.selectpicker.current.elements = mainElements;
        },
        findLis: function findLis() {
          return this.$menuInner.find('.inner > li');
        },
        render: function render() {
          var that = this,
              element = this.$element[0],
              // ensure titleOption is appended and selected (if necessary) before getting selectedOptions
          placeholderSelected = this.setPlaceholder() && element.selectedIndex === 0,
              selectedOptions = getSelectedOptions(element, this.options.hideDisabled),
              selectedCount = selectedOptions.length,
              button = this.$button[0],
              buttonInner = button.querySelector('.filter-option-inner-inner'),
              multipleSeparator = document.createTextNode(this.options.multipleSeparator),
              titleFragment = elementTemplates.fragment.cloneNode(false),
              showCount,
              countMax,
              hasContent = false;
          button.classList.toggle('bs-placeholder', that.multiple ? !selectedCount : !getSelectValues(element, selectedOptions));

          if (!that.multiple && selectedOptions.length === 1) {
            that.selectpicker.view.displayedValue = getSelectValues(element, selectedOptions);
          }

          if (this.options.selectedTextFormat === 'static') {
            titleFragment = generateOption.text.call(this, {
              text: this.options.title
            }, true);
          } else {
            showCount = this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1 && selectedCount > 1; // determine if the number of selected options will be shown (showCount === true)

            if (showCount) {
              countMax = this.options.selectedTextFormat.split('>');
              showCount = countMax.length > 1 && selectedCount > countMax[1] || countMax.length === 1 && selectedCount >= 2;
            } // only loop through all selected options if the count won't be shown


            if (showCount === false) {
              if (!placeholderSelected) {
                for (var selectedIndex = 0; selectedIndex < selectedCount; selectedIndex++) {
                  if (selectedIndex < 50) {
                    var option = selectedOptions[selectedIndex],
                        thisData = this.selectpicker.main.data[option.liIndex],
                        titleOptions = {};

                    if (this.multiple && selectedIndex > 0) {
                      titleFragment.appendChild(multipleSeparator.cloneNode(false));
                    }

                    if (option.title) {
                      titleOptions.text = option.title;
                    } else if (thisData) {
                      if (thisData.content && that.options.showContent) {
                        titleOptions.content = thisData.content.toString();
                        hasContent = true;
                      } else {
                        if (that.options.showIcon) {
                          titleOptions.icon = thisData.icon;
                        }

                        if (that.options.showSubtext && !that.multiple && thisData.subtext) titleOptions.subtext = ' ' + thisData.subtext;
                        titleOptions.text = option.textContent.trim();
                      }
                    }

                    titleFragment.appendChild(generateOption.text.call(this, titleOptions, true));
                  } else {
                    break;
                  }
                } // add ellipsis


                if (selectedCount > 49) {
                  titleFragment.appendChild(document.createTextNode('...'));
                }
              }
            } else {
              var optionSelector = ':not([hidden]):not([data-hidden="true"]):not([data-divider="true"])';
              if (this.options.hideDisabled) optionSelector += ':not(:disabled)'; // If this is a multiselect, and selectedTextFormat is count, then show 1 of 2 selected, etc.

              var totalCount = this.$element[0].querySelectorAll('select > option' + optionSelector + ', optgroup' + optionSelector + ' option' + optionSelector).length,
                  tr8nText = typeof this.options.countSelectedText === 'function' ? this.options.countSelectedText(selectedCount, totalCount) : this.options.countSelectedText;
              titleFragment = generateOption.text.call(this, {
                text: tr8nText.replace('{0}', selectedCount.toString()).replace('{1}', totalCount.toString())
              }, true);
            }
          }

          if (this.options.title == undefined) {
            // use .attr to ensure undefined is returned if title attribute is not set
            this.options.title = this.$element.attr('title');
          } // If the select doesn't have a title, then use the default, or if nothing is set at all, use noneSelectedText


          if (!titleFragment.childNodes.length) {
            titleFragment = generateOption.text.call(this, {
              text: typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText
            }, true);
          } // strip all HTML tags and trim the result, then unescape any escaped tags


          button.title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();

          if (this.options.sanitize && hasContent) {
            sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);
          }

          buttonInner.innerHTML = '';
          buttonInner.appendChild(titleFragment);

          if (version.major < 4 && this.$newElement[0].classList.contains('bs3-has-addon')) {
            var filterExpand = button.querySelector('.filter-expand'),
                clone = buttonInner.cloneNode(true);
            clone.className = 'filter-expand';

            if (filterExpand) {
              button.replaceChild(clone, filterExpand);
            } else {
              button.appendChild(clone);
            }
          }

          this.$element.trigger('rendered' + EVENT_KEY);
        },

        /**
         * @param [style]
         * @param [status]
         */
        setStyle: function setStyle(newStyle, status) {
          var button = this.$button[0],
              newElement = this.$newElement[0],
              style = this.options.style.trim(),
              buttonClass;

          if (this.$element.attr('class')) {
            this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ''));
          }

          if (version.major < 4) {
            newElement.classList.add('bs3');

            if (newElement.parentNode.classList && newElement.parentNode.classList.contains('input-group') && (newElement.previousElementSibling || newElement.nextElementSibling) && (newElement.previousElementSibling || newElement.nextElementSibling).classList.contains('input-group-addon')) {
              newElement.classList.add('bs3-has-addon');
            }
          }

          if (newStyle) {
            buttonClass = newStyle.trim();
          } else {
            buttonClass = style;
          }

          if (status == 'add') {
            if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));
          } else if (status == 'remove') {
            if (buttonClass) button.classList.remove.apply(button.classList, buttonClass.split(' '));
          } else {
            if (style) button.classList.remove.apply(button.classList, style.split(' '));
            if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));
          }
        },
        liHeight: function liHeight(refresh) {
          if (!refresh && (this.options.size === false || Object.keys(this.sizeInfo).length)) return;
          var newElement = elementTemplates.div.cloneNode(false),
              menu = elementTemplates.div.cloneNode(false),
              menuInner = elementTemplates.div.cloneNode(false),
              menuInnerInner = document.createElement('ul'),
              divider = elementTemplates.li.cloneNode(false),
              dropdownHeader = elementTemplates.li.cloneNode(false),
              li,
              a = elementTemplates.a.cloneNode(false),
              text = elementTemplates.span.cloneNode(false),
              header = this.options.header && this.$menu.find('.' + classNames.POPOVERHEADER).length > 0 ? this.$menu.find('.' + classNames.POPOVERHEADER)[0].cloneNode(true) : null,
              search = this.options.liveSearch ? elementTemplates.div.cloneNode(false) : null,
              actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,
              doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null,
              firstOption = this.$element.find('option')[0];
          this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;
          text.className = 'text';
          a.className = 'dropdown-item ' + (firstOption ? firstOption.className : '');
          newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;
          newElement.style.width = 0; // ensure button width doesn't affect natural width of menu when calculating

          if (this.options.width === 'auto') menu.style.minWidth = 0;
          menu.className = classNames.MENU + ' ' + classNames.SHOW;
          menuInner.className = 'inner ' + classNames.SHOW;
          menuInnerInner.className = classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '');
          divider.className = classNames.DIVIDER;
          dropdownHeader.className = 'dropdown-header';
          text.appendChild(document.createTextNode("\u200B"));

          if (this.selectpicker.current.data.length) {
            for (var i = 0; i < this.selectpicker.current.data.length; i++) {
              var data = this.selectpicker.current.data[i];

              if (data.type === 'option') {
                li = data.element;
                break;
              }
            }
          } else {
            li = elementTemplates.li.cloneNode(false);
            a.appendChild(text);
            li.appendChild(a);
          }

          dropdownHeader.appendChild(text.cloneNode(true));

          if (this.selectpicker.view.widestOption) {
            menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));
          }

          menuInnerInner.appendChild(li);
          menuInnerInner.appendChild(divider);
          menuInnerInner.appendChild(dropdownHeader);
          if (header) menu.appendChild(header);

          if (search) {
            var input = document.createElement('input');
            search.className = 'bs-searchbox';
            input.className = 'form-control';
            search.appendChild(input);
            menu.appendChild(search);
          }

          if (actions) menu.appendChild(actions);
          menuInner.appendChild(menuInnerInner);
          menu.appendChild(menuInner);
          if (doneButton) menu.appendChild(doneButton);
          newElement.appendChild(menu);
          document.body.appendChild(newElement);
          var liHeight = li.offsetHeight,
              dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,
              headerHeight = header ? header.offsetHeight : 0,
              searchHeight = search ? search.offsetHeight : 0,
              actionsHeight = actions ? actions.offsetHeight : 0,
              doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,
              dividerHeight = $(divider).outerHeight(true),
              // fall back to jQuery if getComputedStyle is not supported
          menuStyle = window.getComputedStyle ? window.getComputedStyle(menu) : false,
              menuWidth = menu.offsetWidth,
              $menu = menuStyle ? null : $(menu),
              menuPadding = {
            vert: toInteger(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) + toInteger(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) + toInteger(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) + toInteger(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),
            horiz: toInteger(menuStyle ? menuStyle.paddingLeft : $menu.css('paddingLeft')) + toInteger(menuStyle ? menuStyle.paddingRight : $menu.css('paddingRight')) + toInteger(menuStyle ? menuStyle.borderLeftWidth : $menu.css('borderLeftWidth')) + toInteger(menuStyle ? menuStyle.borderRightWidth : $menu.css('borderRightWidth'))
          },
              menuExtras = {
            vert: menuPadding.vert + toInteger(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) + toInteger(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2,
            horiz: menuPadding.horiz + toInteger(menuStyle ? menuStyle.marginLeft : $menu.css('marginLeft')) + toInteger(menuStyle ? menuStyle.marginRight : $menu.css('marginRight')) + 2
          },
              scrollBarWidth;
          menuInner.style.overflowY = 'scroll';
          scrollBarWidth = menu.offsetWidth - menuWidth;
          document.body.removeChild(newElement);
          this.sizeInfo.liHeight = liHeight;
          this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;
          this.sizeInfo.headerHeight = headerHeight;
          this.sizeInfo.searchHeight = searchHeight;
          this.sizeInfo.actionsHeight = actionsHeight;
          this.sizeInfo.doneButtonHeight = doneButtonHeight;
          this.sizeInfo.dividerHeight = dividerHeight;
          this.sizeInfo.menuPadding = menuPadding;
          this.sizeInfo.menuExtras = menuExtras;
          this.sizeInfo.menuWidth = menuWidth;
          this.sizeInfo.menuInnerInnerWidth = menuWidth - menuPadding.horiz;
          this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;
          this.sizeInfo.scrollBarWidth = scrollBarWidth;
          this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;
          this.setPositionData();
        },
        getSelectPosition: function getSelectPosition() {
          var that = this,
              $window = $(window),
              pos = that.$newElement.offset(),
              $container = $(that.options.container),
              containerPos;

          if (that.options.container && $container.length && !$container.is('body')) {
            containerPos = $container.offset();
            containerPos.top += parseInt($container.css('borderTopWidth'));
            containerPos.left += parseInt($container.css('borderLeftWidth'));
          } else {
            containerPos = {
              top: 0,
              left: 0
            };
          }

          var winPad = that.options.windowPadding;
          this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();
          this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - containerPos.top - winPad[2];
          this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();
          this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - containerPos.left - winPad[1];
          this.sizeInfo.selectOffsetTop -= winPad[0];
          this.sizeInfo.selectOffsetLeft -= winPad[3];
        },
        setMenuSize: function setMenuSize(isAuto) {
          this.getSelectPosition();

          var selectWidth = this.sizeInfo.selectWidth,
              liHeight = this.sizeInfo.liHeight,
              headerHeight = this.sizeInfo.headerHeight,
              searchHeight = this.sizeInfo.searchHeight,
              actionsHeight = this.sizeInfo.actionsHeight,
              doneButtonHeight = this.sizeInfo.doneButtonHeight,
              divHeight = this.sizeInfo.dividerHeight,
              menuPadding = this.sizeInfo.menuPadding,
              menuInnerHeight,
              menuHeight,
              divLength = 0,
              minHeight,
              _minHeight,
              maxHeight,
              menuInnerMinHeight,
              estimate,
              isDropup;

          if (this.options.dropupAuto) {
            // Get the estimated height of the menu without scrollbars.
            // This is useful for smaller menus, where there might be plenty of room
            // below the button without setting dropup, but we can't know
            // the exact height of the menu until createView is called later
            estimate = liHeight * this.selectpicker.current.elements.length + menuPadding.vert;
            isDropup = this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot; // ensure dropup doesn't change while searching (so menu doesn't bounce back and forth)

            if (this.selectpicker.isSearching === true) {
              isDropup = this.selectpicker.dropup;
            }

            this.$newElement.toggleClass(classNames.DROPUP, isDropup);
            this.selectpicker.dropup = isDropup;
          }

          if (this.options.size === 'auto') {
            _minHeight = this.selectpicker.current.elements.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;
            menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;
            minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;
            menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);

            if (this.$newElement.hasClass(classNames.DROPUP)) {
              menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;
            }

            maxHeight = menuHeight;
            menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;
          } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {
            for (var i = 0; i < this.options.size; i++) {
              if (this.selectpicker.current.data[i].type === 'divider') divLength++;
            }

            menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;
            menuInnerHeight = menuHeight - menuPadding.vert;
            maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;
            minHeight = menuInnerMinHeight = '';
          }

          this.$menu.css({
            'max-height': maxHeight + 'px',
            'overflow': 'hidden',
            'min-height': minHeight + 'px'
          });
          this.$menuInner.css({
            'max-height': menuInnerHeight + 'px',
            'overflow-y': 'auto',
            'min-height': menuInnerMinHeight + 'px'
          }); // ensure menuInnerHeight is always a positive number to prevent issues calculating chunkSize in createView

          this.sizeInfo.menuInnerHeight = Math.max(menuInnerHeight, 1);

          if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {
            this.sizeInfo.hasScrollBar = true;
            this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;
          }

          if (this.options.dropdownAlignRight === 'auto') {
            this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < this.sizeInfo.totalMenuWidth - selectWidth);
          }

          if (this.dropdown && this.dropdown._popper) this.dropdown._popper.update();
        },
        setSize: function setSize(refresh) {
          this.liHeight(refresh);
          if (this.options.header) this.$menu.css('padding-top', 0);

          if (this.options.size !== false) {
            var that = this,
                $window = $(window);
            this.setMenuSize();

            if (this.options.liveSearch) {
              this.$searchbox.off('input.setMenuSize propertychange.setMenuSize').on('input.setMenuSize propertychange.setMenuSize', function () {
                return that.setMenuSize();
              });
            }

            if (this.options.size === 'auto') {
              $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize').on('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize', function () {
                return that.setMenuSize();
              });
            } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {
              $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize');
            }
          }

          this.createView(false, true, refresh);
        },
        setWidth: function setWidth() {
          var that = this;

          if (this.options.width === 'auto') {
            requestAnimationFrame(function () {
              that.$menu.css('min-width', '0');
              that.$element.on('loaded' + EVENT_KEY, function () {
                that.liHeight();
                that.setMenuSize(); // Get correct width if element is hidden

                var $selectClone = that.$newElement.clone().appendTo('body'),
                    btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();
                $selectClone.remove(); // Set width to whatever's larger, button title or longest option

                that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);
                that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');
              });
            });
          } else if (this.options.width === 'fit') {
            // Remove inline min-width so width can be changed from 'auto'
            this.$menu.css('min-width', '');
            this.$newElement.css('width', '').addClass('fit-width');
          } else if (this.options.width) {
            // Remove inline min-width so width can be changed from 'auto'
            this.$menu.css('min-width', '');
            this.$newElement.css('width', this.options.width);
          } else {
            // Remove inline min-width/width so width can be changed
            this.$menu.css('min-width', '');
            this.$newElement.css('width', '');
          } // Remove fit-width class if width is changed programmatically


          if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {
            this.$newElement[0].classList.remove('fit-width');
          }
        },
        selectPosition: function selectPosition() {
          this.$bsContainer = $('<div class="bs-container" />');

          var that = this,
              $container = $(this.options.container),
              pos,
              containerPos,
              actualHeight,
              getPlacement = function getPlacement($element) {
            var containerPosition = {},
                // fall back to dropdown's default display setting if display is not manually set
            display = that.options.display || ( // Bootstrap 3 doesn't have $.fn.dropdown.Constructor.Default
            $.fn.dropdown.Constructor.Default ? $.fn.dropdown.Constructor.Default.display : false);
            that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));
            pos = $element.offset();

            if (!$container.is('body')) {
              containerPos = $container.offset();
              containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();
              containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();
            } else {
              containerPos = {
                top: 0,
                left: 0
              };
            }

            actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight; // Bootstrap 4+ uses Popper for menu positioning

            if (version.major < 4 || display === 'static') {
              containerPosition.top = pos.top - containerPos.top + actualHeight;
              containerPosition.left = pos.left - containerPos.left;
            }

            containerPosition.width = $element[0].offsetWidth;
            that.$bsContainer.css(containerPosition);
          };

          this.$button.on('click.bs.dropdown.data-api', function () {
            if (that.isDisabled()) {
              return;
            }

            getPlacement(that.$newElement);
            that.$bsContainer.appendTo(that.options.container).toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW)).append(that.$menu);
          });
          $(window).off('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId).on('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId, function () {
            var isActive = that.$newElement.hasClass(classNames.SHOW);
            if (isActive) getPlacement(that.$newElement);
          });
          this.$element.on('hide' + EVENT_KEY, function () {
            that.$menu.data('height', that.$menu.height());
            that.$bsContainer.detach();
          });
        },
        setOptionStatus: function setOptionStatus(selectedOnly) {
          var that = this;
          that.noScroll = false;

          if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {
            for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {
              var liData = that.selectpicker.current.data[i + that.selectpicker.view.position0],
                  option = liData.option;

              if (option) {
                if (selectedOnly !== true) {
                  that.setDisabled(liData.index, liData.disabled);
                }

                that.setSelected(liData.index, option.selected);
              }
            }
          }
        },

        /**
         * @param {number} index - the index of the option that is being changed
         * @param {boolean} selected - true if the option is being selected, false if being deselected
         */
        setSelected: function setSelected(index, selected) {
          var li = this.selectpicker.main.elements[index],
              liData = this.selectpicker.main.data[index],
              activeIndexIsSet = this.activeIndex !== undefined,
              thisIsActive = this.activeIndex === index,
              prevActive,
              a,
              // if current option is already active
          // OR
          // if the current option is being selected, it's NOT multiple, and
          // activeIndex is undefined:
          //  - when the menu is first being opened, OR
          //  - after a search has been performed, OR
          //  - when retainActive is false when selecting a new option (i.e. index of the newly selected option is not the same as the current activeIndex)
          keepActive = thisIsActive || selected && !this.multiple && !activeIndexIsSet;
          liData.selected = selected;
          a = li.firstChild;

          if (selected) {
            this.selectedIndex = index;
          }

          li.classList.toggle('selected', selected);

          if (keepActive) {
            this.focusItem(li, liData);
            this.selectpicker.view.currentActive = li;
            this.activeIndex = index;
          } else {
            this.defocusItem(li);
          }

          if (a) {
            a.classList.toggle('selected', selected);

            if (selected) {
              a.setAttribute('aria-selected', true);
            } else {
              if (this.multiple) {
                a.setAttribute('aria-selected', false);
              } else {
                a.removeAttribute('aria-selected');
              }
            }
          }

          if (!keepActive && !activeIndexIsSet && selected && this.prevActiveIndex !== undefined) {
            prevActive = this.selectpicker.main.elements[this.prevActiveIndex];
            this.defocusItem(prevActive);
          }
        },

        /**
         * @param {number} index - the index of the option that is being disabled
         * @param {boolean} disabled - true if the option is being disabled, false if being enabled
         */
        setDisabled: function setDisabled(index, disabled) {
          var li = this.selectpicker.main.elements[index],
              a;
          this.selectpicker.main.data[index].disabled = disabled;
          a = li.firstChild;
          li.classList.toggle(classNames.DISABLED, disabled);

          if (a) {
            if (version.major === '4') a.classList.toggle(classNames.DISABLED, disabled);

            if (disabled) {
              a.setAttribute('aria-disabled', disabled);
              a.setAttribute('tabindex', -1);
            } else {
              a.removeAttribute('aria-disabled');
              a.setAttribute('tabindex', 0);
            }
          }
        },
        isDisabled: function isDisabled() {
          return this.$element[0].disabled;
        },
        checkDisabled: function checkDisabled() {
          if (this.isDisabled()) {
            this.$newElement[0].classList.add(classNames.DISABLED);
            this.$button.addClass(classNames.DISABLED).attr('aria-disabled', true);
          } else {
            if (this.$button[0].classList.contains(classNames.DISABLED)) {
              this.$newElement[0].classList.remove(classNames.DISABLED);
              this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);
            }
          }
        },
        clickListener: function clickListener() {
          var that = this,
              $document = $(document);
          $document.data('spaceSelect', false);
          this.$button.on('keyup', function (e) {
            if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {
              e.preventDefault();
              $document.data('spaceSelect', false);
            }
          });
          this.$newElement.on('show.bs.dropdown', function () {
            if (version.major > 3 && !that.dropdown) {
              that.dropdown = that.$button.data('bs.dropdown');
              that.dropdown._menu = that.$menu[0];
            }
          });
          this.$button.on('click.bs.dropdown.data-api', function () {
            if (!that.$newElement.hasClass(classNames.SHOW)) {
              that.setSize();
            }
          });

          function setFocus() {
            if (that.options.liveSearch) {
              that.$searchbox.trigger('focus');
            } else {
              that.$menuInner.trigger('focus');
            }
          }

          function checkPopperExists() {
            if (that.dropdown && that.dropdown._popper && that.dropdown._popper.state.isCreated) {
              setFocus();
            } else {
              requestAnimationFrame(checkPopperExists);
            }
          }

          this.$element.on('shown' + EVENT_KEY, function () {
            if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {
              that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;
            }

            if (version.major > 3) {
              requestAnimationFrame(checkPopperExists);
            } else {
              setFocus();
            }
          }); // ensure posinset and setsize are correct before selecting an option via a click

          this.$menuInner.on('mouseenter', 'li a', function (e) {
            var hoverLi = this.parentElement,
                position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,
                index = Array.prototype.indexOf.call(hoverLi.parentElement.children, hoverLi),
                hoverData = that.selectpicker.current.data[index + position0];
            that.focusItem(hoverLi, hoverData, true);
          });
          this.$menuInner.on('click', 'li a', function (e, retainActive) {
            var $this = $(this),
                element = that.$element[0],
                position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,
                clickedData = that.selectpicker.current.data[$this.parent().index() + position0],
                clickedIndex = clickedData.index,
                prevValue = getSelectValues(element),
                prevIndex = element.selectedIndex,
                prevOption = element.options[prevIndex],
                triggerChange = true; // Don't close on multi choice menu

            if (that.multiple && that.options.maxOptions !== 1) {
              e.stopPropagation();
            }

            e.preventDefault(); // Don't run if the select is disabled

            if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {
              var option = clickedData.option,
                  $option = $(option),
                  state = option.selected,
                  $optgroup = $option.parent('optgroup'),
                  $optgroupOptions = $optgroup.find('option'),
                  maxOptions = that.options.maxOptions,
                  maxOptionsGrp = $optgroup.data('maxOptions') || false;
              if (clickedIndex === that.activeIndex) retainActive = true;

              if (!retainActive) {
                that.prevActiveIndex = that.activeIndex;
                that.activeIndex = undefined;
              }

              if (!that.multiple) {
                // Deselect all others if not multi select box
                if (prevOption) prevOption.selected = false;
                option.selected = true;
                that.setSelected(clickedIndex, true);
              } else {
                // Toggle the one we have chosen if we are multi select.
                option.selected = !state;
                that.setSelected(clickedIndex, !state);
                that.focusedParent.focus();

                if (maxOptions !== false || maxOptionsGrp !== false) {
                  var maxReached = maxOptions < getSelectedOptions(element).length,
                      maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;

                  if (maxOptions && maxReached || maxOptionsGrp && maxReachedGrp) {
                    if (maxOptions && maxOptions == 1) {
                      element.selectedIndex = -1;
                      option.selected = true;
                      that.setOptionStatus(true);
                    } else if (maxOptionsGrp && maxOptionsGrp == 1) {
                      for (var i = 0; i < $optgroupOptions.length; i++) {
                        var _option = $optgroupOptions[i];
                        _option.selected = false;
                        that.setSelected(_option.liIndex, false);
                      }

                      option.selected = true;
                      that.setSelected(clickedIndex, true);
                    } else {
                      var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,
                          maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,
                          maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),
                          maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),
                          $notify = $('<div class="notify"></div>'); // If {var} is set in array, replace it

                      /** @deprecated */

                      if (maxOptionsArr[2]) {
                        maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
                        maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
                      }

                      option.selected = false;
                      that.$menu.append($notify);

                      if (maxOptions && maxReached) {
                        $notify.append($('<div>' + maxTxt + '</div>'));
                        triggerChange = false;
                        that.$element.trigger('maxReached' + EVENT_KEY);
                      }

                      if (maxOptionsGrp && maxReachedGrp) {
                        $notify.append($('<div>' + maxTxtGrp + '</div>'));
                        triggerChange = false;
                        that.$element.trigger('maxReachedGrp' + EVENT_KEY);
                      }

                      setTimeout(function () {
                        that.setSelected(clickedIndex, false);
                      }, 10);
                      $notify[0].classList.add('fadeOut');
                      setTimeout(function () {
                        $notify.remove();
                      }, 1050);
                    }
                  }
                }
              }

              if (!that.multiple || that.multiple && that.options.maxOptions === 1) {
                that.$button.trigger('focus');
              } else if (that.options.liveSearch) {
                that.$searchbox.trigger('focus');
              } // Trigger select 'change'


              if (triggerChange) {
                if (that.multiple || prevIndex !== element.selectedIndex) {
                  // $option.prop('selected') is current option state (selected/unselected). prevValue is the value of the select prior to being changed.
                  changedArguments = [option.index, $option.prop('selected'), prevValue];
                  that.$element.triggerNative('change');
                }
              }
            }
          });
          this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .' + classNames.POPOVERHEADER + ', .' + classNames.POPOVERHEADER + ' :not(.close)', function (e) {
            if (e.currentTarget == this) {
              e.preventDefault();
              e.stopPropagation();

              if (that.options.liveSearch && !$(e.target).hasClass('close')) {
                that.$searchbox.trigger('focus');
              } else {
                that.$button.trigger('focus');
              }
            }
          });
          this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {
            e.preventDefault();
            e.stopPropagation();

            if (that.options.liveSearch) {
              that.$searchbox.trigger('focus');
            } else {
              that.$button.trigger('focus');
            }
          });
          this.$menu.on('click', '.' + classNames.POPOVERHEADER + ' .close', function () {
            that.$button.trigger('click');
          });
          this.$searchbox.on('click', function (e) {
            e.stopPropagation();
          });
          this.$menu.on('click', '.actions-btn', function (e) {
            if (that.options.liveSearch) {
              that.$searchbox.trigger('focus');
            } else {
              that.$button.trigger('focus');
            }

            e.preventDefault();
            e.stopPropagation();

            if ($(this).hasClass('bs-select-all')) {
              that.selectAll();
            } else {
              that.deselectAll();
            }
          });
          this.$button.on('focus' + EVENT_KEY, function (e) {
            var tabindex = that.$element[0].getAttribute('tabindex'); // only change when button is actually focused

            if (tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {
              // apply select element's tabindex to ensure correct order is followed when tabbing to the next element
              this.setAttribute('tabindex', tabindex); // set element's tabindex to -1 to allow for reverse tabbing

              that.$element[0].setAttribute('tabindex', -1);
              that.selectpicker.view.tabindex = tabindex;
            }
          }).on('blur' + EVENT_KEY, function (e) {
            // revert everything to original tabindex
            if (that.selectpicker.view.tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {
              that.$element[0].setAttribute('tabindex', that.selectpicker.view.tabindex);
              this.setAttribute('tabindex', -1);
              that.selectpicker.view.tabindex = undefined;
            }
          });
          this.$element.on('change' + EVENT_KEY, function () {
            that.render();
            that.$element.trigger('changed' + EVENT_KEY, changedArguments);
            changedArguments = null;
          }).on('focus' + EVENT_KEY, function () {
            if (!that.options.mobile) that.$button[0].focus();
          });
        },
        liveSearchListener: function liveSearchListener() {
          var that = this;
          this.$button.on('click.bs.dropdown.data-api', function () {
            if (!!that.$searchbox.val()) {
              that.$searchbox.val('');
              that.selectpicker.search.previousValue = undefined;
            }
          });
          this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {
            e.stopPropagation();
          });
          this.$searchbox.on('input propertychange', function () {
            var searchValue = that.$searchbox[0].value;
            that.selectpicker.search.elements = [];
            that.selectpicker.search.data = [];

            if (searchValue) {
              var i,
                  searchMatch = [],
                  q = searchValue.toUpperCase(),
                  cache = {},
                  cacheArr = [],
                  searchStyle = that._searchStyle(),
                  normalizeSearch = that.options.liveSearchNormalize;

              if (normalizeSearch) q = normalizeToBase(q);

              for (var i = 0; i < that.selectpicker.main.data.length; i++) {
                var li = that.selectpicker.main.data[i];

                if (!cache[i]) {
                  cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);
                }

                if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {
                  if (li.headerIndex > 0) {
                    cache[li.headerIndex - 1] = true;
                    cacheArr.push(li.headerIndex - 1);
                  }

                  cache[li.headerIndex] = true;
                  cacheArr.push(li.headerIndex);
                  cache[li.lastIndex + 1] = true;
                }

                if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);
              }

              for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {
                var index = cacheArr[i],
                    prevIndex = cacheArr[i - 1],
                    li = that.selectpicker.main.data[index],
                    liPrev = that.selectpicker.main.data[prevIndex];

                if (li.type !== 'divider' || li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i) {
                  that.selectpicker.search.data.push(li);
                  searchMatch.push(that.selectpicker.main.elements[index]);
                }
              }

              that.activeIndex = undefined;
              that.noScroll = true;
              that.$menuInner.scrollTop(0);
              that.selectpicker.search.elements = searchMatch;
              that.createView(true);
              showNoResults.call(that, searchMatch, searchValue);
            } else if (that.selectpicker.search.previousValue) {
              // for IE11 (#2402)
              that.$menuInner.scrollTop(0);
              that.createView(false);
            }

            that.selectpicker.search.previousValue = searchValue;
          });
        },
        _searchStyle: function _searchStyle() {
          return this.options.liveSearchStyle || 'contains';
        },
        val: function val(value) {
          var element = this.$element[0];

          if (typeof value !== 'undefined') {
            var prevValue = getSelectValues(element);
            changedArguments = [null, null, prevValue];
            this.$element.val(value).trigger('changed' + EVENT_KEY, changedArguments);

            if (this.$newElement.hasClass(classNames.SHOW)) {
              if (this.multiple) {
                this.setOptionStatus(true);
              } else {
                var liSelectedIndex = (element.options[element.selectedIndex] || {}).liIndex;

                if (typeof liSelectedIndex === 'number') {
                  this.setSelected(this.selectedIndex, false);
                  this.setSelected(liSelectedIndex, true);
                }
              }
            }

            this.render();
            changedArguments = null;
            return this.$element;
          } else {
            return this.$element.val();
          }
        },
        changeAll: function changeAll(status) {
          if (!this.multiple) return;
          if (typeof status === 'undefined') status = true;
          var element = this.$element[0],
              previousSelected = 0,
              currentSelected = 0,
              prevValue = getSelectValues(element);
          element.classList.add('bs-select-hidden');

          for (var i = 0, data = this.selectpicker.current.data, len = data.length; i < len; i++) {
            var liData = data[i],
                option = liData.option;

            if (option && !liData.disabled && liData.type !== 'divider') {
              if (liData.selected) previousSelected++;
              option.selected = status;
              if (status === true) currentSelected++;
            }
          }

          element.classList.remove('bs-select-hidden');
          if (previousSelected === currentSelected) return;
          this.setOptionStatus();
          changedArguments = [null, null, prevValue];
          this.$element.triggerNative('change');
        },
        selectAll: function selectAll() {
          return this.changeAll(true);
        },
        deselectAll: function deselectAll() {
          return this.changeAll(false);
        },
        toggle: function toggle(e) {
          e = e || window.event;
          if (e) e.stopPropagation();
          this.$button.trigger('click.bs.dropdown.data-api');
        },
        keydown: function keydown(e) {
          var $this = $(this),
              isToggle = $this.hasClass('dropdown-toggle'),
              $parent = isToggle ? $this.closest('.dropdown') : $this.closest(Selector.MENU),
              that = $parent.data('this'),
              $items = that.findLis(),
              index,
              isActive,
              liActive,
              activeLi,
              offset,
              updateScroll = false,
              downOnTab = e.which === keyCodes.TAB && !isToggle && !that.options.selectOnTab,
              isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,
              scrollTop = that.$menuInner[0].scrollTop,
              isVirtual = that.isVirtual(),
              position0 = isVirtual === true ? that.selectpicker.view.position0 : 0; // do nothing if a function key is pressed

          if (e.which >= 112 && e.which <= 123) return;
          isActive = that.$newElement.hasClass(classNames.SHOW);

          if (!isActive && (isArrowKey || e.which >= 48 && e.which <= 57 || e.which >= 96 && e.which <= 105 || e.which >= 65 && e.which <= 90)) {
            that.$button.trigger('click.bs.dropdown.data-api');

            if (that.options.liveSearch) {
              that.$searchbox.trigger('focus');
              return;
            }
          }

          if (e.which === keyCodes.ESCAPE && isActive) {
            e.preventDefault();
            that.$button.trigger('click.bs.dropdown.data-api').trigger('focus');
          }

          if (isArrowKey) {
            // if up or down
            if (!$items.length) return;
            liActive = that.selectpicker.main.elements[that.activeIndex];
            index = liActive ? Array.prototype.indexOf.call(liActive.parentElement.children, liActive) : -1;

            if (index !== -1) {
              that.defocusItem(liActive);
            }

            if (e.which === keyCodes.ARROW_UP) {
              // up
              if (index !== -1) index--;
              if (index + position0 < 0) index += $items.length;

              if (!that.selectpicker.view.canHighlight[index + position0]) {
                index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;
                if (index === -1) index = $items.length - 1;
              }
            } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) {
              // down
              index++;
              if (index + position0 >= that.selectpicker.view.canHighlight.length) index = that.selectpicker.view.firstHighlightIndex;

              if (!that.selectpicker.view.canHighlight[index + position0]) {
                index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);
              }
            }

            e.preventDefault();
            var liActiveIndex = position0 + index;

            if (e.which === keyCodes.ARROW_UP) {
              // up
              // scroll to bottom and highlight last option
              if (position0 === 0 && index === $items.length - 1) {
                that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;
                liActiveIndex = that.selectpicker.current.elements.length - 1;
              } else {
                activeLi = that.selectpicker.current.data[liActiveIndex];
                offset = activeLi.position - activeLi.height;
                updateScroll = offset < scrollTop;
              }
            } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) {
              // down
              // scroll to top and highlight first option
              if (index === that.selectpicker.view.firstHighlightIndex) {
                that.$menuInner[0].scrollTop = 0;
                liActiveIndex = that.selectpicker.view.firstHighlightIndex;
              } else {
                activeLi = that.selectpicker.current.data[liActiveIndex];
                offset = activeLi.position - that.sizeInfo.menuInnerHeight;
                updateScroll = offset > scrollTop;
              }
            }

            liActive = that.selectpicker.current.elements[liActiveIndex];
            that.activeIndex = that.selectpicker.current.data[liActiveIndex].index;
            that.focusItem(liActive);
            that.selectpicker.view.currentActive = liActive;
            if (updateScroll) that.$menuInner[0].scrollTop = offset;

            if (that.options.liveSearch) {
              that.$searchbox.trigger('focus');
            } else {
              $this.trigger('focus');
            }
          } else if (!$this.is('input') && !REGEXP_TAB_OR_ESCAPE.test(e.which) || e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory) {
            var searchMatch,
                matches = [],
                keyHistory;
            e.preventDefault();
            that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];
            if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);
            that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();
            keyHistory = that.selectpicker.keydown.keyHistory; // if all letters are the same, set keyHistory to just the first character when searching

            if (/^(.)\1+$/.test(keyHistory)) {
              keyHistory = keyHistory.charAt(0);
            } // find matches


            for (var i = 0; i < that.selectpicker.current.data.length; i++) {
              var li = that.selectpicker.current.data[i],
                  hasMatch;
              hasMatch = stringSearch(li, keyHistory, 'startsWith', true);

              if (hasMatch && that.selectpicker.view.canHighlight[i]) {
                matches.push(li.index);
              }
            }

            if (matches.length) {
              var matchIndex = 0;
              $items.removeClass('active').find('a').removeClass('active'); // either only one key has been pressed or they are all the same key

              if (keyHistory.length === 1) {
                matchIndex = matches.indexOf(that.activeIndex);

                if (matchIndex === -1 || matchIndex === matches.length - 1) {
                  matchIndex = 0;
                } else {
                  matchIndex++;
                }
              }

              searchMatch = matches[matchIndex];
              activeLi = that.selectpicker.main.data[searchMatch];

              if (scrollTop - activeLi.position > 0) {
                offset = activeLi.position - activeLi.height;
                updateScroll = true;
              } else {
                offset = activeLi.position - that.sizeInfo.menuInnerHeight; // if the option is already visible at the current scroll position, just keep it the same

                updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;
              }

              liActive = that.selectpicker.main.elements[searchMatch];
              that.activeIndex = matches[matchIndex];
              that.focusItem(liActive);
              if (liActive) liActive.firstChild.focus();
              if (updateScroll) that.$menuInner[0].scrollTop = offset;
              $this.trigger('focus');
            }
          } // Select focused option if "Enter", "Spacebar" or "Tab" (when selectOnTab is true) are pressed inside the menu.


          if (isActive && (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory || e.which === keyCodes.ENTER || e.which === keyCodes.TAB && that.options.selectOnTab)) {
            if (e.which !== keyCodes.SPACE) e.preventDefault();

            if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {
              that.$menuInner.find('.active a').trigger('click', true); // retain active class

              $this.trigger('focus');

              if (!that.options.liveSearch) {
                // Prevent screen from scrolling if the user hits the spacebar
                e.preventDefault(); // Fixes spacebar selection of dropdown items in FF & IE

                $(document).data('spaceSelect', true);
              }
            }
          }
        },
        mobile: function mobile() {
          // ensure mobile is set to true if mobile function is called after init
          this.options.mobile = true;
          this.$element[0].classList.add('mobile-device');
        },
        refresh: function refresh() {
          // update options if data attributes have been changed
          var config = $.extend({}, this.options, this.$element.data());
          this.options = config;
          this.checkDisabled();
          this.buildData();
          this.setStyle();
          this.render();
          this.buildList();
          this.setWidth();
          this.setSize(true);
          this.$element.trigger('refreshed' + EVENT_KEY);
        },
        hide: function hide() {
          this.$newElement.hide();
        },
        show: function show() {
          this.$newElement.show();
        },
        remove: function remove() {
          this.$newElement.remove();
          this.$element.remove();
        },
        destroy: function destroy() {
          this.$newElement.before(this.$element).remove();

          if (this.$bsContainer) {
            this.$bsContainer.remove();
          } else {
            this.$menu.remove();
          }

          if (this.selectpicker.view.titleOption && this.selectpicker.view.titleOption.parentNode) {
            this.selectpicker.view.titleOption.parentNode.removeChild(this.selectpicker.view.titleOption);
          }

          this.$element.off(EVENT_KEY).removeData('selectpicker').removeClass('bs-select-hidden selectpicker');
          $(window).off(EVENT_KEY + '.' + this.selectId);
        }
      }; // SELECTPICKER PLUGIN DEFINITION
      // ==============================

      function Plugin(option) {
        // get the args of the outer function..
        var args = arguments; // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them
        // to get lost/corrupted in android 2.3 and IE9 #715 #775

        var _option = option;
        [].shift.apply(args); // if the version was not set successfully

        if (!version.success) {
          // try to retreive it again
          try {
            version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');
          } catch (err) {
            // fall back to use BootstrapVersion if set
            if (Selectpicker.BootstrapVersion) {
              version.full = Selectpicker.BootstrapVersion.split(' ')[0].split('.');
            } else {
              version.full = [version.major, '0', '0'];
              console.warn('There was an issue retrieving Bootstrap\'s version. ' + 'Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. ' + 'If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.', err);
            }
          }

          version.major = version.full[0];
          version.success = true;
        }

        if (version.major === '4') {
          // some defaults need to be changed if using Bootstrap 4
          // check to see if they have already been manually changed before forcing them to update
          var toUpdate = [];
          if (Selectpicker.DEFAULTS.style === classNames.BUTTONCLASS) toUpdate.push({
            name: 'style',
            className: 'BUTTONCLASS'
          });
          if (Selectpicker.DEFAULTS.iconBase === classNames.ICONBASE) toUpdate.push({
            name: 'iconBase',
            className: 'ICONBASE'
          });
          if (Selectpicker.DEFAULTS.tickIcon === classNames.TICKICON) toUpdate.push({
            name: 'tickIcon',
            className: 'TICKICON'
          });
          classNames.DIVIDER = 'dropdown-divider';
          classNames.SHOW = 'show';
          classNames.BUTTONCLASS = 'btn-light';
          classNames.POPOVERHEADER = 'popover-header';
          classNames.ICONBASE = '';
          classNames.TICKICON = 'bs-ok-default';

          for (var i = 0; i < toUpdate.length; i++) {
            var option = toUpdate[i];
            Selectpicker.DEFAULTS[option.name] = classNames[option.className];
          }
        }

        var value;
        var chain = this.each(function () {
          var $this = $(this);

          if ($this.is('select')) {
            var data = $this.data('selectpicker'),
                options = _typeof(_option) == 'object' && _option;

            if (!data) {
              var dataAttributes = $this.data();

              for (var dataAttr in dataAttributes) {
                if (Object.prototype.hasOwnProperty.call(dataAttributes, dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {
                  delete dataAttributes[dataAttr];
                }
              }

              var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, dataAttributes, options);
              config.template = $.extend({}, Selectpicker.DEFAULTS.template, $.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}, dataAttributes.template, options.template);
              $this.data('selectpicker', data = new Selectpicker(this, config));
            } else if (options) {
              for (var i in options) {
                if (Object.prototype.hasOwnProperty.call(options, i)) {
                  data.options[i] = options[i];
                }
              }
            }

            if (typeof _option == 'string') {
              if (data[_option] instanceof Function) {
                value = data[_option].apply(data, args);
              } else {
                value = data.options[_option];
              }
            }
          }
        });

        if (typeof value !== 'undefined') {
          // noinspection JSUnusedAssignment
          return value;
        } else {
          return chain;
        }
      }

      var old = $.fn.selectpicker;
      $.fn.selectpicker = Plugin;
      $.fn.selectpicker.Constructor = Selectpicker; // SELECTPICKER NO CONFLICT
      // ========================

      $.fn.selectpicker.noConflict = function () {
        $.fn.selectpicker = old;
        return this;
      }; // get Bootstrap's keydown event handler for either Bootstrap 4 or Bootstrap 3


      function keydownHandler() {
        if ($.fn.dropdown) {
          // wait to define until function is called in case Bootstrap isn't loaded yet
          var bootstrapKeydown = $.fn.dropdown.Constructor._dataApiKeydownHandler || $.fn.dropdown.Constructor.prototype.keydown;
          return bootstrapKeydown.apply(this, arguments);
        }
      }

      $(document).off('keydown.bs.dropdown.data-api').on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > [data-toggle="dropdown"]', keydownHandler).on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > .dropdown-menu', keydownHandler).on('keydown' + EVENT_KEY, '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input', Selectpicker.prototype.keydown).on('focusin.modal', '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input', function (e) {
        e.stopPropagation();
      }); // SELECTPICKER DATA-API
      // =====================

      $(window).on('load' + EVENT_KEY + '.data-api', function () {
        $('.selectpicker').each(function () {
          var $selectpicker = $(this);
          Plugin.call($selectpicker, $selectpicker.data());
        });
      });
    })(jQuery);
    /***/

  },

  /***/
  "./resources/assets/vendor/libs/bootstrap-select/bootstrap-select.js":
  /*!***************************************************************************!*\
    !*** ./resources/assets/vendor/libs/bootstrap-select/bootstrap-select.js ***!
    \***************************************************************************/

  /*! no static exports found */

  /***/
  function resourcesAssetsVendorLibsBootstrapSelectBootstrapSelectJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! bootstrap-select/js/bootstrap-select.js */
    "./node_modules/bootstrap-select/js/bootstrap-select.js");
    /***/

  },

  /***/
  27:
  /*!*********************************************************************************!*\
    !*** multi ./resources/assets/vendor/libs/bootstrap-select/bootstrap-select.js ***!
    \*********************************************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\xampp\htdocs\globalplanthire\resources\assets\vendor\libs\bootstrap-select\bootstrap-select.js */
    "./resources/assets/vendor/libs/bootstrap-select/bootstrap-select.js");
    /***/
  }
  /******/

}));

/***/ }),

/***/ "./resources/assets/libs/bootstrap-tagsinput/bootstrap-tagsinput.js":
/*!**************************************************************************!*\
  !*** ./resources/assets/libs/bootstrap-tagsinput/bootstrap-tagsinput.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(window,
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "/";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 58);
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "./node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesBootstrapTagsinputDistBootstrapTagsinputJs(module, exports) {
    (function ($) {
      "use strict";

      var defaultOptions = {
        tagClass: function tagClass(item) {
          return 'label label-info';
        },
        itemValue: function itemValue(item) {
          return item ? item.toString() : item;
        },
        itemText: function itemText(item) {
          return this.itemValue(item);
        },
        itemTitle: function itemTitle(item) {
          return null;
        },
        freeInput: true,
        addOnBlur: true,
        maxTags: undefined,
        maxChars: undefined,
        confirmKeys: [13, 44],
        delimiter: ',',
        delimiterRegex: null,
        cancelConfirmKeysOnEmpty: false,
        onTagExists: function onTagExists(item, $tag) {
          $tag.hide().fadeIn();
        },
        trimValue: false,
        allowDuplicates: false
      };
      /**
       * Constructor function
       */

      function TagsInput(element, options) {
        this.isInit = true;
        this.itemsArray = [];
        this.$element = $(element);
        this.$element.hide();
        this.isSelect = element.tagName === 'SELECT';
        this.multiple = this.isSelect && element.hasAttribute('multiple');
        this.objectItems = options && options.itemValue;
        this.placeholderText = element.hasAttribute('placeholder') ? this.$element.attr('placeholder') : '';
        this.inputSize = Math.max(1, this.placeholderText.length);
        this.$container = $('<div class="bootstrap-tagsinput"></div>');
        this.$input = $('<input type="text" placeholder="' + this.placeholderText + '"/>').appendTo(this.$container);
        this.$element.before(this.$container);
        this.build(options);
        this.isInit = false;
      }

      TagsInput.prototype = {
        constructor: TagsInput,

        /**
         * Adds the given item as a new tag. Pass true to dontPushVal to prevent
         * updating the elements val()
         */
        add: function add(item, dontPushVal, options) {
          var self = this;
          if (self.options.maxTags && self.itemsArray.length >= self.options.maxTags) return; // Ignore falsey values, except false

          if (item !== false && !item) return; // Trim value

          if (typeof item === "string" && self.options.trimValue) {
            item = $.trim(item);
          } // Throw an error when trying to add an object while the itemValue option was not set


          if (_typeof(item) === "object" && !self.objectItems) throw "Can't add objects when itemValue option is not set"; // Ignore strings only containg whitespace

          if (item.toString().match(/^\s*$/)) return; // If SELECT but not multiple, remove current tag

          if (self.isSelect && !self.multiple && self.itemsArray.length > 0) self.remove(self.itemsArray[0]);

          if (typeof item === "string" && this.$element[0].tagName === 'INPUT') {
            var delimiter = self.options.delimiterRegex ? self.options.delimiterRegex : self.options.delimiter;
            var items = item.split(delimiter);

            if (items.length > 1) {
              for (var i = 0; i < items.length; i++) {
                this.add(items[i], true);
              }

              if (!dontPushVal) self.pushVal();
              return;
            }
          }

          var itemValue = self.options.itemValue(item),
              itemText = self.options.itemText(item),
              tagClass = self.options.tagClass(item),
              itemTitle = self.options.itemTitle(item); // Ignore items allready added

          var existing = $.grep(self.itemsArray, function (item) {
            return self.options.itemValue(item) === itemValue;
          })[0];

          if (existing && !self.options.allowDuplicates) {
            // Invoke onTagExists
            if (self.options.onTagExists) {
              var $existingTag = $(".tag", self.$container).filter(function () {
                return $(this).data("item") === existing;
              });
              self.options.onTagExists(item, $existingTag);
            }

            return;
          } // if length greater than limit


          if (self.items().toString().length + item.length + 1 > self.options.maxInputLength) return; // raise beforeItemAdd arg

          var beforeItemAddEvent = $.Event('beforeItemAdd', {
            item: item,
            cancel: false,
            options: options
          });
          self.$element.trigger(beforeItemAddEvent);
          if (beforeItemAddEvent.cancel) return; // register item in internal array and map

          self.itemsArray.push(item); // add a tag element

          var $tag = $('<span class="tag ' + htmlEncode(tagClass) + (itemTitle !== null ? '" title="' + itemTitle : '') + '">' + htmlEncode(itemText) + '<span data-role="remove"></span></span>');
          $tag.data('item', item);
          self.findInputWrapper().before($tag);
          $tag.after(' '); // Check to see if the tag exists in its raw or uri-encoded form

          var optionExists = $('option[value="' + encodeURIComponent(itemValue) + '"]', self.$element).length || $('option[value="' + htmlEncode(itemValue) + '"]', self.$element).length; // add <option /> if item represents a value not present in one of the <select />'s options

          if (self.isSelect && !optionExists) {
            var $option = $('<option selected>' + htmlEncode(itemText) + '</option>');
            $option.data('item', item);
            $option.attr('value', itemValue);
            self.$element.append($option);
          }

          if (!dontPushVal) self.pushVal(); // Add class when reached maxTags

          if (self.options.maxTags === self.itemsArray.length || self.items().toString().length === self.options.maxInputLength) self.$container.addClass('bootstrap-tagsinput-max'); // If using typeahead, once the tag has been added, clear the typeahead value so it does not stick around in the input.

          if ($('.typeahead, .twitter-typeahead', self.$container).length) {
            self.$input.typeahead('val', '');
          }

          if (this.isInit) {
            self.$element.trigger($.Event('itemAddedOnInit', {
              item: item,
              options: options
            }));
          } else {
            self.$element.trigger($.Event('itemAdded', {
              item: item,
              options: options
            }));
          }
        },

        /**
         * Removes the given item. Pass true to dontPushVal to prevent updating the
         * elements val()
         */
        remove: function remove(item, dontPushVal, options) {
          var self = this;

          if (self.objectItems) {
            if (_typeof(item) === "object") item = $.grep(self.itemsArray, function (other) {
              return self.options.itemValue(other) == self.options.itemValue(item);
            });else item = $.grep(self.itemsArray, function (other) {
              return self.options.itemValue(other) == item;
            });
            item = item[item.length - 1];
          }

          if (item) {
            var beforeItemRemoveEvent = $.Event('beforeItemRemove', {
              item: item,
              cancel: false,
              options: options
            });
            self.$element.trigger(beforeItemRemoveEvent);
            if (beforeItemRemoveEvent.cancel) return;
            $('.tag', self.$container).filter(function () {
              return $(this).data('item') === item;
            }).remove();
            $('option', self.$element).filter(function () {
              return $(this).data('item') === item;
            }).remove();
            if ($.inArray(item, self.itemsArray) !== -1) self.itemsArray.splice($.inArray(item, self.itemsArray), 1);
          }

          if (!dontPushVal) self.pushVal(); // Remove class when reached maxTags

          if (self.options.maxTags > self.itemsArray.length) self.$container.removeClass('bootstrap-tagsinput-max');
          self.$element.trigger($.Event('itemRemoved', {
            item: item,
            options: options
          }));
        },

        /**
         * Removes all items
         */
        removeAll: function removeAll() {
          var self = this;
          $('.tag', self.$container).remove();
          $('option', self.$element).remove();

          while (self.itemsArray.length > 0) {
            self.itemsArray.pop();
          }

          self.pushVal();
        },

        /**
         * Refreshes the tags so they match the text/value of their corresponding
         * item.
         */
        refresh: function refresh() {
          var self = this;
          $('.tag', self.$container).each(function () {
            var $tag = $(this),
                item = $tag.data('item'),
                itemValue = self.options.itemValue(item),
                itemText = self.options.itemText(item),
                tagClass = self.options.tagClass(item); // Update tag's class and inner text

            $tag.attr('class', null);
            $tag.addClass('tag ' + htmlEncode(tagClass));
            $tag.contents().filter(function () {
              return this.nodeType == 3;
            })[0].nodeValue = htmlEncode(itemText);

            if (self.isSelect) {
              var option = $('option', self.$element).filter(function () {
                return $(this).data('item') === item;
              });
              option.attr('value', itemValue);
            }
          });
        },

        /**
         * Returns the items added as tags
         */
        items: function items() {
          return this.itemsArray;
        },

        /**
         * Assembly value by retrieving the value of each item, and set it on the
         * element.
         */
        pushVal: function pushVal() {
          var self = this,
              val = $.map(self.items(), function (item) {
            return self.options.itemValue(item).toString();
          });
          self.$element.val(val, true).trigger('change');
        },

        /**
         * Initializes the tags input behaviour on the element
         */
        build: function build(options) {
          var self = this;
          self.options = $.extend({}, defaultOptions, options); // When itemValue is set, freeInput should always be false

          if (self.objectItems) self.options.freeInput = false;
          makeOptionItemFunction(self.options, 'itemValue');
          makeOptionItemFunction(self.options, 'itemText');
          makeOptionFunction(self.options, 'tagClass'); // Typeahead Bootstrap version 2.3.2

          if (self.options.typeahead) {
            var typeahead = self.options.typeahead || {};
            makeOptionFunction(typeahead, 'source');
            self.$input.typeahead($.extend({}, typeahead, {
              source: function source(query, process) {
                function processItems(items) {
                  var texts = [];

                  for (var i = 0; i < items.length; i++) {
                    var text = self.options.itemText(items[i]);
                    map[text] = items[i];
                    texts.push(text);
                  }

                  process(texts);
                }

                this.map = {};
                var map = this.map,
                    data = typeahead.source(query);

                if ($.isFunction(data.success)) {
                  // support for Angular callbacks
                  data.success(processItems);
                } else if ($.isFunction(data.then)) {
                  // support for Angular promises
                  data.then(processItems);
                } else {
                  // support for functions and jquery promises
                  $.when(data).then(processItems);
                }
              },
              updater: function updater(text) {
                self.add(this.map[text]);
                return this.map[text];
              },
              matcher: function matcher(text) {
                return text.toLowerCase().indexOf(this.query.trim().toLowerCase()) !== -1;
              },
              sorter: function sorter(texts) {
                return texts.sort();
              },
              highlighter: function highlighter(text) {
                var regex = new RegExp('(' + this.query + ')', 'gi');
                return text.replace(regex, "<strong>$1</strong>");
              }
            }));
          } // typeahead.js


          if (self.options.typeaheadjs) {
            var typeaheadConfig = null;
            var typeaheadDatasets = {}; // Determine if main configurations were passed or simply a dataset

            var typeaheadjs = self.options.typeaheadjs;

            if ($.isArray(typeaheadjs)) {
              typeaheadConfig = typeaheadjs[0];
              typeaheadDatasets = typeaheadjs[1];
            } else {
              typeaheadDatasets = typeaheadjs;
            }

            self.$input.typeahead(typeaheadConfig, typeaheadDatasets).on('typeahead:selected', $.proxy(function (obj, datum) {
              if (typeaheadDatasets.valueKey) self.add(datum[typeaheadDatasets.valueKey]);else self.add(datum);
              self.$input.typeahead('val', '');
            }, self));
          }

          self.$container.on('click', $.proxy(function (event) {
            if (!self.$element.attr('disabled')) {
              self.$input.removeAttr('disabled');
            }

            self.$input.focus();
          }, self));

          if (self.options.addOnBlur && self.options.freeInput) {
            self.$input.on('focusout', $.proxy(function (event) {
              // HACK: only process on focusout when no typeahead opened, to
              //       avoid adding the typeahead text as tag
              if ($('.typeahead, .twitter-typeahead', self.$container).length === 0) {
                self.add(self.$input.val());
                self.$input.val('');
              }
            }, self));
          }

          self.$container.on('keydown', 'input', $.proxy(function (event) {
            var $input = $(event.target),
                $inputWrapper = self.findInputWrapper();

            if (self.$element.attr('disabled')) {
              self.$input.attr('disabled', 'disabled');
              return;
            }

            switch (event.which) {
              // BACKSPACE
              case 8:
                if (doGetCaretPosition($input[0]) === 0) {
                  var prev = $inputWrapper.prev();

                  if (prev.length) {
                    self.remove(prev.data('item'));
                  }
                }

                break;
              // DELETE

              case 46:
                if (doGetCaretPosition($input[0]) === 0) {
                  var next = $inputWrapper.next();

                  if (next.length) {
                    self.remove(next.data('item'));
                  }
                }

                break;
              // LEFT ARROW

              case 37:
                // Try to move the input before the previous tag
                var $prevTag = $inputWrapper.prev();

                if ($input.val().length === 0 && $prevTag[0]) {
                  $prevTag.before($inputWrapper);
                  $input.focus();
                }

                break;
              // RIGHT ARROW

              case 39:
                // Try to move the input after the next tag
                var $nextTag = $inputWrapper.next();

                if ($input.val().length === 0 && $nextTag[0]) {
                  $nextTag.after($inputWrapper);
                  $input.focus();
                }

                break;

              default: // ignore

            } // Reset internal input's size


            var textLength = $input.val().length,
                wordSpace = Math.ceil(textLength / 5),
                size = textLength + wordSpace + 1;
            $input.attr('size', Math.max(this.inputSize, $input.val().length));
          }, self));
          self.$container.on('keypress', 'input', $.proxy(function (event) {
            var $input = $(event.target);

            if (self.$element.attr('disabled')) {
              self.$input.attr('disabled', 'disabled');
              return;
            }

            var text = $input.val(),
                maxLengthReached = self.options.maxChars && text.length >= self.options.maxChars;

            if (self.options.freeInput && (keyCombinationInList(event, self.options.confirmKeys) || maxLengthReached)) {
              // Only attempt to add a tag if there is data in the field
              if (text.length !== 0) {
                self.add(maxLengthReached ? text.substr(0, self.options.maxChars) : text);
                $input.val('');
              } // If the field is empty, let the event triggered fire as usual


              if (self.options.cancelConfirmKeysOnEmpty === false) {
                event.preventDefault();
              }
            } // Reset internal input's size


            var textLength = $input.val().length,
                wordSpace = Math.ceil(textLength / 5),
                size = textLength + wordSpace + 1;
            $input.attr('size', Math.max(this.inputSize, $input.val().length));
          }, self)); // Remove icon clicked

          self.$container.on('click', '[data-role=remove]', $.proxy(function (event) {
            if (self.$element.attr('disabled')) {
              return;
            }

            self.remove($(event.target).closest('.tag').data('item'));
          }, self)); // Only add existing value as tags when using strings as tags

          if (self.options.itemValue === defaultOptions.itemValue) {
            if (self.$element[0].tagName === 'INPUT') {
              self.add(self.$element.val());
            } else {
              $('option', self.$element).each(function () {
                self.add($(this).attr('value'), true);
              });
            }
          }
        },

        /**
         * Removes all tagsinput behaviour and unregsiter all event handlers
         */
        destroy: function destroy() {
          var self = this; // Unbind events

          self.$container.off('keypress', 'input');
          self.$container.off('click', '[role=remove]');
          self.$container.remove();
          self.$element.removeData('tagsinput');
          self.$element.show();
        },

        /**
         * Sets focus on the tagsinput
         */
        focus: function focus() {
          this.$input.focus();
        },

        /**
         * Returns the internal input element
         */
        input: function input() {
          return this.$input;
        },

        /**
         * Returns the element which is wrapped around the internal input. This
         * is normally the $container, but typeahead.js moves the $input element.
         */
        findInputWrapper: function findInputWrapper() {
          var elt = this.$input[0],
              container = this.$container[0];

          while (elt && elt.parentNode !== container) {
            elt = elt.parentNode;
          }

          return $(elt);
        }
      };
      /**
       * Register JQuery plugin
       */

      $.fn.tagsinput = function (arg1, arg2, arg3) {
        var results = [];
        this.each(function () {
          var tagsinput = $(this).data('tagsinput'); // Initialize a new tags input

          if (!tagsinput) {
            tagsinput = new TagsInput(this, arg1);
            $(this).data('tagsinput', tagsinput);
            results.push(tagsinput);

            if (this.tagName === 'SELECT') {
              $('option', $(this)).attr('selected', 'selected');
            } // Init tags from $(this).val()


            $(this).val($(this).val());
          } else if (!arg1 && !arg2) {
            // tagsinput already exists
            // no function, trying to init
            results.push(tagsinput);
          } else if (tagsinput[arg1] !== undefined) {
            // Invoke function on existing tags input
            if (tagsinput[arg1].length === 3 && arg3 !== undefined) {
              var retVal = tagsinput[arg1](arg2, null, arg3);
            } else {
              var retVal = tagsinput[arg1](arg2);
            }

            if (retVal !== undefined) results.push(retVal);
          }
        });

        if (typeof arg1 == 'string') {
          // Return the results from the invoked function calls
          return results.length > 1 ? results : results[0];
        } else {
          return results;
        }
      };

      $.fn.tagsinput.Constructor = TagsInput;
      /**
       * Most options support both a string or number as well as a function as
       * option value. This function makes sure that the option with the given
       * key in the given options is wrapped in a function
       */

      function makeOptionItemFunction(options, key) {
        if (typeof options[key] !== 'function') {
          var propertyName = options[key];

          options[key] = function (item) {
            return item[propertyName];
          };
        }
      }

      function makeOptionFunction(options, key) {
        if (typeof options[key] !== 'function') {
          var value = options[key];

          options[key] = function () {
            return value;
          };
        }
      }
      /**
       * HtmlEncodes the given value
       */


      var htmlEncodeContainer = $('<div />');

      function htmlEncode(value) {
        if (value) {
          return htmlEncodeContainer.text(value).html();
        } else {
          return '';
        }
      }
      /**
       * Returns the position of the caret in the given input field
       * http://flightschool.acylt.com/devnotes/caret-position-woes/
       */


      function doGetCaretPosition(oField) {
        var iCaretPos = 0;

        if (document.selection) {
          oField.focus();
          var oSel = document.selection.createRange();
          oSel.moveStart('character', -oField.value.length);
          iCaretPos = oSel.text.length;
        } else if (oField.selectionStart || oField.selectionStart == '0') {
          iCaretPos = oField.selectionStart;
        }

        return iCaretPos;
      }
      /**
        * Returns boolean indicates whether user has pressed an expected key combination.
        * @param object keyPressEvent: JavaScript event object, refer
        *     http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
        * @param object lookupList: expected key combinations, as in:
        *     [13, {which: 188, shiftKey: true}]
        */


      function keyCombinationInList(keyPressEvent, lookupList) {
        var found = false;
        $.each(lookupList, function (index, keyCombination) {
          if (typeof keyCombination === 'number' && keyPressEvent.which === keyCombination) {
            found = true;
            return false;
          }

          if (keyPressEvent.which === keyCombination.which) {
            var alt = !keyCombination.hasOwnProperty('altKey') || keyPressEvent.altKey === keyCombination.altKey,
                shift = !keyCombination.hasOwnProperty('shiftKey') || keyPressEvent.shiftKey === keyCombination.shiftKey,
                ctrl = !keyCombination.hasOwnProperty('ctrlKey') || keyPressEvent.ctrlKey === keyCombination.ctrlKey;

            if (alt && shift && ctrl) {
              found = true;
              return false;
            }
          }
        });
        return found;
      }
      /**
       * Initialize tagsinput behaviour on inputs and selects which have
       * data-role=tagsinput
       */


      $(function () {
        $("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput();
      });
    })(window.jQuery);
    /***/

  },

  /***/
  "./resources/assets/vendor/libs/bootstrap-tagsinput/_extension.js":
  /*!************************************************************************!*\
    !*** ./resources/assets/vendor/libs/bootstrap-tagsinput/_extension.js ***!
    \************************************************************************/

  /*! no static exports found */

  /***/
  function resourcesAssetsVendorLibsBootstrapTagsinput_extensionJs(module, exports) {
    // Fix input position calculation
    //
    var tagsinputBuild = $.fn.tagsinput.Constructor.prototype.build;
    var tagsinputDestroy = $.fn.tagsinput.Constructor.prototype.destroy;

    $.fn.tagsinput.Constructor.prototype.build = function (options) {
      var _this = this;

      if (options && options.typeahead) {
        $.extend(options.typeahead, {
          minLength: 1,
          afterSelect: function afterSelect() {
            _this.$input[0].value = '';

            _this.$input.data('typeahead').lookup('');
          }
        });
      }

      var result = tagsinputBuild.call(this, options);
      var re = /<|>/g;
      this.$inpWidth = $('<div class="bootstrap-tagsinput-input" style="position:absolute;z-index:-101;top:-9999px;opacity:0;white-space:nowrap;"></div>');
      $('<div style="position:absolute;width:0;height:0;z-index:-100;opacity:0;overflow:hidden;"></div>').append(this.$inpWidth).prependTo(this.$container);

      var getWidth = function getWidth(val) {
        return Math.ceil(_this.$inpWidth.html((val || '').replace(re, '#')).outerWidth() + 12) + 'px';
      };

      this.$input[0].style.width = getWidth();
      this.$input.on('keydown keyup focusout', function () {
        this.style.width = getWidth(this.value);

        if (this.value.length < 1 && options && options.typeahead) {
          $(this).data('typeahead').lookup('');
        }
      });
      this.$input.on('paste', function () {
        setTimeout($.proxy(function () {
          this.style.width = getWidth(this.value);
        }, this), 100);
      });
      return result;
    };

    $.fn.tagsinput.Constructor.prototype.destroy = function () {
      this.$input.off('keydown keyup focusout paste change');
      return tagsinputDestroy.call(this);
    }; // Re-initialize [data-role=tagsinput]


    $(function () {
      $('input[data-role=tagsinput], select[multiple][data-role=tagsinput]').tagsinput('destroy');
      $('input[data-role=tagsinput], select[multiple][data-role=tagsinput]').tagsinput();
    });
    /***/
  },

  /***/
  "./resources/assets/vendor/libs/bootstrap-tagsinput/bootstrap-tagsinput.js":
  /*!*********************************************************************************!*\
    !*** ./resources/assets/vendor/libs/bootstrap-tagsinput/bootstrap-tagsinput.js ***!
    \*********************************************************************************/

  /*! no static exports found */

  /***/
  function resourcesAssetsVendorLibsBootstrapTagsinputBootstrapTagsinputJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! bootstrap-tagsinput/dist/bootstrap-tagsinput.js */
    "./node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.js");

    __webpack_require__(
    /*! ./_extension.js */
    "./resources/assets/vendor/libs/bootstrap-tagsinput/_extension.js");
    /***/

  },

  /***/
  58:
  /*!***************************************************************************************!*\
    !*** multi ./resources/assets/vendor/libs/bootstrap-tagsinput/bootstrap-tagsinput.js ***!
    \***************************************************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\xampp\htdocs\globalplanthire\resources\assets\vendor\libs\bootstrap-tagsinput\bootstrap-tagsinput.js */
    "./resources/assets/vendor/libs/bootstrap-tagsinput/bootstrap-tagsinput.js");
    /***/
  }
  /******/

}));

/***/ }),

/***/ "./resources/assets/libs/datatables/datatables.js":
/*!********************************************************!*\
  !*** ./resources/assets/libs/datatables/datatables.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(window,
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "/";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 65);
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesDatatablesNetBs4JsDataTablesBootstrap4Js(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*! DataTables Bootstrap 4 integration
    * 2011-2017 SpryMedia Ltd - datatables.net/license
    */

    /**
     * DataTables integration for Bootstrap 4. This requires Bootstrap 4 and
     * DataTables 1.10 or newer.
     *
     * This file sets the defaults and adds options to DataTables to style its
     * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
     * for further information.
     */


    (function (factory) {
      if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(
        /*! jquery */
        "jquery"), __webpack_require__(
        /*! datatables.net */
        "datatables.net")], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
          return factory($, window, document);
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {}
    })(function ($, window, document, undefined) {
      'use strict';

      var DataTable = $.fn.dataTable;
      /* Set the defaults for DataTables initialisation */

      $.extend(true, DataTable.defaults, {
        dom: "<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>>" + "<'row'<'col-sm-12'tr>>" + "<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>",
        renderer: 'bootstrap'
      });
      /* Default class modification */

      $.extend(DataTable.ext.classes, {
        sWrapper: "dataTables_wrapper dt-bootstrap4",
        sFilterInput: "form-control form-control-sm",
        sLengthSelect: "custom-select custom-select-sm form-control form-control-sm",
        sProcessing: "dataTables_processing card",
        sPageButton: "paginate_button page-item"
      });
      /* Bootstrap paging button renderer */

      DataTable.ext.renderer.pageButton.bootstrap = function (settings, host, idx, buttons, page, pages) {
        var api = new DataTable.Api(settings);
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay,
            btnClass,
            counter = 0;

        var attach = function attach(container, buttons) {
          var i, ien, node, button;

          var clickHandler = function clickHandler(e) {
            e.preventDefault();

            if (!$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action) {
              api.page(e.data.action).draw('page');
            }
          };

          for (i = 0, ien = buttons.length; i < ien; i++) {
            button = buttons[i];

            if (Array.isArray(button)) {
              attach(container, button);
            } else {
              btnDisplay = '';
              btnClass = '';

              switch (button) {
                case 'ellipsis':
                  btnDisplay = '&#x2026;';
                  btnClass = 'disabled';
                  break;

                case 'first':
                  btnDisplay = lang.sFirst;
                  btnClass = button + (page > 0 ? '' : ' disabled');
                  break;

                case 'previous':
                  btnDisplay = lang.sPrevious;
                  btnClass = button + (page > 0 ? '' : ' disabled');
                  break;

                case 'next':
                  btnDisplay = lang.sNext;
                  btnClass = button + (page < pages - 1 ? '' : ' disabled');
                  break;

                case 'last':
                  btnDisplay = lang.sLast;
                  btnClass = button + (page < pages - 1 ? '' : ' disabled');
                  break;

                default:
                  btnDisplay = button + 1;
                  btnClass = page === button ? 'active' : '';
                  break;
              }

              if (btnDisplay) {
                node = $('<li>', {
                  'class': classes.sPageButton + ' ' + btnClass,
                  'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
                }).append($('<a>', {
                  'href': '#',
                  'aria-controls': settings.sTableId,
                  'aria-label': aria[button],
                  'data-dt-idx': counter,
                  'tabindex': settings.iTabIndex,
                  'class': 'page-link'
                }).html(btnDisplay)).appendTo(container);

                settings.oApi._fnBindAction(node, {
                  action: button
                }, clickHandler);

                counter++;
              }
            }
          }
        }; // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame. 


        var activeEl;

        try {
          // Because this approach is destroying and recreating the paging
          // elements, focus is lost on the select button which is bad for
          // accessibility. So we want to restore focus once the draw has
          // completed
          activeEl = $(host).find(document.activeElement).data('dt-idx');
        } catch (e) {}

        attach($(host).empty().html('<ul class="pagination"/>').children('ul'), buttons);

        if (activeEl !== undefined) {
          $(host).find('[data-dt-idx=' + activeEl + ']').trigger('focus');
        }
      };

      return DataTable;
    });
    /***/

  },

  /***/
  "./node_modules/datatables.net/js/jquery.dataTables.js":
  /*!*************************************************************!*\
    !*** ./node_modules/datatables.net/js/jquery.dataTables.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesDatatablesNetJsJqueryDataTablesJs(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*! DataTables 1.10.24
    * 2008-2021 SpryMedia Ltd - datatables.net/license
    */

    /**
     * @summary     DataTables
     * @description Paginate, search and order HTML tables
     * @version     1.10.24
     * @file        jquery.dataTables.js
     * @author      SpryMedia Ltd
     * @contact     www.datatables.net
     * @copyright   Copyright 2008-2021 SpryMedia Ltd.
     *
     * This source file is free software, available under the following license:
     *   MIT license - http://datatables.net/license
     *
     * This source file is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
     * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
     *
     * For details please refer to: http://www.datatables.net
     */

    /*jslint evil: true, undef: true, browser: true */

    /*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/


    (function (factory) {
      "use strict";

      if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(
        /*! jquery */
        "jquery")], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
          return factory($, window, document);
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {}
    })(function ($, window, document, undefined) {
      "use strict";
      /**
       * DataTables is a plug-in for the jQuery Javascript library. It is a highly
       * flexible tool, based upon the foundations of progressive enhancement,
       * which will add advanced interaction controls to any HTML table. For a
       * full list of features please refer to
       * [DataTables.net](href="http://datatables.net).
       *
       * Note that the `DataTable` object is not a global variable but is aliased
       * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
       * be  accessed.
       *
       *  @class
       *  @param {object} [init={}] Configuration object for DataTables. Options
       *    are defined by {@link DataTable.defaults}
       *  @requires jQuery 1.7+
       *
       *  @example
       *    // Basic initialisation
       *    $(document).ready( function {
       *      $('#example').dataTable();
       *    } );
       *
       *  @example
       *    // Initialisation with configuration options - in this case, disable
       *    // pagination and sorting.
       *    $(document).ready( function {
       *      $('#example').dataTable( {
       *        "paginate": false,
       *        "sort": false
       *      } );
       *    } );
       */

      var DataTable = function DataTable(options) {
        /**
         * Perform a jQuery selector action on the table's TR elements (from the tbody) and
         * return the resulting jQuery object.
         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
         *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
         *    criterion ("applied") or all TR elements (i.e. no filter).
         *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
         *    Can be either 'current', whereby the current sorting of the table is used, or
         *    'original' whereby the original order the data was read into the table is used.
         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
         *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
         *    'current' and filter is 'applied', regardless of what they might be given as.
         *  @returns {object} jQuery object, filtered by the given selector.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Highlight every second row
         *      oTable.$('tr:odd').css('backgroundColor', 'blue');
         *    } );
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Filter to rows with 'Webkit' in them, add a background colour and then
         *      // remove the filter, thus highlighting the 'Webkit' rows only.
         *      oTable.fnFilter('Webkit');
         *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
         *      oTable.fnFilter('');
         *    } );
         */
        this.$ = function (sSelector, oOpts) {
          return this.api(true).$(sSelector, oOpts);
        };
        /**
         * Almost identical to $ in operation, but in this case returns the data for the matched
         * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
         * rather than any descendants, so the data can be obtained for the row/cell. If matching
         * rows are found, the data returned is the original data array/object that was used to
         * create the row (or a generated array if from a DOM source).
         *
         * This method is often useful in-combination with $ where both functions are given the
         * same parameters and the array indexes will match identically.
         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
         *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
         *    criterion ("applied") or all elements (i.e. no filter).
         *  @param {string} [oOpts.order=current] Order of the data in the processed array.
         *    Can be either 'current', whereby the current sorting of the table is used, or
         *    'original' whereby the original order the data was read into the table is used.
         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
         *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
         *    'current' and filter is 'applied', regardless of what they might be given as.
         *  @returns {array} Data for the matched elements. If any elements, as a result of the
         *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
         *    entry in the array.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Get the data from the first row in the table
         *      var data = oTable._('tr:first');
         *
         *      // Do something useful with the data
         *      alert( "First cell is: "+data[0] );
         *    } );
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Filter to 'Webkit' and get all data for
         *      oTable.fnFilter('Webkit');
         *      var data = oTable._('tr', {"search": "applied"});
         *
         *      // Do something with the data
         *      alert( data.length+" rows matched the search" );
         *    } );
         */


        this._ = function (sSelector, oOpts) {
          return this.api(true).rows(sSelector, oOpts).data();
        };
        /**
         * Create a DataTables Api instance, with the currently selected tables for
         * the Api's context.
         * @param {boolean} [traditional=false] Set the API instance's context to be
         *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
         *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
         *   or if all tables captured in the jQuery object should be used.
         * @return {DataTables.Api}
         */


        this.api = function (traditional) {
          return traditional ? new _Api2(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api2(this);
        };
        /**
         * Add a single new row or multiple rows of data to the table. Please note
         * that this is suitable for client-side processing only - if you are using
         * server-side processing (i.e. "bServerSide": true), then to add data, you
         * must add it to the data source, i.e. the server-side, through an Ajax call.
         *  @param {array|object} data The data to be added to the table. This can be:
         *    <ul>
         *      <li>1D array of data - add a single row with the data provided</li>
         *      <li>2D array of arrays - add multiple rows in a single call</li>
         *      <li>object - data object when using <i>mData</i></li>
         *      <li>array of objects - multiple data objects when using <i>mData</i></li>
         *    </ul>
         *  @param {bool} [redraw=true] redraw the table or not
         *  @returns {array} An array of integers, representing the list of indexes in
         *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
         *    the table.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    // Global var for counter
         *    var giCount = 2;
         *
         *    $(document).ready(function() {
         *      $('#example').dataTable();
         *    } );
         *
         *    function fnClickAddRow() {
         *      $('#example').dataTable().fnAddData( [
         *        giCount+".1",
         *        giCount+".2",
         *        giCount+".3",
         *        giCount+".4" ]
         *      );
         *
         *      giCount++;
         *    }
         */


        this.fnAddData = function (data, redraw) {
          var api = this.api(true);
          /* Check if we want to add multiple rows or not */

          var rows = Array.isArray(data) && (Array.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);

          if (redraw === undefined || redraw) {
            api.draw();
          }

          return rows.flatten().toArray();
        };
        /**
         * This function will make DataTables recalculate the column sizes, based on the data
         * contained in the table and the sizes applied to the columns (in the DOM, CSS or
         * through the sWidth parameter). This can be useful when the width of the table's
         * parent element changes (for example a window resize).
         *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable( {
         *        "sScrollY": "200px",
         *        "bPaginate": false
         *      } );
         *
         *      $(window).on('resize', function () {
         *        oTable.fnAdjustColumnSizing();
         *      } );
         *    } );
         */


        this.fnAdjustColumnSizing = function (bRedraw) {
          var api = this.api(true).columns.adjust();
          var settings = api.settings()[0];
          var scroll = settings.oScroll;

          if (bRedraw === undefined || bRedraw) {
            api.draw(false);
          } else if (scroll.sX !== "" || scroll.sY !== "") {
            /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
            _fnScrollDraw(settings);
          }
        };
        /**
         * Quickly and simply clear a table
         *  @param {bool} [bRedraw=true] redraw the table or not
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
         *      oTable.fnClearTable();
         *    } );
         */


        this.fnClearTable = function (bRedraw) {
          var api = this.api(true).clear();

          if (bRedraw === undefined || bRedraw) {
            api.draw();
          }
        };
        /**
         * The exact opposite of 'opening' a row, this function will close any rows which
         * are currently 'open'.
         *  @param {node} nTr the table row to 'close'
         *  @returns {int} 0 on success, or 1 if failed (can't find the row)
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable;
         *
         *      // 'open' an information row when a row is clicked on
         *      $('#example tbody tr').click( function () {
         *        if ( oTable.fnIsOpen(this) ) {
         *          oTable.fnClose( this );
         *        } else {
         *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
         *        }
         *      } );
         *
         *      oTable = $('#example').dataTable();
         *    } );
         */


        this.fnClose = function (nTr) {
          this.api(true).row(nTr).child.hide();
        };
        /**
         * Remove a row for the table
         *  @param {mixed} target The index of the row from aoData to be deleted, or
         *    the TR element you want to delete
         *  @param {function|null} [callBack] Callback function
         *  @param {bool} [redraw=true] Redraw the table or not
         *  @returns {array} The row that was deleted
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Immediately remove the first row
         *      oTable.fnDeleteRow( 0 );
         *    } );
         */


        this.fnDeleteRow = function (target, callback, redraw) {
          var api = this.api(true);
          var rows = api.rows(target);
          var settings = rows.settings()[0];
          var data = settings.aoData[rows[0][0]];
          rows.remove();

          if (callback) {
            callback.call(this, settings, data);
          }

          if (redraw === undefined || redraw) {
            api.draw();
          }

          return data;
        };
        /**
         * Restore the table to it's original state in the DOM by removing all of DataTables
         * enhancements, alterations to the DOM structure of the table and event listeners.
         *  @param {boolean} [remove=false] Completely remove the table from the DOM
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
         *      var oTable = $('#example').dataTable();
         *      oTable.fnDestroy();
         *    } );
         */


        this.fnDestroy = function (remove) {
          this.api(true).destroy(remove);
        };
        /**
         * Redraw the table
         *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
         *      oTable.fnDraw();
         *    } );
         */


        this.fnDraw = function (complete) {
          // Note that this isn't an exact match to the old call to _fnDraw - it takes
          // into account the new data, but can hold position.
          this.api(true).draw(complete);
        };
        /**
         * Filter the input based on data
         *  @param {string} sInput String to filter the table on
         *  @param {int|null} [iColumn] Column to limit filtering to
         *  @param {bool} [bRegex=false] Treat as regular expression or not
         *  @param {bool} [bSmart=true] Perform smart filtering or not
         *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
         *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Sometime later - filter...
         *      oTable.fnFilter( 'test string' );
         *    } );
         */


        this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
          var api = this.api(true);

          if (iColumn === null || iColumn === undefined) {
            api.search(sInput, bRegex, bSmart, bCaseInsensitive);
          } else {
            api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
          }

          api.draw();
        };
        /**
         * Get the data for the whole table, an individual row or an individual cell based on the
         * provided parameters.
         *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
         *    a TR node then the data source for the whole row will be returned. If given as a
         *    TD/TH cell node then iCol will be automatically calculated and the data for the
         *    cell returned. If given as an integer, then this is treated as the aoData internal
         *    data index for the row (see fnGetPosition) and the data for that row used.
         *  @param {int} [col] Optional column index that you want the data of.
         *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
         *    returned. If mRow is defined, just data for that row, and is iCol is
         *    defined, only data for the designated cell is returned.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    // Row data
         *    $(document).ready(function() {
         *      oTable = $('#example').dataTable();
         *
         *      oTable.$('tr').click( function () {
         *        var data = oTable.fnGetData( this );
         *        // ... do something with the array / object of data for the row
         *      } );
         *    } );
         *
         *  @example
         *    // Individual cell data
         *    $(document).ready(function() {
         *      oTable = $('#example').dataTable();
         *
         *      oTable.$('td').click( function () {
         *        var sData = oTable.fnGetData( this );
         *        alert( 'The cell clicked on had the value of '+sData );
         *      } );
         *    } );
         */


        this.fnGetData = function (src, col) {
          var api = this.api(true);

          if (src !== undefined) {
            var type = src.nodeName ? src.nodeName.toLowerCase() : '';
            return col !== undefined || type == 'td' || type == 'th' ? api.cell(src, col).data() : api.row(src).data() || null;
          }

          return api.data().toArray();
        };
        /**
         * Get an array of the TR nodes that are used in the table's body. Note that you will
         * typically want to use the '$' API method in preference to this as it is more
         * flexible.
         *  @param {int} [iRow] Optional row index for the TR element you want
         *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
         *    in the table's body, or iRow is defined, just the TR element requested.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Get the nodes from the table
         *      var nNodes = oTable.fnGetNodes( );
         *    } );
         */


        this.fnGetNodes = function (iRow) {
          var api = this.api(true);
          return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
        };
        /**
         * Get the array indexes of a particular cell from it's DOM element
         * and column index including hidden columns
         *  @param {node} node this can either be a TR, TD or TH in the table's body
         *  @returns {int} If nNode is given as a TR, then a single index is returned, or
         *    if given as a cell, an array of [row index, column index (visible),
         *    column index (all)] is given.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      $('#example tbody td').click( function () {
         *        // Get the position of the current data from the node
         *        var aPos = oTable.fnGetPosition( this );
         *
         *        // Get the data array for this row
         *        var aData = oTable.fnGetData( aPos[0] );
         *
         *        // Update the data array and return the value
         *        aData[ aPos[1] ] = 'clicked';
         *        this.innerHTML = 'clicked';
         *      } );
         *
         *      // Init DataTables
         *      oTable = $('#example').dataTable();
         *    } );
         */


        this.fnGetPosition = function (node) {
          var api = this.api(true);
          var nodeName = node.nodeName.toUpperCase();

          if (nodeName == 'TR') {
            return api.row(node).index();
          } else if (nodeName == 'TD' || nodeName == 'TH') {
            var cell = api.cell(node).index();
            return [cell.row, cell.columnVisible, cell.column];
          }

          return null;
        };
        /**
         * Check to see if a row is 'open' or not.
         *  @param {node} nTr the table row to check
         *  @returns {boolean} true if the row is currently open, false otherwise
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable;
         *
         *      // 'open' an information row when a row is clicked on
         *      $('#example tbody tr').click( function () {
         *        if ( oTable.fnIsOpen(this) ) {
         *          oTable.fnClose( this );
         *        } else {
         *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
         *        }
         *      } );
         *
         *      oTable = $('#example').dataTable();
         *    } );
         */


        this.fnIsOpen = function (nTr) {
          return this.api(true).row(nTr).child.isShown();
        };
        /**
         * This function will place a new row directly after a row which is currently
         * on display on the page, with the HTML contents that is passed into the
         * function. This can be used, for example, to ask for confirmation that a
         * particular record should be deleted.
         *  @param {node} nTr The table row to 'open'
         *  @param {string|node|jQuery} mHtml The HTML to put into the row
         *  @param {string} sClass Class to give the new TD cell
         *  @returns {node} The row opened. Note that if the table row passed in as the
         *    first parameter, is not found in the table, this method will silently
         *    return.
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable;
         *
         *      // 'open' an information row when a row is clicked on
         *      $('#example tbody tr').click( function () {
         *        if ( oTable.fnIsOpen(this) ) {
         *          oTable.fnClose( this );
         *        } else {
         *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
         *        }
         *      } );
         *
         *      oTable = $('#example').dataTable();
         *    } );
         */


        this.fnOpen = function (nTr, mHtml, sClass) {
          return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
        };
        /**
         * Change the pagination - provides the internal logic for pagination in a simple API
         * function. With this function you can have a DataTables table go to the next,
         * previous, first or last pages.
         *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
         *    or page number to jump to (integer), note that page 0 is the first page.
         *  @param {bool} [bRedraw=true] Redraw the table or not
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      oTable.fnPageChange( 'next' );
         *    } );
         */


        this.fnPageChange = function (mAction, bRedraw) {
          var api = this.api(true).page(mAction);

          if (bRedraw === undefined || bRedraw) {
            api.draw(false);
          }
        };
        /**
         * Show a particular column
         *  @param {int} iCol The column whose display should be changed
         *  @param {bool} bShow Show (true) or hide (false) the column
         *  @param {bool} [bRedraw=true] Redraw the table or not
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Hide the second column after initialisation
         *      oTable.fnSetColumnVis( 1, false );
         *    } );
         */


        this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
          var api = this.api(true).column(iCol).visible(bShow);

          if (bRedraw === undefined || bRedraw) {
            api.columns.adjust().draw();
          }
        };
        /**
         * Get the settings for a particular table for external manipulation
         *  @returns {object} DataTables settings object. See
         *    {@link DataTable.models.oSettings}
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      var oSettings = oTable.fnSettings();
         *
         *      // Show an example parameter from the settings
         *      alert( oSettings._iDisplayStart );
         *    } );
         */


        this.fnSettings = function () {
          return _fnSettingsFromNode(this[_ext.iApiIndex]);
        };
        /**
         * Sort the table by a particular column
         *  @param {int} iCol the data index to sort on. Note that this will not match the
         *    'display index' if you have hidden data entries
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Sort immediately with columns 0 and 1
         *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
         *    } );
         */


        this.fnSort = function (aaSort) {
          this.api(true).order(aaSort).draw();
        };
        /**
         * Attach a sort listener to an element for a given column
         *  @param {node} nNode the element to attach the sort listener to
         *  @param {int} iColumn the column that a click on this node will sort on
         *  @param {function} [fnCallback] callback function when sort is run
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Sort on column 1, when 'sorter' is clicked on
         *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
         *    } );
         */


        this.fnSortListener = function (nNode, iColumn, fnCallback) {
          this.api(true).order.listener(nNode, iColumn, fnCallback);
        };
        /**
         * Update a table cell or row - this method will accept either a single value to
         * update the cell with, an array of values with one element for each column or
         * an object in the same format as the original data source. The function is
         * self-referencing in order to make the multi column updates easier.
         *  @param {object|array|string} mData Data to update the cell/row with
         *  @param {node|int} mRow TR element you want to update or the aoData index
         *  @param {int} [iColumn] The column to update, give as null or undefined to
         *    update a whole row.
         *  @param {bool} [bRedraw=true] Redraw the table or not
         *  @param {bool} [bAction=true] Perform pre-draw actions or not
         *  @returns {int} 0 on success, 1 on error
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
         *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
         *    } );
         */


        this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
          var api = this.api(true);

          if (iColumn === undefined || iColumn === null) {
            api.row(mRow).data(mData);
          } else {
            api.cell(mRow, iColumn).data(mData);
          }

          if (bAction === undefined || bAction) {
            api.columns.adjust();
          }

          if (bRedraw === undefined || bRedraw) {
            api.draw();
          }

          return 0;
        };
        /**
         * Provide a common method for plug-ins to check the version of DataTables being used, in order
         * to ensure compatibility.
         *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
         *    formats "X" and "X.Y" are also acceptable.
         *  @returns {boolean} true if this version of DataTables is greater or equal to the required
         *    version, or false if this version of DataTales is not suitable
         *  @method
         *  @dtopt API
         *  @deprecated Since v1.10
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      alert( oTable.fnVersionCheck( '1.9.0' ) );
         *    } );
         */


        this.fnVersionCheck = _ext.fnVersionCheck;

        var _that = this;

        var emptyInit = options === undefined;
        var len = this.length;

        if (emptyInit) {
          options = {};
        }

        this.oApi = this.internal = _ext.internal; // Extend with old style plug-in API methods

        for (var fn in DataTable.ext.internal) {
          if (fn) {
            this[fn] = _fnExternApiFunc(fn);
          }
        }

        this.each(function () {
          // For each initialisation we want to give it a clean initialisation
          // object that can be bashed around
          var o = {};
          var oInit = len > 1 ? // optimisation for single table case
          _fnExtend(o, options, true) : options;
          /*global oInit,_that,emptyInit*/

          var i = 0,
              iLen,
              j,
              jLen,
              k,
              kLen;
          var sId = this.getAttribute('id');
          var bInitHandedOff = false;
          var defaults = DataTable.defaults;
          var $this = $(this);
          /* Sanity check */

          if (this.nodeName.toLowerCase() != 'table') {
            _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);

            return;
          }
          /* Backwards compatibility for the defaults */


          _fnCompatOpts(defaults);

          _fnCompatCols(defaults.column);
          /* Convert the camel-case defaults to Hungarian */


          _fnCamelToHungarian(defaults, defaults, true);

          _fnCamelToHungarian(defaults.column, defaults.column, true);
          /* Setting up the initialisation object */


          _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()), true);
          /* Check to see if we are re-initialising a table */


          var allSettings = DataTable.settings;

          for (i = 0, iLen = allSettings.length; i < iLen; i++) {
            var s = allSettings[i];
            /* Base check on table node */

            if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
              var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
              var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

              if (emptyInit || bRetrieve) {
                return s.oInstance;
              } else if (bDestroy) {
                s.oInstance.fnDestroy();
                break;
              } else {
                _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);

                return;
              }
            }
            /* If the element we are initialising has the same ID as a table which was previously
             * initialised, but the table nodes don't match (from before) then we destroy the old
             * instance by simply deleting it. This is under the assumption that the table has been
             * destroyed by other methods. Anyone using non-id selectors will need to do this manually
             */


            if (s.sTableId == this.id) {
              allSettings.splice(i, 1);
              break;
            }
          }
          /* Ensure the table has an ID - required for accessibility */


          if (sId === null || sId === "") {
            sId = "DataTables_Table_" + DataTable.ext._unique++;
            this.id = sId;
          }
          /* Create the settings object for this table and set some of the default parameters */


          var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
            "sDestroyWidth": $this[0].style.width,
            "sInstance": sId,
            "sTableId": sId
          });
          oSettings.nTable = this;
          oSettings.oApi = _that.internal;
          oSettings.oInit = oInit;
          allSettings.push(oSettings); // Need to add the instance after the instance after the settings object has been added
          // to the settings array, so we can self reference the table instance if more than one

          oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable(); // Backwards compatibility, before we apply all the defaults

          _fnCompatOpts(oInit);

          _fnLanguageCompat(oInit.oLanguage); // If the length menu is given, but the init display length is not, use the length menu


          if (oInit.aLengthMenu && !oInit.iDisplayLength) {
            oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
          } // Apply the defaults and init options to make a single init object will all
          // options defined from defaults and instance options.


          oInit = _fnExtend($.extend(true, {}, defaults), oInit); // Map the initialisation options onto the settings object

          _fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]);

          _fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"], // backwards compat
          ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"]]);

          _fnMap(oSettings.oScroll, oInit, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);

          _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
          /* Callback functions which are array driven */


          _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');

          _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');

          _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');

          _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');

          _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');

          _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');

          _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');

          _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');

          _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');

          _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');

          _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

          oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
          /* Browser support detection */

          _fnBrowserDetect(oSettings);

          var oClasses = oSettings.oClasses;
          $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
          $this.addClass(oClasses.sTable);

          if (oSettings.iInitDisplayStart === undefined) {
            /* Display start point, taking into account the save saving */
            oSettings.iInitDisplayStart = oInit.iDisplayStart;
            oSettings._iDisplayStart = oInit.iDisplayStart;
          }

          if (oInit.iDeferLoading !== null) {
            oSettings.bDeferLoading = true;
            var tmp = Array.isArray(oInit.iDeferLoading);
            oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
            oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
          }
          /* Language definitions */


          var oLanguage = oSettings.oLanguage;
          $.extend(true, oLanguage, oInit.oLanguage);

          if (oLanguage.sUrl) {
            /* Get the language definitions from a file - because this Ajax call makes the language
             * get async to the remainder of this function we use bInitHandedOff to indicate that
             * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
             */
            $.ajax({
              dataType: 'json',
              url: oLanguage.sUrl,
              success: function success(json) {
                _fnLanguageCompat(json);

                _fnCamelToHungarian(defaults.oLanguage, json);

                $.extend(true, oLanguage, json);

                _fnCallbackFire(oSettings, null, 'i18n', [oSettings]);

                _fnInitialise(oSettings);
              },
              error: function error() {
                // Error occurred loading language file, continue on as best we can
                _fnInitialise(oSettings);
              }
            });
            bInitHandedOff = true;
          } else {
            _fnCallbackFire(oSettings, null, 'i18n', [oSettings]);
          }
          /*
           * Stripes
           */


          if (oInit.asStripeClasses === null) {
            oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven];
          }
          /* Remove row stripe classes if they are already on the table row */


          var stripeClasses = oSettings.asStripeClasses;
          var rowOne = $this.children('tbody').find('tr').eq(0);

          if ($.inArray(true, $.map(stripeClasses, function (el, i) {
            return rowOne.hasClass(el);
          })) !== -1) {
            $('tbody tr', this).removeClass(stripeClasses.join(' '));
            oSettings.asDestroyStripes = stripeClasses.slice();
          }
          /*
           * Columns
           * See if we should load columns automatically or use defined ones
           */


          var anThs = [];
          var aoColumnsInit;
          var nThead = this.getElementsByTagName('thead');

          if (nThead.length !== 0) {
            _fnDetectHeader(oSettings.aoHeader, nThead[0]);

            anThs = _fnGetUniqueThs(oSettings);
          }
          /* If not given a column array, generate one with nulls */


          if (oInit.aoColumns === null) {
            aoColumnsInit = [];

            for (i = 0, iLen = anThs.length; i < iLen; i++) {
              aoColumnsInit.push(null);
            }
          } else {
            aoColumnsInit = oInit.aoColumns;
          }
          /* Add the columns */


          for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
            _fnAddColumn(oSettings, anThs ? anThs[i] : null);
          }
          /* Apply the column definitions */


          _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
            _fnColumnOptions(oSettings, iCol, oDef);
          });
          /* HTML5 attribute detection - build an mData object automatically if the
           * attributes are found
           */


          if (rowOne.length) {
            var a = function a(cell, name) {
              return cell.getAttribute('data-' + name) !== null ? name : null;
            };

            $(rowOne[0]).children('th, td').each(function (i, cell) {
              var col = oSettings.aoColumns[i];

              if (col.mData === i) {
                var sort = a(cell, 'sort') || a(cell, 'order');
                var filter = a(cell, 'filter') || a(cell, 'search');

                if (sort !== null || filter !== null) {
                  col.mData = {
                    _: i + '.display',
                    sort: sort !== null ? i + '.@data-' + sort : undefined,
                    type: sort !== null ? i + '.@data-' + sort : undefined,
                    filter: filter !== null ? i + '.@data-' + filter : undefined
                  };

                  _fnColumnOptions(oSettings, i);
                }
              }
            });
          }

          var features = oSettings.oFeatures;

          var loadedInit = function loadedInit() {
            /*
             * Sorting
             * @todo For modularisation (1.11) this needs to do into a sort start up handler
             */
            // If aaSorting is not defined, then we use the first indicator in asSorting
            // in case that has been altered, so the default sort reflects that option
            if (oInit.aaSorting === undefined) {
              var sorting = oSettings.aaSorting;

              for (i = 0, iLen = sorting.length; i < iLen; i++) {
                sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
              }
            }
            /* Do a first pass on the sorting classes (allows any size changes to be taken into
             * account, and also will apply sorting disabled classes if disabled
             */


            _fnSortingClasses(oSettings);

            if (features.bSort) {
              _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
                if (oSettings.bSorted) {
                  var aSort = _fnSortFlatten(oSettings);

                  var sortedColumns = {};
                  $.each(aSort, function (i, val) {
                    sortedColumns[val.src] = val.dir;
                  });

                  _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);

                  _fnSortAria(oSettings);
                }
              });
            }

            _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
              if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
                _fnSortingClasses(oSettings);
              }
            }, 'sc');
            /*
             * Final init
             * Cache the header, body and footer as required, creating them if needed
             */
            // Work around for Webkit bug 83867 - store the caption-side before removing from doc


            var captions = $this.children('caption').each(function () {
              this._captionSide = $(this).css('caption-side');
            });
            var thead = $this.children('thead');

            if (thead.length === 0) {
              thead = $('<thead/>').appendTo($this);
            }

            oSettings.nTHead = thead[0];
            var tbody = $this.children('tbody');

            if (tbody.length === 0) {
              tbody = $('<tbody/>').appendTo($this);
            }

            oSettings.nTBody = tbody[0];
            var tfoot = $this.children('tfoot');

            if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
              // If we are a scrolling table, and no footer has been given, then we need to create
              // a tfoot element for the caption element to be appended to
              tfoot = $('<tfoot/>').appendTo($this);
            }

            if (tfoot.length === 0 || tfoot.children().length === 0) {
              $this.addClass(oClasses.sNoFooter);
            } else if (tfoot.length > 0) {
              oSettings.nTFoot = tfoot[0];

              _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
            }
            /* Check if there is data passing into the constructor */


            if (oInit.aaData) {
              for (i = 0; i < oInit.aaData.length; i++) {
                _fnAddData(oSettings, oInit.aaData[i]);
              }
            } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
              /* Grab the data from the page - only do this when deferred loading or no Ajax
               * source since there is no point in reading the DOM data if we are then going
               * to replace it with Ajax data
               */
              _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
            }
            /* Copy the data index array */


            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
            /* Initialisation complete - table can be drawn */

            oSettings.bInitialised = true;
            /* Check if we need to initialise the table (it might not have been handed off to the
             * language processor)
             */

            if (bInitHandedOff === false) {
              _fnInitialise(oSettings);
            }
          };
          /* Must be done after everything which can be overridden by the state saving! */


          if (oInit.bStateSave) {
            features.bStateSave = true;

            _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');

            _fnLoadState(oSettings, oInit, loadedInit);
          } else {
            loadedInit();
          }
        });
        _that = null;
        return this;
      };
      /*
       * It is useful to have variables which are scoped locally so only the
       * DataTables functions can access them and they don't leak into global space.
       * At the same time these functions are often useful over multiple files in the
       * core and API, so we list, or at least document, all variables which are used
       * by DataTables as private variables here. This also ensures that there is no
       * clashing of variable names and that they can easily referenced for reuse.
       */
      // Defined else where
      //  _selector_run
      //  _selector_opts
      //  _selector_first
      //  _selector_row_indexes


      var _ext; // DataTable.ext


      var _Api2; // DataTable.Api


      var _api_register; // DataTable.Api.register


      var _api_registerPlural; // DataTable.Api.registerPlural


      var _re_dic = {};
      var _re_new_lines = /[\r\n\u2028]/g;
      var _re_html = /<.*?>/g; // This is not strict ISO8601 - Date.parse() is quite lax, although
      // implementations differ between browsers.

      var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/; // Escape regular expression special characters

      var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g'); // http://en.wikipedia.org/wiki/Foreign_exchange_market
      // - \u20BD - Russian ruble.
      // - \u20a9 - South Korean Won
      // - \u20BA - Turkish Lira
      // - \u20B9 - Indian Rupee
      // - R - Brazil (R$) and South Africa
      // - fr - Swiss Franc
      // - kr - Swedish krona, Norwegian krone and Danish krone
      // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
      // -  - Bitcoin
      // -  - Ethereum
      //   standards as thousands separators.


      var _re_formatted_numeric = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;

      var _empty = function _empty(d) {
        return !d || d === true || d === '-' ? true : false;
      };

      var _intVal = function _intVal(s) {
        var integer = parseInt(s, 10);
        return !isNaN(integer) && isFinite(s) ? integer : null;
      }; // Convert from a formatted number with characters other than `.` as the
      // decimal place, to a Javascript number


      var _numToDecimal = function _numToDecimal(num, decimalPoint) {
        // Cache created regular expressions for speed as this function is called often
        if (!_re_dic[decimalPoint]) {
          _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
        }

        return typeof num === 'string' && decimalPoint !== '.' ? num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') : num;
      };

      var _isNumber = function _isNumber(d, decimalPoint, formatted) {
        var strType = typeof d === 'string'; // If empty return immediately so there must be a number if it is a
        // formatted string (this stops the string "k", or "kr", etc being detected
        // as a formatted number for currency

        if (_empty(d)) {
          return true;
        }

        if (decimalPoint && strType) {
          d = _numToDecimal(d, decimalPoint);
        }

        if (formatted && strType) {
          d = d.replace(_re_formatted_numeric, '');
        }

        return !isNaN(parseFloat(d)) && isFinite(d);
      }; // A string without HTML in it can be considered to be HTML still


      var _isHtml = function _isHtml(d) {
        return _empty(d) || typeof d === 'string';
      };

      var _htmlNumeric = function _htmlNumeric(d, decimalPoint, formatted) {
        if (_empty(d)) {
          return true;
        }

        var html = _isHtml(d);

        return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
      };

      var _pluck = function _pluck(a, prop, prop2) {
        var out = [];
        var i = 0,
            ien = a.length; // Could have the test in the loop for slightly smaller code, but speed
        // is essential here

        if (prop2 !== undefined) {
          for (; i < ien; i++) {
            if (a[i] && a[i][prop]) {
              out.push(a[i][prop][prop2]);
            }
          }
        } else {
          for (; i < ien; i++) {
            if (a[i]) {
              out.push(a[i][prop]);
            }
          }
        }

        return out;
      }; // Basically the same as _pluck, but rather than looping over `a` we use `order`
      // as the indexes to pick from `a`


      var _pluck_order = function _pluck_order(a, order, prop, prop2) {
        var out = [];
        var i = 0,
            ien = order.length; // Could have the test in the loop for slightly smaller code, but speed
        // is essential here

        if (prop2 !== undefined) {
          for (; i < ien; i++) {
            if (a[order[i]][prop]) {
              out.push(a[order[i]][prop][prop2]);
            }
          }
        } else {
          for (; i < ien; i++) {
            out.push(a[order[i]][prop]);
          }
        }

        return out;
      };

      var _range = function _range(len, start) {
        var out = [];
        var end;

        if (start === undefined) {
          start = 0;
          end = len;
        } else {
          end = start;
          start = len;
        }

        for (var i = start; i < end; i++) {
          out.push(i);
        }

        return out;
      };

      var _removeEmpty = function _removeEmpty(a) {
        var out = [];

        for (var i = 0, ien = a.length; i < ien; i++) {
          if (a[i]) {
            // careful - will remove all falsy values!
            out.push(a[i]);
          }
        }

        return out;
      };

      var _stripHtml = function _stripHtml(d) {
        return d.replace(_re_html, '');
      };
      /**
       * Determine if all values in the array are unique. This means we can short
       * cut the _unique method at the cost of a single loop. A sorted array is used
       * to easily check the values.
       *
       * @param  {array} src Source array
       * @return {boolean} true if all unique, false otherwise
       * @ignore
       */


      var _areAllUnique = function _areAllUnique(src) {
        if (src.length < 2) {
          return true;
        }

        var sorted = src.slice().sort();
        var last = sorted[0];

        for (var i = 1, ien = sorted.length; i < ien; i++) {
          if (sorted[i] === last) {
            return false;
          }

          last = sorted[i];
        }

        return true;
      };
      /**
       * Find the unique elements in a source array.
       *
       * @param  {array} src Source array
       * @return {array} Array of unique items
       * @ignore
       */


      var _unique = function _unique(src) {
        if (_areAllUnique(src)) {
          return src.slice();
        } // A faster unique method is to use object keys to identify used values,
        // but this doesn't work with arrays or objects, which we must also
        // consider. See jsperf.com/compare-array-unique-versions/4 for more
        // information.


        var out = [],
            val,
            i,
            ien = src.length,
            j,
            k = 0;

        again: for (i = 0; i < ien; i++) {
          val = src[i];

          for (j = 0; j < k; j++) {
            if (out[j] === val) {
              continue again;
            }
          }

          out.push(val);
          k++;
        }

        return out;
      }; // Surprisingly this is faster than [].concat.apply
      // https://jsperf.com/flatten-an-array-loop-vs-reduce/2


      var _flatten = function _flatten(out, val) {
        if (Array.isArray(val)) {
          for (var i = 0; i < val.length; i++) {
            _flatten(out, val[i]);
          }
        } else {
          out.push(val);
        }

        return out;
      }; // Array.isArray polyfill.
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray


      if (!Array.isArray) {
        Array.isArray = function (arg) {
          return Object.prototype.toString.call(arg) === '[object Array]';
        };
      } // .trim() polyfill
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim


      if (!String.prototype.trim) {
        String.prototype.trim = function () {
          return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        };
      }
      /**
       * DataTables utility methods
       * 
       * This namespace provides helper methods that DataTables uses internally to
       * create a DataTable, but which are not exclusively used only for DataTables.
       * These methods can be used by extension authors to save the duplication of
       * code.
       *
       *  @namespace
       */


      DataTable.util = {
        /**
         * Throttle the calls to a function. Arguments and context are maintained
         * for the throttled function.
         *
         * @param {function} fn Function to be called
         * @param {integer} freq Call frequency in mS
         * @return {function} Wrapped function
         */
        throttle: function throttle(fn, freq) {
          var frequency = freq !== undefined ? freq : 200,
              last,
              timer;
          return function () {
            var that = this,
                now = +new Date(),
                args = arguments;

            if (last && now < last + frequency) {
              clearTimeout(timer);
              timer = setTimeout(function () {
                last = undefined;
                fn.apply(that, args);
              }, frequency);
            } else {
              last = now;
              fn.apply(that, args);
            }
          };
        },

        /**
         * Escape a string such that it can be used in a regular expression
         *
         *  @param {string} val string to escape
         *  @returns {string} escaped string
         */
        escapeRegex: function escapeRegex(val) {
          return val.replace(_re_escape_regex, '\\$1');
        }
      };
      /**
       * Create a mapping object that allows camel case parameters to be looked up
       * for their Hungarian counterparts. The mapping is stored in a private
       * parameter called `_hungarianMap` which can be accessed on the source object.
       *  @param {object} o
       *  @memberof DataTable#oApi
       */

      function _fnHungarianMap(o) {
        var hungarian = 'a aa ai ao as b fn i m o s ',
            match,
            newKey,
            map = {};
        $.each(o, function (key, val) {
          match = key.match(/^([^A-Z]+?)([A-Z])/);

          if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
            newKey = key.replace(match[0], match[2].toLowerCase());
            map[newKey] = key;

            if (match[1] === 'o') {
              _fnHungarianMap(o[key]);
            }
          }
        });
        o._hungarianMap = map;
      }
      /**
       * Convert from camel case parameters to Hungarian, based on a Hungarian map
       * created by _fnHungarianMap.
       *  @param {object} src The model object which holds all parameters that can be
       *    mapped.
       *  @param {object} user The object to convert from camel case to Hungarian.
       *  @param {boolean} force When set to `true`, properties which already have a
       *    Hungarian value in the `user` object will be overwritten. Otherwise they
       *    won't be.
       *  @memberof DataTable#oApi
       */


      function _fnCamelToHungarian(src, user, force) {
        if (!src._hungarianMap) {
          _fnHungarianMap(src);
        }

        var hungarianKey;
        $.each(user, function (key, val) {
          hungarianKey = src._hungarianMap[key];

          if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
            // For objects, we need to buzz down into the object to copy parameters
            if (hungarianKey.charAt(0) === 'o') {
              // Copy the camelCase options over to the hungarian
              if (!user[hungarianKey]) {
                user[hungarianKey] = {};
              }

              $.extend(true, user[hungarianKey], user[key]);

              _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
            } else {
              user[hungarianKey] = user[key];
            }
          }
        });
      }
      /**
       * Language compatibility - when certain options are given, and others aren't, we
       * need to duplicate the values over, in order to provide backwards compatibility
       * with older language files.
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnLanguageCompat(lang) {
        // Note the use of the Hungarian notation for the parameters in this method as
        // this is called after the mapping of camelCase to Hungarian
        var defaults = DataTable.defaults.oLanguage; // Default mapping

        var defaultDecimal = defaults.sDecimal;

        if (defaultDecimal) {
          _addNumericSort(defaultDecimal);
        }

        if (lang) {
          var zeroRecords = lang.sZeroRecords; // Backwards compatibility - if there is no sEmptyTable given, then use the same as
          // sZeroRecords - assuming that is given.

          if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
            _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
          } // Likewise with loading records


          if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
            _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
          } // Old parameter name of the thousands separator mapped onto the new


          if (lang.sInfoThousands) {
            lang.sThousands = lang.sInfoThousands;
          }

          var decimal = lang.sDecimal;

          if (decimal && defaultDecimal !== decimal) {
            _addNumericSort(decimal);
          }
        }
      }
      /**
       * Map one parameter onto another
       *  @param {object} o Object to map
       *  @param {*} knew The new parameter name
       *  @param {*} old The old parameter name
       */


      var _fnCompatMap = function _fnCompatMap(o, knew, old) {
        if (o[knew] !== undefined) {
          o[old] = o[knew];
        }
      };
      /**
       * Provide backwards compatibility for the main DT options. Note that the new
       * options are mapped onto the old parameters, so this is an external interface
       * change only.
       *  @param {object} init Object to map
       */


      function _fnCompatOpts(init) {
        _fnCompatMap(init, 'ordering', 'bSort');

        _fnCompatMap(init, 'orderMulti', 'bSortMulti');

        _fnCompatMap(init, 'orderClasses', 'bSortClasses');

        _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');

        _fnCompatMap(init, 'order', 'aaSorting');

        _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');

        _fnCompatMap(init, 'paging', 'bPaginate');

        _fnCompatMap(init, 'pagingType', 'sPaginationType');

        _fnCompatMap(init, 'pageLength', 'iDisplayLength');

        _fnCompatMap(init, 'searching', 'bFilter'); // Boolean initialisation of x-scrolling


        if (typeof init.sScrollX === 'boolean') {
          init.sScrollX = init.sScrollX ? '100%' : '';
        }

        if (typeof init.scrollX === 'boolean') {
          init.scrollX = init.scrollX ? '100%' : '';
        } // Column search objects are in an array, so it needs to be converted
        // element by element


        var searchCols = init.aoSearchCols;

        if (searchCols) {
          for (var i = 0, ien = searchCols.length; i < ien; i++) {
            if (searchCols[i]) {
              _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
            }
          }
        }
      }
      /**
       * Provide backwards compatibility for column options. Note that the new options
       * are mapped onto the old parameters, so this is an external interface change
       * only.
       *  @param {object} init Object to map
       */


      function _fnCompatCols(init) {
        _fnCompatMap(init, 'orderable', 'bSortable');

        _fnCompatMap(init, 'orderData', 'aDataSort');

        _fnCompatMap(init, 'orderSequence', 'asSorting');

        _fnCompatMap(init, 'orderDataType', 'sortDataType'); // orderData can be given as an integer


        var dataSort = init.aDataSort;

        if (typeof dataSort === 'number' && !Array.isArray(dataSort)) {
          init.aDataSort = [dataSort];
        }
      }
      /**
       * Browser feature detection for capabilities, quirks
       *  @param {object} settings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnBrowserDetect(settings) {
        // We don't need to do this every time DataTables is constructed, the values
        // calculated are specific to the browser and OS configuration which we
        // don't expect to change between initialisations
        if (!DataTable.__browser) {
          var browser = {};
          DataTable.__browser = browser; // Scrolling feature / quirks detection

          var n = $('<div/>').css({
            position: 'fixed',
            top: 0,
            left: $(window).scrollLeft() * -1,
            // allow for scrolling
            height: 1,
            width: 1,
            overflow: 'hidden'
          }).append($('<div/>').css({
            position: 'absolute',
            top: 1,
            left: 1,
            width: 100,
            overflow: 'scroll'
          }).append($('<div/>').css({
            width: '100%',
            height: 10
          }))).appendTo('body');
          var outer = n.children();
          var inner = outer.children(); // Numbers below, in order, are:
          // inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
          //
          // IE6 XP:                           100 100 100  83
          // IE7 Vista:                        100 100 100  83
          // IE 8+ Windows:                     83  83 100  83
          // Evergreen Windows:                 83  83 100  83
          // Evergreen Mac with scrollbars:     85  85 100  85
          // Evergreen Mac without scrollbars: 100 100 100 100
          // Get scrollbar width

          browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth; // IE6/7 will oversize a width 100% element inside a scrolling element, to
          // include the width of the scrollbar, while other browsers ensure the inner
          // element is contained without forcing scrolling

          browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100; // In rtl text layout, some browsers (most, but not all) will place the
          // scrollbar on the left, rather than the right.

          browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1; // IE8- don't provide height and width for getBoundingClientRect

          browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
          n.remove();
        }

        $.extend(settings.oBrowser, DataTable.__browser);
        settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
      }
      /**
       * Array.prototype reduce[Right] method, used for browsers which don't support
       * JS 1.6. Done this way to reduce code size, since we iterate either way
       *  @param {object} settings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnReduce(that, fn, init, start, end, inc) {
        var i = start,
            value,
            isSet = false;

        if (init !== undefined) {
          value = init;
          isSet = true;
        }

        while (i !== end) {
          if (!that.hasOwnProperty(i)) {
            continue;
          }

          value = isSet ? fn(value, that[i], i, that) : that[i];
          isSet = true;
          i += inc;
        }

        return value;
      }
      /**
       * Add a column to the list used for the table with default values
       *  @param {object} oSettings dataTables settings object
       *  @param {node} nTh The th element for this column
       *  @memberof DataTable#oApi
       */


      function _fnAddColumn(oSettings, nTh) {
        // Add column to aoColumns array
        var oDefaults = DataTable.defaults.column;
        var iCol = oSettings.aoColumns.length;
        var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
          "nTh": nTh ? nTh : document.createElement('th'),
          "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
          "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
          "mData": oDefaults.mData ? oDefaults.mData : iCol,
          idx: iCol
        });
        oSettings.aoColumns.push(oCol); // Add search object for column specific search. Note that the `searchCols[ iCol ]`
        // passed into extend can be undefined. This allows the user to give a default
        // with only some of the parameters defined, and also not give a default

        var searchCols = oSettings.aoPreSearchCols;
        searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]); // Use the default column options function to initialise classes etc

        _fnColumnOptions(oSettings, iCol, $(nTh).data());
      }
      /**
       * Apply options for a column
       *  @param {object} oSettings dataTables settings object
       *  @param {int} iCol column index to consider
       *  @param {object} oOptions object with sType, bVisible and bSearchable etc
       *  @memberof DataTable#oApi
       */


      function _fnColumnOptions(oSettings, iCol, oOptions) {
        var oCol = oSettings.aoColumns[iCol];
        var oClasses = oSettings.oClasses;
        var th = $(oCol.nTh); // Try to get width information from the DOM. We can't get it from CSS
        // as we'd need to parse the CSS stylesheet. `width` option can override

        if (!oCol.sWidthOrig) {
          // Width attribute
          oCol.sWidthOrig = th.attr('width') || null; // Style attribute

          var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);

          if (t) {
            oCol.sWidthOrig = t[1];
          }
        }
        /* User specified column options */


        if (oOptions !== undefined && oOptions !== null) {
          // Backwards compatibility
          _fnCompatCols(oOptions); // Map camel case parameters to their Hungarian counterparts


          _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);
          /* Backwards compatibility for mDataProp */


          if (oOptions.mDataProp !== undefined && !oOptions.mData) {
            oOptions.mData = oOptions.mDataProp;
          }

          if (oOptions.sType) {
            oCol._sManualType = oOptions.sType;
          } // `class` is a reserved word in Javascript, so we need to provide
          // the ability to use a valid name for the camel case input


          if (oOptions.className && !oOptions.sClass) {
            oOptions.sClass = oOptions.className;
          }

          if (oOptions.sClass) {
            th.addClass(oOptions.sClass);
          }

          $.extend(oCol, oOptions);

          _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
          /* iDataSort to be applied (backwards compatibility), but aDataSort will take
           * priority if defined
           */


          if (oOptions.iDataSort !== undefined) {
            oCol.aDataSort = [oOptions.iDataSort];
          }

          _fnMap(oCol, oOptions, "aDataSort");
        }
        /* Cache the data get and set functions for speed */


        var mDataSrc = oCol.mData;

        var mData = _fnGetObjectDataFn(mDataSrc);

        var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

        var attrTest = function attrTest(src) {
          return typeof src === 'string' && src.indexOf('@') !== -1;
        };

        oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
        oCol._setter = null;

        oCol.fnGetData = function (rowData, type, meta) {
          var innerData = mData(rowData, type, undefined, meta);
          return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
        };

        oCol.fnSetData = function (rowData, val, meta) {
          return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
        }; // Indicate if DataTables should read DOM data as an object or array
        // Used in _fnGetRowElements


        if (typeof mDataSrc !== 'number') {
          oSettings._rowReadObject = true;
        }
        /* Feature sorting overrides column specific when off */


        if (!oSettings.oFeatures.bSort) {
          oCol.bSortable = false;
          th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
        }
        /* Check that the class assignment is correct for sorting */


        var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
        var bDesc = $.inArray('desc', oCol.asSorting) !== -1;

        if (!oCol.bSortable || !bAsc && !bDesc) {
          oCol.sSortingClass = oClasses.sSortableNone;
          oCol.sSortingClassJUI = "";
        } else if (bAsc && !bDesc) {
          oCol.sSortingClass = oClasses.sSortableAsc;
          oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
        } else if (!bAsc && bDesc) {
          oCol.sSortingClass = oClasses.sSortableDesc;
          oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
        } else {
          oCol.sSortingClass = oClasses.sSortable;
          oCol.sSortingClassJUI = oClasses.sSortJUI;
        }
      }
      /**
       * Adjust the table column widths for new data. Note: you would probably want to
       * do a redraw after calling this function!
       *  @param {object} settings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnAdjustColumnSizing(settings) {
        /* Not interested in doing column width calculation if auto-width is disabled */
        if (settings.oFeatures.bAutoWidth !== false) {
          var columns = settings.aoColumns;

          _fnCalculateColumnWidths(settings);

          for (var i = 0, iLen = columns.length; i < iLen; i++) {
            columns[i].nTh.style.width = columns[i].sWidth;
          }
        }

        var scroll = settings.oScroll;

        if (scroll.sY !== '' || scroll.sX !== '') {
          _fnScrollDraw(settings);
        }

        _fnCallbackFire(settings, null, 'column-sizing', [settings]);
      }
      /**
       * Covert the index of a visible column to the index in the data array (take account
       * of hidden columns)
       *  @param {object} oSettings dataTables settings object
       *  @param {int} iMatch Visible column index to lookup
       *  @returns {int} i the data index
       *  @memberof DataTable#oApi
       */


      function _fnVisibleToColumnIndex(oSettings, iMatch) {
        var aiVis = _fnGetColumns(oSettings, 'bVisible');

        return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null;
      }
      /**
       * Covert the index of an index in the data array and convert it to the visible
       *   column index (take account of hidden columns)
       *  @param {int} iMatch Column index to lookup
       *  @param {object} oSettings dataTables settings object
       *  @returns {int} i the data index
       *  @memberof DataTable#oApi
       */


      function _fnColumnIndexToVisible(oSettings, iMatch) {
        var aiVis = _fnGetColumns(oSettings, 'bVisible');

        var iPos = $.inArray(iMatch, aiVis);
        return iPos !== -1 ? iPos : null;
      }
      /**
       * Get the number of visible columns
       *  @param {object} oSettings dataTables settings object
       *  @returns {int} i the number of visible columns
       *  @memberof DataTable#oApi
       */


      function _fnVisbleColumns(oSettings) {
        var vis = 0; // No reduce in IE8, use a loop for now

        $.each(oSettings.aoColumns, function (i, col) {
          if (col.bVisible && $(col.nTh).css('display') !== 'none') {
            vis++;
          }
        });
        return vis;
      }
      /**
       * Get an array of column indexes that match a given property
       *  @param {object} oSettings dataTables settings object
       *  @param {string} sParam Parameter in aoColumns to look for - typically
       *    bVisible or bSearchable
       *  @returns {array} Array of indexes with matched properties
       *  @memberof DataTable#oApi
       */


      function _fnGetColumns(oSettings, sParam) {
        var a = [];
        $.map(oSettings.aoColumns, function (val, i) {
          if (val[sParam]) {
            a.push(i);
          }
        });
        return a;
      }
      /**
       * Calculate the 'type' of a column
       *  @param {object} settings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnColumnTypes(settings) {
        var columns = settings.aoColumns;
        var data = settings.aoData;
        var types = DataTable.ext.type.detect;
        var i, ien, j, jen, k, ken;
        var col, cell, detectedType, cache; // For each column, spin over the 

        for (i = 0, ien = columns.length; i < ien; i++) {
          col = columns[i];
          cache = [];

          if (!col.sType && col._sManualType) {
            col.sType = col._sManualType;
          } else if (!col.sType) {
            for (j = 0, jen = types.length; j < jen; j++) {
              for (k = 0, ken = data.length; k < ken; k++) {
                // Use a cache array so we only need to get the type data
                // from the formatter once (when using multiple detectors)
                if (cache[k] === undefined) {
                  cache[k] = _fnGetCellData(settings, k, i, 'type');
                }

                detectedType = types[j](cache[k], settings); // If null, then this type can't apply to this column, so
                // rather than testing all cells, break out. There is an
                // exception for the last type which is `html`. We need to
                // scan all rows since it is possible to mix string and HTML
                // types

                if (!detectedType && j !== types.length - 1) {
                  break;
                } // Only a single match is needed for html type since it is
                // bottom of the pile and very similar to string


                if (detectedType === 'html') {
                  break;
                }
              } // Type is valid for all data points in the column - use this
              // type


              if (detectedType) {
                col.sType = detectedType;
                break;
              }
            } // Fall back - if no type was detected, always use string


            if (!col.sType) {
              col.sType = 'string';
            }
          }
        }
      }
      /**
       * Take the column definitions and static columns arrays and calculate how
       * they relate to column indexes. The callback function will then apply the
       * definition found for a column to a suitable configuration object.
       *  @param {object} oSettings dataTables settings object
       *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
       *  @param {array} aoCols The aoColumns array that defines columns individually
       *  @param {function} fn Callback function - takes two parameters, the calculated
       *    column index and the definition for that column.
       *  @memberof DataTable#oApi
       */


      function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
        var i, iLen, j, jLen, k, kLen, def;
        var columns = oSettings.aoColumns; // Column definitions with aTargets

        if (aoColDefs) {
          /* Loop over the definitions array - loop in reverse so first instance has priority */
          for (i = aoColDefs.length - 1; i >= 0; i--) {
            def = aoColDefs[i];
            /* Each definition can target multiple columns, as it is an array */

            var aTargets = def.targets !== undefined ? def.targets : def.aTargets;

            if (!Array.isArray(aTargets)) {
              aTargets = [aTargets];
            }

            for (j = 0, jLen = aTargets.length; j < jLen; j++) {
              if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
                /* Add columns that we don't yet know about */
                while (columns.length <= aTargets[j]) {
                  _fnAddColumn(oSettings);
                }
                /* Integer, basic index */


                fn(aTargets[j], def);
              } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
                /* Negative integer, right to left column counting */
                fn(columns.length + aTargets[j], def);
              } else if (typeof aTargets[j] === 'string') {
                /* Class name matching on TH element */
                for (k = 0, kLen = columns.length; k < kLen; k++) {
                  if (aTargets[j] == "_all" || $(columns[k].nTh).hasClass(aTargets[j])) {
                    fn(k, def);
                  }
                }
              }
            }
          }
        } // Statically defined columns array


        if (aoCols) {
          for (i = 0, iLen = aoCols.length; i < iLen; i++) {
            fn(i, aoCols[i]);
          }
        }
      }
      /**
       * Add a data array to the table, creating DOM node etc. This is the parallel to
       * _fnGatherData, but for adding rows from a Javascript source, rather than a
       * DOM source.
       *  @param {object} oSettings dataTables settings object
       *  @param {array} aData data array to be added
       *  @param {node} [nTr] TR element to add to the table - optional. If not given,
       *    DataTables will create a row automatically
       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
       *    if nTr is.
       *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
       *  @memberof DataTable#oApi
       */


      function _fnAddData(oSettings, aDataIn, nTr, anTds) {
        /* Create the object for storing information about this new row */
        var iRow = oSettings.aoData.length;
        var oData = $.extend(true, {}, DataTable.models.oRow, {
          src: nTr ? 'dom' : 'data',
          idx: iRow
        });
        oData._aData = aDataIn;
        oSettings.aoData.push(oData);
        /* Create the cells */

        var nTd, sThisType;
        var columns = oSettings.aoColumns; // Invalidate the column types as the new data needs to be revalidated

        for (var i = 0, iLen = columns.length; i < iLen; i++) {
          columns[i].sType = null;
        }
        /* Add to the display array */


        oSettings.aiDisplayMaster.push(iRow);
        var id = oSettings.rowIdFn(aDataIn);

        if (id !== undefined) {
          oSettings.aIds[id] = oData;
        }
        /* Create the DOM information, or register it if already present */


        if (nTr || !oSettings.oFeatures.bDeferRender) {
          _fnCreateTr(oSettings, iRow, nTr, anTds);
        }

        return iRow;
      }
      /**
       * Add one or more TR elements to the table. Generally we'd expect to
       * use this for reading data from a DOM sourced table, but it could be
       * used for an TR element. Note that if a TR is given, it is used (i.e.
       * it is not cloned).
       *  @param {object} settings dataTables settings object
       *  @param {array|node|jQuery} trs The TR element(s) to add to the table
       *  @returns {array} Array of indexes for the added rows
       *  @memberof DataTable#oApi
       */


      function _fnAddTr(settings, trs) {
        var row; // Allow an individual node to be passed in

        if (!(trs instanceof $)) {
          trs = $(trs);
        }

        return trs.map(function (i, el) {
          row = _fnGetRowElements(settings, el);
          return _fnAddData(settings, row.data, el, row.cells);
        });
      }
      /**
       * Take a TR element and convert it to an index in aoData
       *  @param {object} oSettings dataTables settings object
       *  @param {node} n the TR element to find
       *  @returns {int} index if the node is found, null if not
       *  @memberof DataTable#oApi
       */


      function _fnNodeToDataIndex(oSettings, n) {
        return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
      }
      /**
       * Take a TD element and convert it into a column data index (not the visible index)
       *  @param {object} oSettings dataTables settings object
       *  @param {int} iRow The row number the TD/TH can be found in
       *  @param {node} n The TD/TH element to find
       *  @returns {int} index if the node is found, -1 if not
       *  @memberof DataTable#oApi
       */


      function _fnNodeToColumnIndex(oSettings, iRow, n) {
        return $.inArray(n, oSettings.aoData[iRow].anCells);
      }
      /**
       * Get the data for a given cell from the internal cache, taking into account data mapping
       *  @param {object} settings dataTables settings object
       *  @param {int} rowIdx aoData row id
       *  @param {int} colIdx Column index
       *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
       *  @returns {*} Cell data
       *  @memberof DataTable#oApi
       */


      function _fnGetCellData(settings, rowIdx, colIdx, type) {
        var draw = settings.iDraw;
        var col = settings.aoColumns[colIdx];
        var rowData = settings.aoData[rowIdx]._aData;
        var defaultContent = col.sDefaultContent;
        var cellData = col.fnGetData(rowData, type, {
          settings: settings,
          row: rowIdx,
          col: colIdx
        });

        if (cellData === undefined) {
          if (settings.iDrawError != draw && defaultContent === null) {
            _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);

            settings.iDrawError = draw;
          }

          return defaultContent;
        } // When the data source is null and a specific data type is requested (i.e.
        // not the original data), we can use default column data


        if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
          cellData = defaultContent;
        } else if (typeof cellData === 'function') {
          // If the data source is a function, then we run it and use the return,
          // executing in the scope of the data object (for instances)
          return cellData.call(rowData);
        }

        if (cellData === null && type == 'display') {
          return '';
        }

        return cellData;
      }
      /**
       * Set the value for a specific cell, into the internal data cache
       *  @param {object} settings dataTables settings object
       *  @param {int} rowIdx aoData row id
       *  @param {int} colIdx Column index
       *  @param {*} val Value to set
       *  @memberof DataTable#oApi
       */


      function _fnSetCellData(settings, rowIdx, colIdx, val) {
        var col = settings.aoColumns[colIdx];
        var rowData = settings.aoData[rowIdx]._aData;
        col.fnSetData(rowData, val, {
          settings: settings,
          row: rowIdx,
          col: colIdx
        });
      } // Private variable that is used to match action syntax in the data property object


      var __reArray = /\[.*?\]$/;
      var __reFn = /\(\)$/;
      /**
       * Split string on periods, taking into account escaped periods
       * @param  {string} str String to split
       * @return {array} Split string
       */

      function _fnSplitObjNotation(str) {
        return $.map(str.match(/(\\.|[^\.])+/g) || [''], function (s) {
          return s.replace(/\\\./g, '.');
        });
      }
      /**
       * Return a function that can be used to get data from a source object, taking
       * into account the ability to use nested objects as a source
       *  @param {string|int|function} mSource The data source for the object
       *  @returns {function} Data get function
       *  @memberof DataTable#oApi
       */


      function _fnGetObjectDataFn(mSource) {
        if ($.isPlainObject(mSource)) {
          /* Build an object of get functions, and wrap them in a single call */
          var o = {};
          $.each(mSource, function (key, val) {
            if (val) {
              o[key] = _fnGetObjectDataFn(val);
            }
          });
          return function (data, type, row, meta) {
            var t = o[type] || o._;
            return t !== undefined ? t(data, type, row, meta) : data;
          };
        } else if (mSource === null) {
          /* Give an empty string for rendering / sorting etc */
          return function (data) {
            // type, row and meta also passed, but not used
            return data;
          };
        } else if (typeof mSource === 'function') {
          return function (data, type, row, meta) {
            return mSource(data, type, row, meta);
          };
        } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
          /* If there is a . in the source string then the data source is in a
           * nested object so we loop over the data for each level to get the next
           * level down. On each loop we test for undefined, and if found immediately
           * return. This allows entire objects to be missing and sDefaultContent to
           * be used if defined, rather than throwing an error
           */
          var fetchData = function fetchData(data, type, src) {
            var arrayNotation, funcNotation, out, innerSrc;

            if (src !== "") {
              var a = _fnSplitObjNotation(src);

              for (var i = 0, iLen = a.length; i < iLen; i++) {
                // Check if we are dealing with special notation
                arrayNotation = a[i].match(__reArray);
                funcNotation = a[i].match(__reFn);

                if (arrayNotation) {
                  // Array notation
                  a[i] = a[i].replace(__reArray, ''); // Condition allows simply [] to be passed in

                  if (a[i] !== "") {
                    data = data[a[i]];
                  }

                  out = []; // Get the remainder of the nested object to get

                  a.splice(0, i + 1);
                  innerSrc = a.join('.'); // Traverse each entry in the array getting the properties requested

                  if (Array.isArray(data)) {
                    for (var j = 0, jLen = data.length; j < jLen; j++) {
                      out.push(fetchData(data[j], type, innerSrc));
                    }
                  } // If a string is given in between the array notation indicators, that
                  // is used to join the strings together, otherwise an array is returned


                  var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                  data = join === "" ? out : out.join(join); // The inner call to fetchData has already traversed through the remainder
                  // of the source requested, so we exit from the loop

                  break;
                } else if (funcNotation) {
                  // Function call
                  a[i] = a[i].replace(__reFn, '');
                  data = data[a[i]]();
                  continue;
                }

                if (data === null || data[a[i]] === undefined) {
                  return undefined;
                }

                data = data[a[i]];
              }
            }

            return data;
          };

          return function (data, type) {
            // row and meta also passed, but not used
            return fetchData(data, type, mSource);
          };
        } else {
          /* Array or flat object mapping */
          return function (data, type) {
            // row and meta also passed, but not used
            return data[mSource];
          };
        }
      }
      /**
       * Return a function that can be used to set data from a source object, taking
       * into account the ability to use nested objects as a source
       *  @param {string|int|function} mSource The data source for the object
       *  @returns {function} Data set function
       *  @memberof DataTable#oApi
       */


      function _fnSetObjectDataFn(mSource) {
        if ($.isPlainObject(mSource)) {
          /* Unlike get, only the underscore (global) option is used for for
           * setting data since we don't know the type here. This is why an object
           * option is not documented for `mData` (which is read/write), but it is
           * for `mRender` which is read only.
           */
          return _fnSetObjectDataFn(mSource._);
        } else if (mSource === null) {
          /* Nothing to do when the data source is null */
          return function () {};
        } else if (typeof mSource === 'function') {
          return function (data, val, meta) {
            mSource(data, 'set', val, meta);
          };
        } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
          /* Like the get, we need to get data from a nested object */
          var setData = function setData(data, val, src) {
            var a = _fnSplitObjNotation(src),
                b;

            var aLast = a[a.length - 1];
            var arrayNotation, funcNotation, o, innerSrc;

            for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
              // Protect against prototype pollution
              if (a[i] === '__proto__' || a[i] === 'constructor') {
                throw new Error('Cannot set prototype values');
              } // Check if we are dealing with an array notation request


              arrayNotation = a[i].match(__reArray);
              funcNotation = a[i].match(__reFn);

              if (arrayNotation) {
                a[i] = a[i].replace(__reArray, '');
                data[a[i]] = []; // Get the remainder of the nested object to set so we can recurse

                b = a.slice();
                b.splice(0, i + 1);
                innerSrc = b.join('.'); // Traverse each entry in the array setting the properties requested

                if (Array.isArray(val)) {
                  for (var j = 0, jLen = val.length; j < jLen; j++) {
                    o = {};
                    setData(o, val[j], innerSrc);
                    data[a[i]].push(o);
                  }
                } else {
                  // We've been asked to save data to an array, but it
                  // isn't array data to be saved. Best that can be done
                  // is to just save the value.
                  data[a[i]] = val;
                } // The inner call to setData has already traversed through the remainder
                // of the source and has set the data, thus we can exit here


                return;
              } else if (funcNotation) {
                // Function call
                a[i] = a[i].replace(__reFn, '');
                data = data[a[i]](val);
              } // If the nested object doesn't currently exist - since we are
              // trying to set the value - create it


              if (data[a[i]] === null || data[a[i]] === undefined) {
                data[a[i]] = {};
              }

              data = data[a[i]];
            } // Last item in the input - i.e, the actual set


            if (aLast.match(__reFn)) {
              // Function call
              data = data[aLast.replace(__reFn, '')](val);
            } else {
              // If array notation is used, we just want to strip it and use the property name
              // and assign the value. If it isn't used, then we get the result we want anyway
              data[aLast.replace(__reArray, '')] = val;
            }
          };

          return function (data, val) {
            // meta is also passed in, but not used
            return setData(data, val, mSource);
          };
        } else {
          /* Array or flat object mapping */
          return function (data, val) {
            // meta is also passed in, but not used
            data[mSource] = val;
          };
        }
      }
      /**
       * Return an array with the full table data
       *  @param {object} oSettings dataTables settings object
       *  @returns array {array} aData Master data array
       *  @memberof DataTable#oApi
       */


      function _fnGetDataMaster(settings) {
        return _pluck(settings.aoData, '_aData');
      }
      /**
       * Nuke the table
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnClearTable(settings) {
        settings.aoData.length = 0;
        settings.aiDisplayMaster.length = 0;
        settings.aiDisplay.length = 0;
        settings.aIds = {};
      }
      /**
      * Take an array of integers (index array) and remove a target integer (value - not
      * the key!)
      *  @param {array} a Index array to target
      *  @param {int} iTarget value to find
      *  @memberof DataTable#oApi
      */


      function _fnDeleteIndex(a, iTarget, splice) {
        var iTargetIndex = -1;

        for (var i = 0, iLen = a.length; i < iLen; i++) {
          if (a[i] == iTarget) {
            iTargetIndex = i;
          } else if (a[i] > iTarget) {
            a[i]--;
          }
        }

        if (iTargetIndex != -1 && splice === undefined) {
          a.splice(iTargetIndex, 1);
        }
      }
      /**
       * Mark cached data as invalid such that a re-read of the data will occur when
       * the cached data is next requested. Also update from the data source object.
       *
       * @param {object} settings DataTables settings object
       * @param {int}    rowIdx   Row index to invalidate
       * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
       *     or 'data'
       * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
       *     row will be invalidated
       * @memberof DataTable#oApi
       *
       * @todo For the modularisation of v1.11 this will need to become a callback, so
       *   the sort and filter methods can subscribe to it. That will required
       *   initialisation options for sorting, which is why it is not already baked in
       */


      function _fnInvalidate(settings, rowIdx, src, colIdx) {
        var row = settings.aoData[rowIdx];
        var i, ien;

        var cellWrite = function cellWrite(cell, col) {
          // This is very frustrating, but in IE if you just write directly
          // to innerHTML, and elements that are overwritten are GC'ed,
          // even if there is a reference to them elsewhere
          while (cell.childNodes.length) {
            cell.removeChild(cell.firstChild);
          }

          cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
        }; // Are we reading last data from DOM or the data object?


        if (src === 'dom' || (!src || src === 'auto') && row.src === 'dom') {
          // Read the data from the DOM
          row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
        } else {
          // Reading from data object, update the DOM
          var cells = row.anCells;

          if (cells) {
            if (colIdx !== undefined) {
              cellWrite(cells[colIdx], colIdx);
            } else {
              for (i = 0, ien = cells.length; i < ien; i++) {
                cellWrite(cells[i], i);
              }
            }
          }
        } // For both row and cell invalidation, the cached data for sorting and
        // filtering is nulled out


        row._aSortData = null;
        row._aFilterData = null; // Invalidate the type for a specific column (if given) or all columns since
        // the data might have changed

        var cols = settings.aoColumns;

        if (colIdx !== undefined) {
          cols[colIdx].sType = null;
        } else {
          for (i = 0, ien = cols.length; i < ien; i++) {
            cols[i].sType = null;
          } // Update DataTables special `DT_*` attributes for the row


          _fnRowAttributes(settings, row);
        }
      }
      /**
       * Build a data source object from an HTML row, reading the contents of the
       * cells that are in the row.
       *
       * @param {object} settings DataTables settings object
       * @param {node|object} TR element from which to read data or existing row
       *   object from which to re-read the data from the cells
       * @param {int} [colIdx] Optional column index
       * @param {array|object} [d] Data source object. If `colIdx` is given then this
       *   parameter should also be given and will be used to write the data into.
       *   Only the column in question will be written
       * @returns {object} Object with two parameters: `data` the data read, in
       *   document order, and `cells` and array of nodes (they can be useful to the
       *   caller, so rather than needing a second traversal to get them, just return
       *   them from here).
       * @memberof DataTable#oApi
       */


      function _fnGetRowElements(settings, row, colIdx, d) {
        var tds = [],
            td = row.firstChild,
            name,
            col,
            o,
            i = 0,
            contents,
            columns = settings.aoColumns,
            objectRead = settings._rowReadObject; // Allow the data object to be passed in, or construct

        d = d !== undefined ? d : objectRead ? {} : [];

        var attr = function attr(str, td) {
          if (typeof str === 'string') {
            var idx = str.indexOf('@');

            if (idx !== -1) {
              var attr = str.substring(idx + 1);

              var setter = _fnSetObjectDataFn(str);

              setter(d, td.getAttribute(attr));
            }
          }
        }; // Read data from a cell and store into the data object


        var cellProcess = function cellProcess(cell) {
          if (colIdx === undefined || colIdx === i) {
            col = columns[i];
            contents = cell.innerHTML.trim();

            if (col && col._bAttrSrc) {
              var setter = _fnSetObjectDataFn(col.mData._);

              setter(d, contents);
              attr(col.mData.sort, cell);
              attr(col.mData.type, cell);
              attr(col.mData.filter, cell);
            } else {
              // Depending on the `data` option for the columns the data can
              // be read to either an object or an array.
              if (objectRead) {
                if (!col._setter) {
                  // Cache the setter function
                  col._setter = _fnSetObjectDataFn(col.mData);
                }

                col._setter(d, contents);
              } else {
                d[i] = contents;
              }
            }
          }

          i++;
        };

        if (td) {
          // `tr` element was passed in
          while (td) {
            name = td.nodeName.toUpperCase();

            if (name == "TD" || name == "TH") {
              cellProcess(td);
              tds.push(td);
            }

            td = td.nextSibling;
          }
        } else {
          // Existing row object passed in
          tds = row.anCells;

          for (var j = 0, jen = tds.length; j < jen; j++) {
            cellProcess(tds[j]);
          }
        } // Read the ID from the DOM if present


        var rowNode = row.firstChild ? row : row.nTr;

        if (rowNode) {
          var id = rowNode.getAttribute('id');

          if (id) {
            _fnSetObjectDataFn(settings.rowId)(d, id);
          }
        }

        return {
          data: d,
          cells: tds
        };
      }
      /**
       * Create a new TR element (and it's TD children) for a row
       *  @param {object} oSettings dataTables settings object
       *  @param {int} iRow Row to consider
       *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
       *    DataTables will create a row automatically
       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
       *    if nTr is.
       *  @memberof DataTable#oApi
       */


      function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
        var row = oSettings.aoData[iRow],
            rowData = row._aData,
            cells = [],
            nTr,
            nTd,
            oCol,
            i,
            iLen,
            create;

        if (row.nTr === null) {
          nTr = nTrIn || document.createElement('tr');
          row.nTr = nTr;
          row.anCells = cells;
          /* Use a private property on the node to allow reserve mapping from the node
           * to the aoData array for fast look up
           */

          nTr._DT_RowIndex = iRow;
          /* Special parameters can be given by the data source to be used on the row */

          _fnRowAttributes(oSettings, row);
          /* Process each column */


          for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
            oCol = oSettings.aoColumns[i];
            create = nTrIn ? false : true;
            nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
            nTd._DT_CellIndex = {
              row: iRow,
              column: i
            };
            cells.push(nTd); // Need to create the HTML if new, or if a rendering function is defined

            if (create || (oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')) {
              nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
            }
            /* Add user defined class */


            if (oCol.sClass) {
              nTd.className += ' ' + oCol.sClass;
            } // Visibility - add or remove as required


            if (oCol.bVisible && !nTrIn) {
              nTr.appendChild(nTd);
            } else if (!oCol.bVisible && nTrIn) {
              nTd.parentNode.removeChild(nTd);
            }

            if (oCol.fnCreatedCell) {
              oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
            }
          }

          _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells]);
        }
      }
      /**
       * Add attributes to a row based on the special `DT_*` parameters in a data
       * source object.
       *  @param {object} settings DataTables settings object
       *  @param {object} DataTables row object for the row to be modified
       *  @memberof DataTable#oApi
       */


      function _fnRowAttributes(settings, row) {
        var tr = row.nTr;
        var data = row._aData;

        if (tr) {
          var id = settings.rowIdFn(data);

          if (id) {
            tr.id = id;
          }

          if (data.DT_RowClass) {
            // Remove any classes added by DT_RowClass before
            var a = data.DT_RowClass.split(' ');
            row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
            $(tr).removeClass(row.__rowc.join(' ')).addClass(data.DT_RowClass);
          }

          if (data.DT_RowAttr) {
            $(tr).attr(data.DT_RowAttr);
          }

          if (data.DT_RowData) {
            $(tr).data(data.DT_RowData);
          }
        }
      }
      /**
       * Create the HTML header for the table
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnBuildHead(oSettings) {
        var i, ien, cell, row, column;
        var thead = oSettings.nTHead;
        var tfoot = oSettings.nTFoot;
        var createHeader = $('th, td', thead).length === 0;
        var classes = oSettings.oClasses;
        var columns = oSettings.aoColumns;

        if (createHeader) {
          row = $('<tr/>').appendTo(thead);
        }

        for (i = 0, ien = columns.length; i < ien; i++) {
          column = columns[i];
          cell = $(column.nTh).addClass(column.sClass);

          if (createHeader) {
            cell.appendTo(row);
          } // 1.11 move into sorting


          if (oSettings.oFeatures.bSort) {
            cell.addClass(column.sSortingClass);

            if (column.bSortable !== false) {
              cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId);

              _fnSortAttachListener(oSettings, column.nTh, i);
            }
          }

          if (column.sTitle != cell[0].innerHTML) {
            cell.html(column.sTitle);
          }

          _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes);
        }

        if (createHeader) {
          _fnDetectHeader(oSettings.aoHeader, thead);
        }
        /* ARIA role for the rows */


        $(thead).children('tr').attr('role', 'row');
        /* Deal with the footer - add classes if required */

        $(thead).children('tr').children('th, td').addClass(classes.sHeaderTH);
        $(tfoot).children('tr').children('th, td').addClass(classes.sFooterTH); // Cache the footer cells. Note that we only take the cells from the first
        // row in the footer. If there is more than one row the user wants to
        // interact with, they need to use the table().foot() method. Note also this
        // allows cells to be used for multiple columns using colspan

        if (tfoot !== null) {
          var cells = oSettings.aoFooter[0];

          for (i = 0, ien = cells.length; i < ien; i++) {
            column = columns[i];
            column.nTf = cells[i].cell;

            if (column.sClass) {
              $(column.nTf).addClass(column.sClass);
            }
          }
        }
      }
      /**
       * Draw the header (or footer) element based on the column visibility states. The
       * methodology here is to use the layout array from _fnDetectHeader, modified for
       * the instantaneous column visibility, to construct the new layout. The grid is
       * traversed over cell at a time in a rows x columns grid fashion, although each
       * cell insert can cover multiple elements in the grid - which is tracks using the
       * aApplied array. Cell inserts in the grid will only occur where there isn't
       * already a cell in that position.
       *  @param {object} oSettings dataTables settings object
       *  @param array {objects} aoSource Layout array from _fnDetectHeader
       *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
       *  @memberof DataTable#oApi
       */


      function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
        var i, iLen, j, jLen, k, kLen, n, nLocalTr;
        var aoLocal = [];
        var aApplied = [];
        var iColumns = oSettings.aoColumns.length;
        var iRowspan, iColspan;

        if (!aoSource) {
          return;
        }

        if (bIncludeHidden === undefined) {
          bIncludeHidden = false;
        }
        /* Make a copy of the master layout array, but without the visible columns in it */


        for (i = 0, iLen = aoSource.length; i < iLen; i++) {
          aoLocal[i] = aoSource[i].slice();
          aoLocal[i].nTr = aoSource[i].nTr;
          /* Remove any columns which are currently hidden */

          for (j = iColumns - 1; j >= 0; j--) {
            if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
              aoLocal[i].splice(j, 1);
            }
          }
          /* Prep the applied array - it needs an element for each row */


          aApplied.push([]);
        }

        for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
          nLocalTr = aoLocal[i].nTr;
          /* All cells are going to be replaced, so empty out the row */

          if (nLocalTr) {
            while (n = nLocalTr.firstChild) {
              nLocalTr.removeChild(n);
            }
          }

          for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
            iRowspan = 1;
            iColspan = 1;
            /* Check to see if there is already a cell (row/colspan) covering our target
             * insert point. If there is, then there is nothing to do.
             */

            if (aApplied[i][j] === undefined) {
              nLocalTr.appendChild(aoLocal[i][j].cell);
              aApplied[i][j] = 1;
              /* Expand the cell to cover as many rows as needed */

              while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
                aApplied[i + iRowspan][j] = 1;
                iRowspan++;
              }
              /* Expand the cell to cover as many columns as needed */


              while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
                /* Must update the applied array over the rows for the columns */
                for (k = 0; k < iRowspan; k++) {
                  aApplied[i + k][j + iColspan] = 1;
                }

                iColspan++;
              }
              /* Do the actual expansion in the DOM */


              $(aoLocal[i][j].cell).attr('rowspan', iRowspan).attr('colspan', iColspan);
            }
          }
        }
      }
      /**
       * Insert the required TR nodes into the table for display
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnDraw(oSettings) {
        /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
        var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);

        if ($.inArray(false, aPreDraw) !== -1) {
          _fnProcessingDisplay(oSettings, false);

          return;
        }

        var i, iLen, n;
        var anRows = [];
        var iRowCount = 0;
        var asStripeClasses = oSettings.asStripeClasses;
        var iStripes = asStripeClasses.length;
        var iOpenRows = oSettings.aoOpenRows.length;
        var oLang = oSettings.oLanguage;
        var iInitDisplayStart = oSettings.iInitDisplayStart;
        var bServerSide = _fnDataSource(oSettings) == 'ssp';
        var aiDisplay = oSettings.aiDisplay;
        oSettings.bDrawing = true;
        /* Check and see if we have an initial draw position from state saving */

        if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
          oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
          oSettings.iInitDisplayStart = -1;
        }

        var iDisplayStart = oSettings._iDisplayStart;
        var iDisplayEnd = oSettings.fnDisplayEnd();
        /* Server-side processing draw intercept */

        if (oSettings.bDeferLoading) {
          oSettings.bDeferLoading = false;
          oSettings.iDraw++;

          _fnProcessingDisplay(oSettings, false);
        } else if (!bServerSide) {
          oSettings.iDraw++;
        } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
          return;
        }

        if (aiDisplay.length !== 0) {
          var iStart = bServerSide ? 0 : iDisplayStart;
          var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

          for (var j = iStart; j < iEnd; j++) {
            var iDataIndex = aiDisplay[j];
            var aoData = oSettings.aoData[iDataIndex];

            if (aoData.nTr === null) {
              _fnCreateTr(oSettings, iDataIndex);
            }

            var nRow = aoData.nTr;
            /* Remove the old striping classes and then add the new one */

            if (iStripes !== 0) {
              var sStripe = asStripeClasses[iRowCount % iStripes];

              if (aoData._sRowStripe != sStripe) {
                $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
                aoData._sRowStripe = sStripe;
              }
            } // Row callback functions - might want to manipulate the row
            // iRowCount and j are not currently documented. Are they at all
            // useful?


            _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j, iDataIndex]);

            anRows.push(nRow);
            iRowCount++;
          }
        } else {
          /* Table is empty - create a row with an empty message in it */
          var sZero = oLang.sZeroRecords;

          if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
            sZero = oLang.sLoadingRecords;
          } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
            sZero = oLang.sEmptyTable;
          }

          anRows[0] = $('<tr/>', {
            'class': iStripes ? asStripeClasses[0] : ''
          }).append($('<td />', {
            'valign': 'top',
            'colSpan': _fnVisbleColumns(oSettings),
            'class': oSettings.oClasses.sRowEmpty
          }).html(sZero))[0];
        }
        /* Header and footer callbacks */


        _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

        _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

        var body = $(oSettings.nTBody);
        body.children().detach();
        body.append($(anRows));
        /* Call all required callback functions for the end of a draw */

        _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);
        /* Draw is complete, sorting and filtering must be as well */


        oSettings.bSorted = false;
        oSettings.bFiltered = false;
        oSettings.bDrawing = false;
      }
      /**
       * Redraw the table - taking account of the various features which are enabled
       *  @param {object} oSettings dataTables settings object
       *  @param {boolean} [holdPosition] Keep the current paging position. By default
       *    the paging is reset to the first page
       *  @memberof DataTable#oApi
       */


      function _fnReDraw(settings, holdPosition) {
        var features = settings.oFeatures,
            sort = features.bSort,
            filter = features.bFilter;

        if (sort) {
          _fnSort(settings);
        }

        if (filter) {
          _fnFilterComplete(settings, settings.oPreviousSearch);
        } else {
          // No filtering, so we want to just use the display master
          settings.aiDisplay = settings.aiDisplayMaster.slice();
        }

        if (holdPosition !== true) {
          settings._iDisplayStart = 0;
        } // Let any modules know about the draw hold position state (used by
        // scrolling internally)


        settings._drawHold = holdPosition;

        _fnDraw(settings);

        settings._drawHold = false;
      }
      /**
       * Add the options to the page HTML for the table
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnAddOptionsHtml(oSettings) {
        var classes = oSettings.oClasses;
        var table = $(oSettings.nTable);
        var holding = $('<div/>').insertBefore(table); // Holding element for speed

        var features = oSettings.oFeatures; // All DataTables are wrapped in a div

        var insert = $('<div/>', {
          id: oSettings.sTableId + '_wrapper',
          'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
        });
        oSettings.nHolding = holding[0];
        oSettings.nTableWrapper = insert[0];
        oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
        /* Loop over the user set positioning and place the elements as needed */

        var aDom = oSettings.sDom.split('');
        var featureNode, cOption, nNewNode, cNext, sAttr, j;

        for (var i = 0; i < aDom.length; i++) {
          featureNode = null;
          cOption = aDom[i];

          if (cOption == '<') {
            /* New container div */
            nNewNode = $('<div/>')[0];
            /* Check to see if we should append an id and/or a class name to the container */

            cNext = aDom[i + 1];

            if (cNext == "'" || cNext == '"') {
              sAttr = "";
              j = 2;

              while (aDom[i + j] != cNext) {
                sAttr += aDom[i + j];
                j++;
              }
              /* Replace jQuery UI constants @todo depreciated */


              if (sAttr == "H") {
                sAttr = classes.sJUIHeader;
              } else if (sAttr == "F") {
                sAttr = classes.sJUIFooter;
              }
              /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
               * breaks the string into parts and applies them as needed
               */


              if (sAttr.indexOf('.') != -1) {
                var aSplit = sAttr.split('.');
                nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
                nNewNode.className = aSplit[1];
              } else if (sAttr.charAt(0) == "#") {
                nNewNode.id = sAttr.substr(1, sAttr.length - 1);
              } else {
                nNewNode.className = sAttr;
              }

              i += j;
              /* Move along the position array */
            }

            insert.append(nNewNode);
            insert = $(nNewNode);
          } else if (cOption == '>') {
            /* End container div */
            insert = insert.parent();
          } // @todo Move options into their own plugins?
          else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
              /* Length */
              featureNode = _fnFeatureHtmlLength(oSettings);
            } else if (cOption == 'f' && features.bFilter) {
              /* Filter */
              featureNode = _fnFeatureHtmlFilter(oSettings);
            } else if (cOption == 'r' && features.bProcessing) {
              /* pRocessing */
              featureNode = _fnFeatureHtmlProcessing(oSettings);
            } else if (cOption == 't') {
              /* Table */
              featureNode = _fnFeatureHtmlTable(oSettings);
            } else if (cOption == 'i' && features.bInfo) {
              /* Info */
              featureNode = _fnFeatureHtmlInfo(oSettings);
            } else if (cOption == 'p' && features.bPaginate) {
              /* Pagination */
              featureNode = _fnFeatureHtmlPaginate(oSettings);
            } else if (DataTable.ext.feature.length !== 0) {
              /* Plug-in features */
              var aoFeatures = DataTable.ext.feature;

              for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
                if (cOption == aoFeatures[k].cFeature) {
                  featureNode = aoFeatures[k].fnInit(oSettings);
                  break;
                }
              }
            }
          /* Add to the 2D features array */


          if (featureNode) {
            var aanFeatures = oSettings.aanFeatures;

            if (!aanFeatures[cOption]) {
              aanFeatures[cOption] = [];
            }

            aanFeatures[cOption].push(featureNode);
            insert.append(featureNode);
          }
        }
        /* Built our DOM structure - replace the holding div with what we want */


        holding.replaceWith(insert);
        oSettings.nHolding = null;
      }
      /**
       * Use the DOM source to create up an array of header cells. The idea here is to
       * create a layout grid (array) of rows x columns, which contains a reference
       * to the cell that that point in the grid (regardless of col/rowspan), such that
       * any column / row could be removed and the new grid constructed
       *  @param array {object} aLayout Array to store the calculated layout in
       *  @param {node} nThead The header/footer element for the table
       *  @memberof DataTable#oApi
       */


      function _fnDetectHeader(aLayout, nThead) {
        var nTrs = $(nThead).children('tr');
        var nTr, nCell;
        var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
        var bUnique;

        var fnShiftCol = function fnShiftCol(a, i, j) {
          var k = a[i];

          while (k[j]) {
            j++;
          }

          return j;
        };

        aLayout.splice(0, aLayout.length);
        /* We know how many rows there are in the layout - so prep it */

        for (i = 0, iLen = nTrs.length; i < iLen; i++) {
          aLayout.push([]);
        }
        /* Calculate a layout array */


        for (i = 0, iLen = nTrs.length; i < iLen; i++) {
          nTr = nTrs[i];
          iColumn = 0;
          /* For every cell in the row... */

          nCell = nTr.firstChild;

          while (nCell) {
            if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
              /* Get the col and rowspan attributes from the DOM and sanitise them */
              iColspan = nCell.getAttribute('colspan') * 1;
              iRowspan = nCell.getAttribute('rowspan') * 1;
              iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
              iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
              /* There might be colspan cells already in this row, so shift our target
               * accordingly
               */

              iColShifted = fnShiftCol(aLayout, i, iColumn);
              /* Cache calculation for unique columns */

              bUnique = iColspan === 1 ? true : false;
              /* If there is col / rowspan, copy the information into the layout grid */

              for (l = 0; l < iColspan; l++) {
                for (k = 0; k < iRowspan; k++) {
                  aLayout[i + k][iColShifted + l] = {
                    "cell": nCell,
                    "unique": bUnique
                  };
                  aLayout[i + k].nTr = nTr;
                }
              }
            }

            nCell = nCell.nextSibling;
          }
        }
      }
      /**
       * Get an array of unique th elements, one for each column
       *  @param {object} oSettings dataTables settings object
       *  @param {node} nHeader automatically detect the layout from this node - optional
       *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
       *  @returns array {node} aReturn list of unique th's
       *  @memberof DataTable#oApi
       */


      function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
        var aReturn = [];

        if (!aLayout) {
          aLayout = oSettings.aoHeader;

          if (nHeader) {
            aLayout = [];

            _fnDetectHeader(aLayout, nHeader);
          }
        }

        for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
          for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
            if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
              aReturn[j] = aLayout[i][j].cell;
            }
          }
        }

        return aReturn;
      }
      /**
       * Create an Ajax call based on the table's settings, taking into account that
       * parameters can have multiple forms, and backwards compatibility.
       *
       * @param {object} oSettings dataTables settings object
       * @param {array} data Data to send to the server, required by
       *     DataTables - may be augmented by developer callbacks
       * @param {function} fn Callback function to run when data is obtained
       */


      function _fnBuildAjax(oSettings, data, fn) {
        // Compatibility with 1.9-, allow fnServerData and event to manipulate
        _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]); // Convert to object based for 1.10+ if using the old array scheme which can
        // come from server-side processing or serverParams


        if (data && Array.isArray(data)) {
          var tmp = {};
          var rbracket = /(.*?)\[\]$/;
          $.each(data, function (key, val) {
            var match = val.name.match(rbracket);

            if (match) {
              // Support for arrays
              var name = match[0];

              if (!tmp[name]) {
                tmp[name] = [];
              }

              tmp[name].push(val.value);
            } else {
              tmp[val.name] = val.value;
            }
          });
          data = tmp;
        }

        var ajaxData;
        var ajax = oSettings.ajax;
        var instance = oSettings.oInstance;

        var callback = function callback(json) {
          _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);

          fn(json);
        };

        if ($.isPlainObject(ajax) && ajax.data) {
          ajaxData = ajax.data;
          var newData = typeof ajaxData === 'function' ? ajaxData(data, oSettings) : // fn can manipulate data or return
          ajaxData; // an object object or array to merge
          // If the function returned something, use that alone

          data = typeof ajaxData === 'function' && newData ? newData : $.extend(true, data, newData); // Remove the data property as we've resolved it already and don't want
          // jQuery to do it again (it is restored at the end of the function)

          delete ajax.data;
        }

        var baseAjax = {
          "data": data,
          "success": function success(json) {
            var error = json.error || json.sError;

            if (error) {
              _fnLog(oSettings, 0, error);
            }

            oSettings.json = json;
            callback(json);
          },
          "dataType": "json",
          "cache": false,
          "type": oSettings.sServerMethod,
          "error": function error(xhr, _error, thrown) {
            var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

            if ($.inArray(true, ret) === -1) {
              if (_error == "parsererror") {
                _fnLog(oSettings, 0, 'Invalid JSON response', 1);
              } else if (xhr.readyState === 4) {
                _fnLog(oSettings, 0, 'Ajax error', 7);
              }
            }

            _fnProcessingDisplay(oSettings, false);
          }
        }; // Store the data submitted for the API

        oSettings.oAjaxData = data; // Allow plug-ins and external processes to modify the data

        _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

        if (oSettings.fnServerData) {
          // DataTables 1.9- compatibility
          oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function (val, key) {
            // Need to convert back to 1.9 trad format
            return {
              name: key,
              value: val
            };
          }), callback, oSettings);
        } else if (oSettings.sAjaxSource || typeof ajax === 'string') {
          // DataTables 1.9- compatibility
          oSettings.jqXHR = $.ajax($.extend(baseAjax, {
            url: ajax || oSettings.sAjaxSource
          }));
        } else if (typeof ajax === 'function') {
          // Is a function - let the caller define what needs to be done
          oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
        } else {
          // Object to extend the base settings
          oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax)); // Restore for next time around

          ajax.data = ajaxData;
        }
      }
      /**
       * Update the table using an Ajax call
       *  @param {object} settings dataTables settings object
       *  @returns {boolean} Block the table drawing or not
       *  @memberof DataTable#oApi
       */


      function _fnAjaxUpdate(settings) {
        if (settings.bAjaxDataGet) {
          settings.iDraw++;

          _fnProcessingDisplay(settings, true);

          _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {
            _fnAjaxUpdateDraw(settings, json);
          });

          return false;
        }

        return true;
      }
      /**
       * Build up the parameters in an object needed for a server-side processing
       * request. Note that this is basically done twice, is different ways - a modern
       * method which is used by default in DataTables 1.10 which uses objects and
       * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
       * the sAjaxSource option is used in the initialisation, or the legacyAjax
       * option is set.
       *  @param {object} oSettings dataTables settings object
       *  @returns {bool} block the table drawing or not
       *  @memberof DataTable#oApi
       */


      function _fnAjaxParameters(settings) {
        var columns = settings.aoColumns,
            columnCount = columns.length,
            features = settings.oFeatures,
            preSearch = settings.oPreviousSearch,
            preColSearch = settings.aoPreSearchCols,
            i,
            data = [],
            dataProp,
            column,
            columnSearch,
            sort = _fnSortFlatten(settings),
            displayStart = settings._iDisplayStart,
            displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;

        var param = function param(name, value) {
          data.push({
            'name': name,
            'value': value
          });
        }; // DataTables 1.9- compatible method


        param('sEcho', settings.iDraw);
        param('iColumns', columnCount);
        param('sColumns', _pluck(columns, 'sName').join(','));
        param('iDisplayStart', displayStart);
        param('iDisplayLength', displayLength); // DataTables 1.10+ method

        var d = {
          draw: settings.iDraw,
          columns: [],
          order: [],
          start: displayStart,
          length: displayLength,
          search: {
            value: preSearch.sSearch,
            regex: preSearch.bRegex
          }
        };

        for (i = 0; i < columnCount; i++) {
          column = columns[i];
          columnSearch = preColSearch[i];
          dataProp = typeof column.mData == "function" ? 'function' : column.mData;
          d.columns.push({
            data: dataProp,
            name: column.sName,
            searchable: column.bSearchable,
            orderable: column.bSortable,
            search: {
              value: columnSearch.sSearch,
              regex: columnSearch.bRegex
            }
          });
          param("mDataProp_" + i, dataProp);

          if (features.bFilter) {
            param('sSearch_' + i, columnSearch.sSearch);
            param('bRegex_' + i, columnSearch.bRegex);
            param('bSearchable_' + i, column.bSearchable);
          }

          if (features.bSort) {
            param('bSortable_' + i, column.bSortable);
          }
        }

        if (features.bFilter) {
          param('sSearch', preSearch.sSearch);
          param('bRegex', preSearch.bRegex);
        }

        if (features.bSort) {
          $.each(sort, function (i, val) {
            d.order.push({
              column: val.col,
              dir: val.dir
            });
            param('iSortCol_' + i, val.col);
            param('sSortDir_' + i, val.dir);
          });
          param('iSortingCols', sort.length);
        } // If the legacy.ajax parameter is null, then we automatically decide which
        // form to use, based on sAjaxSource


        var legacy = DataTable.ext.legacy.ajax;

        if (legacy === null) {
          return settings.sAjaxSource ? data : d;
        } // Otherwise, if legacy has been specified then we use that to decide on the
        // form


        return legacy ? data : d;
      }
      /**
       * Data the data from the server (nuking the old) and redraw the table
       *  @param {object} oSettings dataTables settings object
       *  @param {object} json json data return from the server.
       *  @param {string} json.sEcho Tracking flag for DataTables to match requests
       *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
       *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
       *  @param {array} json.aaData The data to display on this page
       *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
       *  @memberof DataTable#oApi
       */


      function _fnAjaxUpdateDraw(settings, json) {
        // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
        // Support both
        var compat = function compat(old, modern) {
          return json[old] !== undefined ? json[old] : json[modern];
        };

        var data = _fnAjaxDataSrc(settings, json);

        var draw = compat('sEcho', 'draw');
        var recordsTotal = compat('iTotalRecords', 'recordsTotal');
        var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

        if (draw !== undefined) {
          // Protect against out of sequence returns
          if (draw * 1 < settings.iDraw) {
            return;
          }

          settings.iDraw = draw * 1;
        }

        _fnClearTable(settings);

        settings._iRecordsTotal = parseInt(recordsTotal, 10);
        settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData(settings, data[i]);
        }

        settings.aiDisplay = settings.aiDisplayMaster.slice();
        settings.bAjaxDataGet = false;

        _fnDraw(settings);

        if (!settings._bInitComplete) {
          _fnInitComplete(settings, json);
        }

        settings.bAjaxDataGet = true;

        _fnProcessingDisplay(settings, false);
      }
      /**
       * Get the data from the JSON data source to use for drawing a table. Using
       * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
       * source object, or from a processing function.
       *  @param {object} oSettings dataTables settings object
       *  @param  {object} json Data source object / array from the server
       *  @return {array} Array of data to use
       */


      function _fnAjaxDataSrc(oSettings, json) {
        var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp; // Compatibility with 1.9-.
        // Compatibility with 1.9-. In order to read from aaData, check if the
        // default has been changed, if not, check for aaData

        if (dataSrc === 'data') {
          return json.aaData || json[dataSrc];
        }

        return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
      }
      /**
       * Generate the node required for filtering text
       *  @returns {node} Filter control element
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnFeatureHtmlFilter(settings) {
        var classes = settings.oClasses;
        var tableId = settings.sTableId;
        var language = settings.oLanguage;
        var previousSearch = settings.oPreviousSearch;
        var features = settings.aanFeatures;
        var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
        var str = language.sSearch;
        str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input;
        var filter = $('<div/>', {
          'id': !features.f ? tableId + '_filter' : null,
          'class': classes.sFilter
        }).append($('<label/>').append(str));

        var searchFn = function searchFn() {
          /* Update all other filter input elements for the new display */
          var n = features.f;
          var val = !this.value ? "" : this.value; // mental IE8 fix :-(

          /* Now do the filter */

          if (val != previousSearch.sSearch) {
            _fnFilterComplete(settings, {
              "sSearch": val,
              "bRegex": previousSearch.bRegex,
              "bSmart": previousSearch.bSmart,
              "bCaseInsensitive": previousSearch.bCaseInsensitive
            }); // Need to redraw, without resorting


            settings._iDisplayStart = 0;

            _fnDraw(settings);
          }
        };

        var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === 'ssp' ? 400 : 0;
        var jqFilter = $('input', filter).val(previousSearch.sSearch).attr('placeholder', language.sSearchPlaceholder).on('keyup.DT search.DT input.DT paste.DT cut.DT', searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).on('mouseup', function (e) {
          // Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
          // on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
          // checks the value to see if it has changed. In other browsers it won't have.
          setTimeout(function () {
            searchFn.call(jqFilter[0]);
          }, 10);
        }).on('keypress.DT', function (e) {
          /* Prevent form submission */
          if (e.keyCode == 13) {
            return false;
          }
        }).attr('aria-controls', tableId); // Update the input elements whenever the table is filtered

        $(settings.nTable).on('search.dt.DT', function (ev, s) {
          if (settings === s) {
            // IE9 throws an 'unknown error' if document.activeElement is used
            // inside an iframe or frame...
            try {
              if (jqFilter[0] !== document.activeElement) {
                jqFilter.val(previousSearch.sSearch);
              }
            } catch (e) {}
          }
        });
        return filter[0];
      }
      /**
       * Filter the table using both the global filter and column based filtering
       *  @param {object} oSettings dataTables settings object
       *  @param {object} oSearch search information
       *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
       *  @memberof DataTable#oApi
       */


      function _fnFilterComplete(oSettings, oInput, iForce) {
        var oPrevSearch = oSettings.oPreviousSearch;
        var aoPrevSearch = oSettings.aoPreSearchCols;

        var fnSaveFilter = function fnSaveFilter(oFilter) {
          /* Save the filtering values */
          oPrevSearch.sSearch = oFilter.sSearch;
          oPrevSearch.bRegex = oFilter.bRegex;
          oPrevSearch.bSmart = oFilter.bSmart;
          oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
        };

        var fnRegex = function fnRegex(o) {
          // Backwards compatibility with the bEscapeRegex option
          return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
        }; // Resolve any column types that are unknown due to addition or invalidation
        // @todo As per sort - can this be moved into an event handler?


        _fnColumnTypes(oSettings);
        /* In server-side processing all filtering is done by the server, so no point hanging around here */


        if (_fnDataSource(oSettings) != 'ssp') {
          /* Global filter */
          _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);

          fnSaveFilter(oInput);
          /* Now do the individual column filter */

          for (var i = 0; i < aoPrevSearch.length; i++) {
            _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
          }
          /* Custom filtering */


          _fnFilterCustom(oSettings);
        } else {
          fnSaveFilter(oInput);
        }
        /* Tell the draw function we have been filtering */


        oSettings.bFiltered = true;

        _fnCallbackFire(oSettings, null, 'search', [oSettings]);
      }
      /**
       * Apply custom filtering functions
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnFilterCustom(settings) {
        var filters = DataTable.ext.search;
        var displayRows = settings.aiDisplay;
        var row, rowIdx;

        for (var i = 0, ien = filters.length; i < ien; i++) {
          var rows = []; // Loop over each row and see if it should be included

          for (var j = 0, jen = displayRows.length; j < jen; j++) {
            rowIdx = displayRows[j];
            row = settings.aoData[rowIdx];

            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
              rows.push(rowIdx);
            }
          } // So the array reference doesn't break set the results into the
          // existing array


          displayRows.length = 0;
          $.merge(displayRows, rows);
        }
      }
      /**
       * Filter the table on a per-column basis
       *  @param {object} oSettings dataTables settings object
       *  @param {string} sInput string to filter on
       *  @param {int} iColumn column to filter
       *  @param {bool} bRegex treat search string as a regular expression or not
       *  @param {bool} bSmart use smart filtering or not
       *  @param {bool} bCaseInsensitive Do case insenstive matching or not
       *  @memberof DataTable#oApi
       */


      function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
        if (searchStr === '') {
          return;
        }

        var data;
        var out = [];
        var display = settings.aiDisplay;

        var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

        for (var i = 0; i < display.length; i++) {
          data = settings.aoData[display[i]]._aFilterData[colIdx];

          if (rpSearch.test(data)) {
            out.push(display[i]);
          }
        }

        settings.aiDisplay = out;
      }
      /**
       * Filter the data table based on user input and draw the table
       *  @param {object} settings dataTables settings object
       *  @param {string} input string to filter on
       *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
       *  @param {bool} regex treat as a regular expression or not
       *  @param {bool} smart perform smart filtering or not
       *  @param {bool} caseInsensitive Do case insenstive matching or not
       *  @memberof DataTable#oApi
       */


      function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
        var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);

        var prevSearch = settings.oPreviousSearch.sSearch;
        var displayMaster = settings.aiDisplayMaster;
        var display, invalidated, i;
        var filtered = []; // Need to take account of custom filtering functions - always filter

        if (DataTable.ext.search.length !== 0) {
          force = true;
        } // Check if any of the rows were invalidated


        invalidated = _fnFilterData(settings); // If the input is blank - we just want the full data set

        if (input.length <= 0) {
          settings.aiDisplay = displayMaster.slice();
        } else {
          // New search - start from the master array
          if (invalidated || force || regex || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted // On resort, the display master needs to be
          // re-filtered since indexes will have changed
          ) {
              settings.aiDisplay = displayMaster.slice();
            } // Search the display array


          display = settings.aiDisplay;

          for (i = 0; i < display.length; i++) {
            if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
              filtered.push(display[i]);
            }
          }

          settings.aiDisplay = filtered;
        }
      }
      /**
       * Build a regular expression object suitable for searching a table
       *  @param {string} sSearch string to search for
       *  @param {bool} bRegex treat as a regular expression or not
       *  @param {bool} bSmart perform smart filtering or not
       *  @param {bool} bCaseInsensitive Do case insensitive matching or not
       *  @returns {RegExp} constructed object
       *  @memberof DataTable#oApi
       */


      function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
        search = regex ? search : _fnEscapeRegex(search);

        if (smart) {
          /* For smart filtering we want to allow the search to work regardless of
           * word order. We also want double quoted text to be preserved, so word
           * order is important - a la google. So this is what we want to
           * generate:
           * 
           * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
           */
          var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
            if (word.charAt(0) === '"') {
              var m = word.match(/^"(.*)"$/);
              word = m ? m[1] : word;
            }

            return word.replace('"', '');
          });
          search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
        }

        return new RegExp(search, caseInsensitive ? 'i' : '');
      }
      /**
       * Escape a string such that it can be used in a regular expression
       *  @param {string} sVal string to escape
       *  @returns {string} escaped string
       *  @memberof DataTable#oApi
       */


      var _fnEscapeRegex = DataTable.util.escapeRegex;
      var __filter_div = $('<div>')[0];

      var __filter_div_textContent = __filter_div.textContent !== undefined; // Update the filtering data for each row if needed (by invalidation or first run)


      function _fnFilterData(settings) {
        var columns = settings.aoColumns;
        var column;
        var i, j, ien, jen, filterData, cellData, row;
        var fomatters = DataTable.ext.type.search;
        var wasInvalidated = false;

        for (i = 0, ien = settings.aoData.length; i < ien; i++) {
          row = settings.aoData[i];

          if (!row._aFilterData) {
            filterData = [];

            for (j = 0, jen = columns.length; j < jen; j++) {
              column = columns[j];

              if (column.bSearchable) {
                cellData = _fnGetCellData(settings, i, j, 'filter');

                if (fomatters[column.sType]) {
                  cellData = fomatters[column.sType](cellData);
                } // Search in DataTables 1.10 is string based. In 1.11 this
                // should be altered to also allow strict type checking.


                if (cellData === null) {
                  cellData = '';
                }

                if (typeof cellData !== 'string' && cellData.toString) {
                  cellData = cellData.toString();
                }
              } else {
                cellData = '';
              } // If it looks like there is an HTML entity in the string,
              // attempt to decode it so sorting works as expected. Note that
              // we could use a single line of jQuery to do this, but the DOM
              // method used here is much faster http://jsperf.com/html-decode


              if (cellData.indexOf && cellData.indexOf('&') !== -1) {
                __filter_div.innerHTML = cellData;
                cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
              }

              if (cellData.replace) {
                cellData = cellData.replace(/[\r\n\u2028]/g, '');
              }

              filterData.push(cellData);
            }

            row._aFilterData = filterData;
            row._sFilterRow = filterData.join('  ');
            wasInvalidated = true;
          }
        }

        return wasInvalidated;
      }
      /**
       * Convert from the internal Hungarian notation to camelCase for external
       * interaction
       *  @param {object} obj Object to convert
       *  @returns {object} Inverted object
       *  @memberof DataTable#oApi
       */


      function _fnSearchToCamel(obj) {
        return {
          search: obj.sSearch,
          smart: obj.bSmart,
          regex: obj.bRegex,
          caseInsensitive: obj.bCaseInsensitive
        };
      }
      /**
       * Convert from camelCase notation to the internal Hungarian. We could use the
       * Hungarian convert function here, but this is cleaner
       *  @param {object} obj Object to convert
       *  @returns {object} Inverted object
       *  @memberof DataTable#oApi
       */


      function _fnSearchToHung(obj) {
        return {
          sSearch: obj.search,
          bSmart: obj.smart,
          bRegex: obj.regex,
          bCaseInsensitive: obj.caseInsensitive
        };
      }
      /**
       * Generate the node required for the info display
       *  @param {object} oSettings dataTables settings object
       *  @returns {node} Information element
       *  @memberof DataTable#oApi
       */


      function _fnFeatureHtmlInfo(settings) {
        var tid = settings.sTableId,
            nodes = settings.aanFeatures.i,
            n = $('<div/>', {
          'class': settings.oClasses.sInfo,
          'id': !nodes ? tid + '_info' : null
        });

        if (!nodes) {
          // Update display on each draw
          settings.aoDrawCallback.push({
            "fn": _fnUpdateInfo,
            "sName": "information"
          });
          n.attr('role', 'status').attr('aria-live', 'polite'); // Table is described by our info div

          $(settings.nTable).attr('aria-describedby', tid + '_info');
        }

        return n[0];
      }
      /**
       * Update the information elements in the display
       *  @param {object} settings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnUpdateInfo(settings) {
        /* Show information about the table */
        var nodes = settings.aanFeatures.i;

        if (nodes.length === 0) {
          return;
        }

        var lang = settings.oLanguage,
            start = settings._iDisplayStart + 1,
            end = settings.fnDisplayEnd(),
            max = settings.fnRecordsTotal(),
            total = settings.fnRecordsDisplay(),
            out = total ? lang.sInfo : lang.sInfoEmpty;

        if (total !== max) {
          /* Record set after filtering */
          out += ' ' + lang.sInfoFiltered;
        } // Convert the macros


        out += lang.sInfoPostFix;
        out = _fnInfoMacros(settings, out);
        var callback = lang.fnInfoCallback;

        if (callback !== null) {
          out = callback.call(settings.oInstance, settings, start, end, max, total, out);
        }

        $(nodes).html(out);
      }

      function _fnInfoMacros(settings, str) {
        // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
        // internally
        var formatter = settings.fnFormatNumber,
            start = settings._iDisplayStart + 1,
            len = settings._iDisplayLength,
            vis = settings.fnRecordsDisplay(),
            all = len === -1;
        return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
      }
      /**
       * Draw the table for the first time, adding all required features
       *  @param {object} settings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnInitialise(settings) {
        var i,
            iLen,
            iAjaxStart = settings.iInitDisplayStart;
        var columns = settings.aoColumns,
            column;
        var features = settings.oFeatures;
        var deferLoading = settings.bDeferLoading; // value modified by the draw

        /* Ensure that the table data is fully initialised */

        if (!settings.bInitialised) {
          setTimeout(function () {
            _fnInitialise(settings);
          }, 200);
          return;
        }
        /* Show the display HTML options */


        _fnAddOptionsHtml(settings);
        /* Build and draw the header / footer for the table */


        _fnBuildHead(settings);

        _fnDrawHead(settings, settings.aoHeader);

        _fnDrawHead(settings, settings.aoFooter);
        /* Okay to show that something is going on now */


        _fnProcessingDisplay(settings, true);
        /* Calculate sizes for columns */


        if (features.bAutoWidth) {
          _fnCalculateColumnWidths(settings);
        }

        for (i = 0, iLen = columns.length; i < iLen; i++) {
          column = columns[i];

          if (column.sWidth) {
            column.nTh.style.width = _fnStringToCss(column.sWidth);
          }
        }

        _fnCallbackFire(settings, null, 'preInit', [settings]); // If there is default sorting required - let's do it. The sort function
        // will do the drawing for us. Otherwise we draw the table regardless of the
        // Ajax source - this allows the table to look initialised for Ajax sourcing
        // data (show 'loading' message possibly)


        _fnReDraw(settings); // Server-side processing init complete is done by _fnAjaxUpdateDraw


        var dataSrc = _fnDataSource(settings);

        if (dataSrc != 'ssp' || deferLoading) {
          // if there is an ajax source load the data
          if (dataSrc == 'ajax') {
            _fnBuildAjax(settings, [], function (json) {
              var aData = _fnAjaxDataSrc(settings, json); // Got the data - add it to the table


              for (i = 0; i < aData.length; i++) {
                _fnAddData(settings, aData[i]);
              } // Reset the init display for cookie saving. We've already done
              // a filter, and therefore cleared it before. So we need to make
              // it appear 'fresh'


              settings.iInitDisplayStart = iAjaxStart;

              _fnReDraw(settings);

              _fnProcessingDisplay(settings, false);

              _fnInitComplete(settings, json);
            }, settings);
          } else {
            _fnProcessingDisplay(settings, false);

            _fnInitComplete(settings);
          }
        }
      }
      /**
       * Draw the table for the first time, adding all required features
       *  @param {object} oSettings dataTables settings object
       *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
       *    with client-side processing (optional)
       *  @memberof DataTable#oApi
       */


      function _fnInitComplete(settings, json) {
        settings._bInitComplete = true; // When data was added after the initialisation (data or Ajax) we need to
        // calculate the column sizing

        if (json || settings.oInit.aaData) {
          _fnAdjustColumnSizing(settings);
        }

        _fnCallbackFire(settings, null, 'plugin-init', [settings, json]);

        _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
      }

      function _fnLengthChange(settings, val) {
        var len = parseInt(val, 10);
        settings._iDisplayLength = len;

        _fnLengthOverflow(settings); // Fire length change event


        _fnCallbackFire(settings, null, 'length', [settings, len]);
      }
      /**
       * Generate the node required for user display length changing
       *  @param {object} settings dataTables settings object
       *  @returns {node} Display length feature node
       *  @memberof DataTable#oApi
       */


      function _fnFeatureHtmlLength(settings) {
        var classes = settings.oClasses,
            tableId = settings.sTableId,
            menu = settings.aLengthMenu,
            d2 = Array.isArray(menu[0]),
            lengths = d2 ? menu[0] : menu,
            language = d2 ? menu[1] : menu;
        var select = $('<select/>', {
          'name': tableId + '_length',
          'aria-controls': tableId,
          'class': classes.sLengthSelect
        });

        for (var i = 0, ien = lengths.length; i < ien; i++) {
          select[0][i] = new Option(typeof language[i] === 'number' ? settings.fnFormatNumber(language[i]) : language[i], lengths[i]);
        }

        var div = $('<div><label/></div>').addClass(classes.sLength);

        if (!settings.aanFeatures.l) {
          div[0].id = tableId + '_length';
        }

        div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)); // Can't use `select` variable as user might provide their own and the
        // reference is broken by the use of outerHTML

        $('select', div).val(settings._iDisplayLength).on('change.DT', function (e) {
          _fnLengthChange(settings, $(this).val());

          _fnDraw(settings);
        }); // Update node value whenever anything changes the table's length

        $(settings.nTable).on('length.dt.DT', function (e, s, len) {
          if (settings === s) {
            $('select', div).val(len);
          }
        });
        return div[0];
      }
      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
       * Note that most of the paging logic is done in
       * DataTable.ext.pager
       */

      /**
       * Generate the node required for default pagination
       *  @param {object} oSettings dataTables settings object
       *  @returns {node} Pagination feature node
       *  @memberof DataTable#oApi
       */


      function _fnFeatureHtmlPaginate(settings) {
        var type = settings.sPaginationType,
            plugin = DataTable.ext.pager[type],
            modern = typeof plugin === 'function',
            redraw = function redraw(settings) {
          _fnDraw(settings);
        },
            node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
            features = settings.aanFeatures;

        if (!modern) {
          plugin.fnInit(settings, node, redraw);
        }
        /* Add a draw callback for the pagination on first instance, to update the paging display */


        if (!features.p) {
          node.id = settings.sTableId + '_paginate';
          settings.aoDrawCallback.push({
            "fn": function fn(settings) {
              if (modern) {
                var start = settings._iDisplayStart,
                    len = settings._iDisplayLength,
                    visRecords = settings.fnRecordsDisplay(),
                    all = len === -1,
                    page = all ? 0 : Math.ceil(start / len),
                    pages = all ? 1 : Math.ceil(visRecords / len),
                    buttons = plugin(page, pages),
                    i,
                    ien;

                for (i = 0, ien = features.p.length; i < ien; i++) {
                  _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages);
                }
              } else {
                plugin.fnUpdate(settings, redraw);
              }
            },
            "sName": "pagination"
          });
        }

        return node;
      }
      /**
       * Alter the display settings to change the page
       *  @param {object} settings DataTables settings object
       *  @param {string|int} action Paging action to take: "first", "previous",
       *    "next" or "last" or page number to jump to (integer)
       *  @param [bool] redraw Automatically draw the update or not
       *  @returns {bool} true page has changed, false - no change
       *  @memberof DataTable#oApi
       */


      function _fnPageChange(settings, action, redraw) {
        var start = settings._iDisplayStart,
            len = settings._iDisplayLength,
            records = settings.fnRecordsDisplay();

        if (records === 0 || len === -1) {
          start = 0;
        } else if (typeof action === "number") {
          start = action * len;

          if (start > records) {
            start = 0;
          }
        } else if (action == "first") {
          start = 0;
        } else if (action == "previous") {
          start = len >= 0 ? start - len : 0;

          if (start < 0) {
            start = 0;
          }
        } else if (action == "next") {
          if (start + len < records) {
            start += len;
          }
        } else if (action == "last") {
          start = Math.floor((records - 1) / len) * len;
        } else {
          _fnLog(settings, 0, "Unknown paging action: " + action, 5);
        }

        var changed = settings._iDisplayStart !== start;
        settings._iDisplayStart = start;

        if (changed) {
          _fnCallbackFire(settings, null, 'page', [settings]);

          if (redraw) {
            _fnDraw(settings);
          }
        }

        return changed;
      }
      /**
       * Generate the node required for the processing node
       *  @param {object} settings dataTables settings object
       *  @returns {node} Processing element
       *  @memberof DataTable#oApi
       */


      function _fnFeatureHtmlProcessing(settings) {
        return $('<div/>', {
          'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
          'class': settings.oClasses.sProcessing
        }).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
      }
      /**
       * Display or hide the processing indicator
       *  @param {object} settings dataTables settings object
       *  @param {bool} show Show the processing indicator (true) or not (false)
       *  @memberof DataTable#oApi
       */


      function _fnProcessingDisplay(settings, show) {
        if (settings.oFeatures.bProcessing) {
          $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
        }

        _fnCallbackFire(settings, null, 'processing', [settings, show]);
      }
      /**
       * Add any control elements for the table - specifically scrolling
       *  @param {object} settings dataTables settings object
       *  @returns {node} Node to add to the DOM
       *  @memberof DataTable#oApi
       */


      function _fnFeatureHtmlTable(settings) {
        var table = $(settings.nTable); // Add the ARIA grid role to the table

        table.attr('role', 'grid'); // Scrolling from here on in

        var scroll = settings.oScroll;

        if (scroll.sX === '' && scroll.sY === '') {
          return settings.nTable;
        }

        var scrollX = scroll.sX;
        var scrollY = scroll.sY;
        var classes = settings.oClasses;
        var caption = table.children('caption');
        var captionSide = caption.length ? caption[0]._captionSide : null;
        var headerClone = $(table[0].cloneNode(false));
        var footerClone = $(table[0].cloneNode(false));
        var footer = table.children('tfoot');
        var _div = '<div/>';

        var size = function size(s) {
          return !s ? null : _fnStringToCss(s);
        };

        if (!footer.length) {
          footer = null;
        }
        /*
         * The HTML structure that we want to generate in this function is:
         *  div - scroller
         *    div - scroll head
         *      div - scroll head inner
         *        table - scroll head table
         *          thead - thead
         *    div - scroll body
         *      table - table (master table)
         *        thead - thead clone for sizing
         *        tbody - tbody
         *    div - scroll foot
         *      div - scroll foot inner
         *        table - scroll foot table
         *          tfoot - tfoot
         */


        var scroller = $(_div, {
          'class': classes.sScrollWrapper
        }).append($(_div, {
          'class': classes.sScrollHead
        }).css({
          overflow: 'hidden',
          position: 'relative',
          border: 0,
          width: scrollX ? size(scrollX) : '100%'
        }).append($(_div, {
          'class': classes.sScrollHeadInner
        }).css({
          'box-sizing': 'content-box',
          width: scroll.sXInner || '100%'
        }).append(headerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'top' ? caption : null).append(table.children('thead'))))).append($(_div, {
          'class': classes.sScrollBody
        }).css({
          position: 'relative',
          overflow: 'auto',
          width: size(scrollX)
        }).append(table));

        if (footer) {
          scroller.append($(_div, {
            'class': classes.sScrollFoot
          }).css({
            overflow: 'hidden',
            border: 0,
            width: scrollX ? size(scrollX) : '100%'
          }).append($(_div, {
            'class': classes.sScrollFootInner
          }).append(footerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'bottom' ? caption : null).append(table.children('tfoot')))));
        }

        var children = scroller.children();
        var scrollHead = children[0];
        var scrollBody = children[1];
        var scrollFoot = footer ? children[2] : null; // When the body is scrolled, then we also want to scroll the headers

        if (scrollX) {
          $(scrollBody).on('scroll.DT', function (e) {
            var scrollLeft = this.scrollLeft;
            scrollHead.scrollLeft = scrollLeft;

            if (footer) {
              scrollFoot.scrollLeft = scrollLeft;
            }
          });
        }

        $(scrollBody).css('max-height', scrollY);

        if (!scroll.bCollapse) {
          $(scrollBody).css('height', scrollY);
        }

        settings.nScrollHead = scrollHead;
        settings.nScrollBody = scrollBody;
        settings.nScrollFoot = scrollFoot; // On redraw - align columns

        settings.aoDrawCallback.push({
          "fn": _fnScrollDraw,
          "sName": "scrolling"
        });
        return scroller[0];
      }
      /**
       * Update the header, footer and body tables for resizing - i.e. column
       * alignment.
       *
       * Welcome to the most horrible function DataTables. The process that this
       * function follows is basically:
       *   1. Re-create the table inside the scrolling div
       *   2. Take live measurements from the DOM
       *   3. Apply the measurements to align the columns
       *   4. Clean up
       *
       *  @param {object} settings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnScrollDraw(settings) {
        // Given that this is such a monster function, a lot of variables are use
        // to try and keep the minimised size as small as possible
        var scroll = settings.oScroll,
            scrollX = scroll.sX,
            scrollXInner = scroll.sXInner,
            scrollY = scroll.sY,
            barWidth = scroll.iBarWidth,
            divHeader = $(settings.nScrollHead),
            divHeaderStyle = divHeader[0].style,
            divHeaderInner = divHeader.children('div'),
            divHeaderInnerStyle = divHeaderInner[0].style,
            divHeaderTable = divHeaderInner.children('table'),
            divBodyEl = settings.nScrollBody,
            divBody = $(divBodyEl),
            divBodyStyle = divBodyEl.style,
            divFooter = $(settings.nScrollFoot),
            divFooterInner = divFooter.children('div'),
            divFooterTable = divFooterInner.children('table'),
            header = $(settings.nTHead),
            table = $(settings.nTable),
            tableEl = table[0],
            tableStyle = tableEl.style,
            footer = settings.nTFoot ? $(settings.nTFoot) : null,
            browser = settings.oBrowser,
            ie67 = browser.bScrollOversize,
            dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),
            headerTrgEls,
            footerTrgEls,
            headerSrcEls,
            footerSrcEls,
            headerCopy,
            footerCopy,
            headerWidths = [],
            footerWidths = [],
            headerContent = [],
            footerContent = [],
            idx,
            correction,
            sanityWidth,
            zeroOut = function zeroOut(nSizer) {
          var style = nSizer.style;
          style.paddingTop = "0";
          style.paddingBottom = "0";
          style.borderTopWidth = "0";
          style.borderBottomWidth = "0";
          style.height = 0;
        }; // If the scrollbar visibility has changed from the last draw, we need to
        // adjust the column sizes as the table width will have changed to account
        // for the scrollbar


        var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;

        if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
          settings.scrollBarVis = scrollBarVis;

          _fnAdjustColumnSizing(settings);

          return; // adjust column sizing will call this function again
        } else {
          settings.scrollBarVis = scrollBarVis;
        }
        /*
         * 1. Re-create the table inside the scrolling div
         */
        // Remove the old minimised thead and tfoot elements in the inner table


        table.children('thead, tfoot').remove();

        if (footer) {
          footerCopy = footer.clone().prependTo(table);
          footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized

          footerSrcEls = footerCopy.find('tr');
        } // Clone the current header and footer elements and then place it into the inner table


        headerCopy = header.clone().prependTo(table);
        headerTrgEls = header.find('tr'); // original header is in its own table

        headerSrcEls = headerCopy.find('tr');
        headerCopy.find('th, td').removeAttr('tabindex');
        /*
         * 2. Take live measurements from the DOM - do not alter the DOM itself!
         */
        // Remove old sizing and apply the calculated column widths
        // Get the unique column headers in the newly created (cloned) header. We want to apply the
        // calculated sizes to this header

        if (!scrollX) {
          divBodyStyle.width = '100%';
          divHeader[0].style.width = '100%';
        }

        $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
          idx = _fnVisibleToColumnIndex(settings, i);
          el.style.width = settings.aoColumns[idx].sWidth;
        });

        if (footer) {
          _fnApplyToChildren(function (n) {
            n.style.width = "";
          }, footerSrcEls);
        } // Size the table as a whole


        sanityWidth = table.outerWidth();

        if (scrollX === "") {
          // No x scrolling
          tableStyle.width = "100%"; // IE7 will make the width of the table when 100% include the scrollbar
          // - which is shouldn't. When there is a scrollbar we need to take this
          // into account.

          if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
            tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
          } // Recalculate the sanity width


          sanityWidth = table.outerWidth();
        } else if (scrollXInner !== "") {
          // legacy x scroll inner has been given - use it
          tableStyle.width = _fnStringToCss(scrollXInner); // Recalculate the sanity width

          sanityWidth = table.outerWidth();
        } // Hidden header should have zero height, so remove padding and borders. Then
        // set the width based on the real headers
        // Apply all styles in one pass


        _fnApplyToChildren(zeroOut, headerSrcEls); // Read all widths in next pass


        _fnApplyToChildren(function (nSizer) {
          headerContent.push(nSizer.innerHTML);
          headerWidths.push(_fnStringToCss($(nSizer).css('width')));
        }, headerSrcEls); // Apply all widths in final pass


        _fnApplyToChildren(function (nToSize, i) {
          // Only apply widths to the DataTables detected header cells - this
          // prevents complex headers from having contradictory sizes applied
          if ($.inArray(nToSize, dtHeaderCells) !== -1) {
            nToSize.style.width = headerWidths[i];
          }
        }, headerTrgEls);

        $(headerSrcEls).height(0);
        /* Same again with the footer if we have one */

        if (footer) {
          _fnApplyToChildren(zeroOut, footerSrcEls);

          _fnApplyToChildren(function (nSizer) {
            footerContent.push(nSizer.innerHTML);
            footerWidths.push(_fnStringToCss($(nSizer).css('width')));
          }, footerSrcEls);

          _fnApplyToChildren(function (nToSize, i) {
            nToSize.style.width = footerWidths[i];
          }, footerTrgEls);

          $(footerSrcEls).height(0);
        }
        /*
         * 3. Apply the measurements
         */
        // "Hide" the header and footer that we used for the sizing. We need to keep
        // the content of the cell so that the width applied to the header and body
        // both match, but we want to hide it completely. We want to also fix their
        // width to what they currently are


        _fnApplyToChildren(function (nSizer, i) {
          nSizer.innerHTML = '<div class="dataTables_sizing">' + headerContent[i] + '</div>';
          nSizer.childNodes[0].style.height = "0";
          nSizer.childNodes[0].style.overflow = "hidden";
          nSizer.style.width = headerWidths[i];
        }, headerSrcEls);

        if (footer) {
          _fnApplyToChildren(function (nSizer, i) {
            nSizer.innerHTML = '<div class="dataTables_sizing">' + footerContent[i] + '</div>';
            nSizer.childNodes[0].style.height = "0";
            nSizer.childNodes[0].style.overflow = "hidden";
            nSizer.style.width = footerWidths[i];
          }, footerSrcEls);
        } // Sanity check that the table is of a sensible width. If not then we are going to get
        // misalignment - try to prevent this by not allowing the table to shrink below its min width


        if (table.outerWidth() < sanityWidth) {
          // The min width depends upon if we have a vertical scrollbar visible or not */
          correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll" ? sanityWidth + barWidth : sanityWidth; // IE6/7 are a law unto themselves...

          if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
            tableStyle.width = _fnStringToCss(correction - barWidth);
          } // And give the user a warning that we've stopped the table getting too small


          if (scrollX === "" || scrollXInner !== "") {
            _fnLog(settings, 1, 'Possible column misalignment', 6);
          }
        } else {
          correction = '100%';
        } // Apply to the container elements


        divBodyStyle.width = _fnStringToCss(correction);
        divHeaderStyle.width = _fnStringToCss(correction);

        if (footer) {
          settings.nScrollFoot.style.width = _fnStringToCss(correction);
        }
        /*
         * 4. Clean up
         */


        if (!scrollY) {
          /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
           * the scrollbar height from the visible display, rather than adding it on. We need to
           * set the height in order to sort this. Don't want to do it in any other browsers.
           */
          if (ie67) {
            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
          }
        }
        /* Finally set the width's of the header and footer tables */


        var iOuterWidth = table.outerWidth();
        divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
        divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth); // Figure out if there are scrollbar present - if so then we need a the header and footer to
        // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)

        var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
        var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
        divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

        if (footer) {
          divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
          divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
          divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
        } // Correct DOM ordering for colgroup - comes before the thead


        table.children('colgroup').insertBefore(table.children('thead'));
        /* Adjust the position of the header in case we loose the y-scrollbar */

        divBody.trigger('scroll'); // If sorting or filtering has occurred, jump the scrolling back to the top
        // only if we aren't holding the position

        if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
          divBodyEl.scrollTop = 0;
        }
      }
      /**
       * Apply a given function to the display child nodes of an element array (typically
       * TD children of TR rows
       *  @param {function} fn Method to apply to the objects
       *  @param array {nodes} an1 List of elements to look through for display children
       *  @param array {nodes} an2 Another list (identical structure to the first) - optional
       *  @memberof DataTable#oApi
       */


      function _fnApplyToChildren(fn, an1, an2) {
        var index = 0,
            i = 0,
            iLen = an1.length;
        var nNode1, nNode2;

        while (i < iLen) {
          nNode1 = an1[i].firstChild;
          nNode2 = an2 ? an2[i].firstChild : null;

          while (nNode1) {
            if (nNode1.nodeType === 1) {
              if (an2) {
                fn(nNode1, nNode2, index);
              } else {
                fn(nNode1, index);
              }

              index++;
            }

            nNode1 = nNode1.nextSibling;
            nNode2 = an2 ? nNode2.nextSibling : null;
          }

          i++;
        }
      }

      var __re_html_remove = /<.*?>/g;
      /**
       * Calculate the width of columns for the table
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */

      function _fnCalculateColumnWidths(oSettings) {
        var table = oSettings.nTable,
            columns = oSettings.aoColumns,
            scroll = oSettings.oScroll,
            scrollY = scroll.sY,
            scrollX = scroll.sX,
            scrollXInner = scroll.sXInner,
            columnCount = columns.length,
            visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
            headerCells = $('th', oSettings.nTHead),
            tableWidthAttr = table.getAttribute('width'),
            // from DOM element
        tableContainer = table.parentNode,
            userInputs = false,
            i,
            column,
            columnIdx,
            width,
            outerWidth,
            browser = oSettings.oBrowser,
            ie67 = browser.bScrollOversize;

        var styleWidth = table.style.width;

        if (styleWidth && styleWidth.indexOf('%') !== -1) {
          tableWidthAttr = styleWidth;
        }
        /* Convert any user input sizes into pixel sizes */


        for (i = 0; i < visibleColumns.length; i++) {
          column = columns[visibleColumns[i]];

          if (column.sWidth !== null) {
            column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
            userInputs = true;
          }
        }
        /* If the number of columns in the DOM equals the number that we have to
         * process in DataTables, then we can use the offsets that are created by
         * the web- browser. No custom sizes can be set in order for this to happen,
         * nor scrolling used
         */


        if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
          for (i = 0; i < columnCount; i++) {
            var colIdx = _fnVisibleToColumnIndex(oSettings, i);

            if (colIdx !== null) {
              columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
            }
          }
        } else {
          // Otherwise construct a single row, worst case, table with the widest
          // node in the data, assign any user defined widths, then insert it into
          // the DOM and allow the browser to do all the hard work of calculating
          // table widths
          var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
          .css('visibility', 'hidden').removeAttr('id'); // Clean up the table body

          tmpTable.find('tbody tr').remove();
          var tr = $('<tr/>').appendTo(tmpTable.find('tbody')); // Clone the table header and footer - we can't use the header / footer
          // from the cloned table, since if scrolling is active, the table's
          // real header and footer are contained in different table tags

          tmpTable.find('thead, tfoot').remove();
          tmpTable.append($(oSettings.nTHead).clone()).append($(oSettings.nTFoot).clone()); // Remove any assigned widths from the footer (from scrolling)

          tmpTable.find('tfoot th, tfoot td').css('width', ''); // Apply custom sizing to the cloned header

          headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

          for (i = 0; i < visibleColumns.length; i++) {
            column = columns[visibleColumns[i]];
            headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''; // For scrollX we need to force the column width otherwise the
            // browser will collapse it. If this width is smaller than the
            // width the column requires, then it will have no effect

            if (column.sWidthOrig && scrollX) {
              $(headerCells[i]).append($('<div/>').css({
                width: column.sWidthOrig,
                margin: 0,
                padding: 0,
                border: 0,
                height: 1
              }));
            }
          } // Find the widest cell for each column and put it into the table


          if (oSettings.aoData.length) {
            for (i = 0; i < visibleColumns.length; i++) {
              columnIdx = visibleColumns[i];
              column = columns[columnIdx];
              $(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
            }
          } // Tidy the temporary table - remove name attributes so there aren't
          // duplicated in the dom (radio elements for example)


          $('[name]', tmpTable).removeAttr('name'); // Table has been built, attach to the document so we can work with it.
          // A holding element is used, positioned at the top of the container
          // with minimal height, so it has no effect on if the container scrolls
          // or not. Otherwise it might trigger scrolling when it actually isn't
          // needed

          var holder = $('<div/>').css(scrollX || scrollY ? {
            position: 'absolute',
            top: 0,
            left: 0,
            height: 1,
            right: 0,
            overflow: 'hidden'
          } : {}).append(tmpTable).appendTo(tableContainer); // When scrolling (X or Y) we want to set the width of the table as 
          // appropriate. However, when not scrolling leave the table width as it
          // is. This results in slightly different, but I think correct behaviour

          if (scrollX && scrollXInner) {
            tmpTable.width(scrollXInner);
          } else if (scrollX) {
            tmpTable.css('width', 'auto');
            tmpTable.removeAttr('width'); // If there is no width attribute or style, then allow the table to
            // collapse

            if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
              tmpTable.width(tableContainer.clientWidth);
            }
          } else if (scrollY) {
            tmpTable.width(tableContainer.clientWidth);
          } else if (tableWidthAttr) {
            tmpTable.width(tableWidthAttr);
          } // Get the width of each column in the constructed table - we need to
          // know the inner width (so it can be assigned to the other table's
          // cells) and the outer width so we can calculate the full width of the
          // table. This is safe since DataTables requires a unique cell for each
          // column, but if ever a header can span multiple columns, this will
          // need to be modified.


          var total = 0;

          for (i = 0; i < visibleColumns.length; i++) {
            var cell = $(headerCells[i]);
            var border = cell.outerWidth() - cell.width(); // Use getBounding... where possible (not IE8-) because it can give
            // sub-pixel accuracy, which we then want to round up!

            var bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth(); // Total is tracked to remove any sub-pixel errors as the outerWidth
            // of the table might not equal the total given here (IE!).

            total += bounding; // Width for each column to use

            columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
          }

          table.style.width = _fnStringToCss(total); // Finished with the table - ditch it

          holder.remove();
        } // If there is a width attr, we want to attach an event listener which
        // allows the table sizing to automatically adjust when the window is
        // resized. Use the width attr rather than CSS, since we can't know if the
        // CSS is a relative value or absolute - DOM read is always px.


        if (tableWidthAttr) {
          table.style.width = _fnStringToCss(tableWidthAttr);
        }

        if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
          var bindResize = function bindResize() {
            $(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
              _fnAdjustColumnSizing(oSettings);
            }));
          }; // IE6/7 will crash if we bind a resize event handler on page load.
          // To be removed in 1.11 which drops IE6/7 support


          if (ie67) {
            setTimeout(bindResize, 1000);
          } else {
            bindResize();
          }

          oSettings._reszEvt = true;
        }
      }
      /**
       * Throttle the calls to a function. Arguments and context are maintained for
       * the throttled function
       *  @param {function} fn Function to be called
       *  @param {int} [freq=200] call frequency in mS
       *  @returns {function} wrapped function
       *  @memberof DataTable#oApi
       */


      var _fnThrottle = DataTable.util.throttle;
      /**
       * Convert a CSS unit width to pixels (e.g. 2em)
       *  @param {string} width width to be converted
       *  @param {node} parent parent to get the with for (required for relative widths) - optional
       *  @returns {int} width in pixels
       *  @memberof DataTable#oApi
       */

      function _fnConvertToWidth(width, parent) {
        if (!width) {
          return 0;
        }

        var n = $('<div/>').css('width', _fnStringToCss(width)).appendTo(parent || document.body);
        var val = n[0].offsetWidth;
        n.remove();
        return val;
      }
      /**
       * Get the widest node
       *  @param {object} settings dataTables settings object
       *  @param {int} colIdx column of interest
       *  @returns {node} widest table node
       *  @memberof DataTable#oApi
       */


      function _fnGetWidestNode(settings, colIdx) {
        var idx = _fnGetMaxLenString(settings, colIdx);

        if (idx < 0) {
          return null;
        }

        var data = settings.aoData[idx];
        return !data.nTr ? // Might not have been created when deferred rendering
        $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] : data.anCells[colIdx];
      }
      /**
       * Get the maximum strlen for each data column
       *  @param {object} settings dataTables settings object
       *  @param {int} colIdx column of interest
       *  @returns {string} max string length for each column
       *  @memberof DataTable#oApi
       */


      function _fnGetMaxLenString(settings, colIdx) {
        var s,
            max = -1,
            maxIdx = -1;

        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
          s = _fnGetCellData(settings, i, colIdx, 'display') + '';
          s = s.replace(__re_html_remove, '');
          s = s.replace(/&nbsp;/g, ' ');

          if (s.length > max) {
            max = s.length;
            maxIdx = i;
          }
        }

        return maxIdx;
      }
      /**
       * Append a CSS unit (only if required) to a string
       *  @param {string} value to css-ify
       *  @returns {string} value with css unit
       *  @memberof DataTable#oApi
       */


      function _fnStringToCss(s) {
        if (s === null) {
          return '0px';
        }

        if (typeof s == 'number') {
          return s < 0 ? '0px' : s + 'px';
        } // Check it has a unit character already


        return s.match(/\d$/) ? s + 'px' : s;
      }

      function _fnSortFlatten(settings) {
        var i,
            iLen,
            k,
            kLen,
            aSort = [],
            aiOrig = [],
            aoColumns = settings.aoColumns,
            aDataSort,
            iCol,
            sType,
            srcCol,
            fixed = settings.aaSortingFixed,
            fixedObj = $.isPlainObject(fixed),
            nestedSort = [],
            add = function add(a) {
          if (a.length && !Array.isArray(a[0])) {
            // 1D array
            nestedSort.push(a);
          } else {
            // 2D array
            $.merge(nestedSort, a);
          }
        }; // Build the sort array, with pre-fix and post-fix options if they have been
        // specified


        if (Array.isArray(fixed)) {
          add(fixed);
        }

        if (fixedObj && fixed.pre) {
          add(fixed.pre);
        }

        add(settings.aaSorting);

        if (fixedObj && fixed.post) {
          add(fixed.post);
        }

        for (i = 0; i < nestedSort.length; i++) {
          srcCol = nestedSort[i][0];
          aDataSort = aoColumns[srcCol].aDataSort;

          for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
            iCol = aDataSort[k];
            sType = aoColumns[iCol].sType || 'string';

            if (nestedSort[i]._idx === undefined) {
              nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
            }

            aSort.push({
              src: srcCol,
              col: iCol,
              dir: nestedSort[i][1],
              index: nestedSort[i]._idx,
              type: sType,
              formatter: DataTable.ext.type.order[sType + "-pre"]
            });
          }
        }

        return aSort;
      }
      /**
       * Change the order of the table
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       *  @todo This really needs split up!
       */


      function _fnSort(oSettings) {
        var i,
            ien,
            iLen,
            j,
            jLen,
            k,
            kLen,
            sDataType,
            nTh,
            aiOrig = [],
            oExtSort = DataTable.ext.type.order,
            aoData = oSettings.aoData,
            aoColumns = oSettings.aoColumns,
            aDataSort,
            data,
            iCol,
            sType,
            oSort,
            formatters = 0,
            sortCol,
            displayMaster = oSettings.aiDisplayMaster,
            aSort; // Resolve any column types that are unknown due to addition or invalidation
        // @todo Can this be moved into a 'data-ready' handler which is called when
        //   data is going to be used in the table?

        _fnColumnTypes(oSettings);

        aSort = _fnSortFlatten(oSettings);

        for (i = 0, ien = aSort.length; i < ien; i++) {
          sortCol = aSort[i]; // Track if we can use the fast sort algorithm

          if (sortCol.formatter) {
            formatters++;
          } // Load the data needed for the sort, for each cell


          _fnSortData(oSettings, sortCol.col);
        }
        /* No sorting required if server-side or no sorting array */


        if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
          // Create a value - key array of the current row positions such that we can use their
          // current position during the sort, if values match, in order to perform stable sorting
          for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
            aiOrig[displayMaster[i]] = i;
          }
          /* Do the sort - here we want multi-column sorting based on a given data source (column)
           * and sorting function (from oSort) in a certain direction. It's reasonably complex to
           * follow on it's own, but this is what we want (example two column sorting):
           *  fnLocalSorting = function(a,b){
           *    var iTest;
           *    iTest = oSort['string-asc']('data11', 'data12');
           *      if (iTest !== 0)
           *        return iTest;
           *    iTest = oSort['numeric-desc']('data21', 'data22');
           *    if (iTest !== 0)
           *      return iTest;
           *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
           *  }
           * Basically we have a test for each sorting column, if the data in that column is equal,
           * test the next column. If all columns match, then we use a numeric sort on the row
           * positions in the original data array to provide a stable sort.
           *
           * Note - I know it seems excessive to have two sorting methods, but the first is around
           * 15% faster, so the second is only maintained for backwards compatibility with sorting
           * methods which do not have a pre-sort formatting function.
           */


          if (formatters === aSort.length) {
            // All sort types have formatting functions
            displayMaster.sort(function (a, b) {
              var x,
                  y,
                  k,
                  test,
                  sort,
                  len = aSort.length,
                  dataA = aoData[a]._aSortData,
                  dataB = aoData[b]._aSortData;

              for (k = 0; k < len; k++) {
                sort = aSort[k];
                x = dataA[sort.col];
                y = dataB[sort.col];
                test = x < y ? -1 : x > y ? 1 : 0;

                if (test !== 0) {
                  return sort.dir === 'asc' ? test : -test;
                }
              }

              x = aiOrig[a];
              y = aiOrig[b];
              return x < y ? -1 : x > y ? 1 : 0;
            });
          } else {
            // Depreciated - remove in 1.11 (providing a plug-in option)
            // Not all sort types have formatting methods, so we have to call their sorting
            // methods.
            displayMaster.sort(function (a, b) {
              var x,
                  y,
                  k,
                  l,
                  test,
                  sort,
                  fn,
                  len = aSort.length,
                  dataA = aoData[a]._aSortData,
                  dataB = aoData[b]._aSortData;

              for (k = 0; k < len; k++) {
                sort = aSort[k];
                x = dataA[sort.col];
                y = dataB[sort.col];
                fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
                test = fn(x, y);

                if (test !== 0) {
                  return test;
                }
              }

              x = aiOrig[a];
              y = aiOrig[b];
              return x < y ? -1 : x > y ? 1 : 0;
            });
          }
        }
        /* Tell the draw function that we have sorted the data */


        oSettings.bSorted = true;
      }

      function _fnSortAria(settings) {
        var label;
        var nextSort;
        var columns = settings.aoColumns;

        var aSort = _fnSortFlatten(settings);

        var oAria = settings.oLanguage.oAria; // ARIA attributes - need to loop all columns, to update all (removing old
        // attributes as needed)

        for (var i = 0, iLen = columns.length; i < iLen; i++) {
          var col = columns[i];
          var asSorting = col.asSorting;
          var sTitle = col.sTitle.replace(/<.*?>/g, "");
          var th = col.nTh; // IE7 is throwing an error when setting these properties with jQuery's
          // attr() and removeAttr() methods...

          th.removeAttribute('aria-sort');
          /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */

          if (col.bSortable) {
            if (aSort.length > 0 && aSort[0].col == i) {
              th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
              nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
            } else {
              nextSort = asSorting[0];
            }

            label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
          } else {
            label = sTitle;
          }

          th.setAttribute('aria-label', label);
        }
      }
      /**
       * Function to run on user sort request
       *  @param {object} settings dataTables settings object
       *  @param {node} attachTo node to attach the handler to
       *  @param {int} colIdx column sorting index
       *  @param {boolean} [append=false] Append the requested sort to the existing
       *    sort if true (i.e. multi-column sort)
       *  @param {function} [callback] callback function
       *  @memberof DataTable#oApi
       */


      function _fnSortListener(settings, colIdx, append, callback) {
        var col = settings.aoColumns[colIdx];
        var sorting = settings.aaSorting;
        var asSorting = col.asSorting;
        var nextSortIdx;

        var next = function next(a, overflow) {
          var idx = a._idx;

          if (idx === undefined) {
            idx = $.inArray(a[1], asSorting);
          }

          return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
        }; // Convert to 2D array if needed


        if (typeof sorting[0] === 'number') {
          sorting = settings.aaSorting = [sorting];
        } // If appending the sort then we are multi-column sorting


        if (append && settings.oFeatures.bSortMulti) {
          // Are we already doing some kind of sort on this column?
          var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

          if (sortIdx !== -1) {
            // Yes, modify the sort
            nextSortIdx = next(sorting[sortIdx], true);

            if (nextSortIdx === null && sorting.length === 1) {
              nextSortIdx = 0; // can't remove sorting completely
            }

            if (nextSortIdx === null) {
              sorting.splice(sortIdx, 1);
            } else {
              sorting[sortIdx][1] = asSorting[nextSortIdx];
              sorting[sortIdx]._idx = nextSortIdx;
            }
          } else {
            // No sort on this column yet
            sorting.push([colIdx, asSorting[0], 0]);
            sorting[sorting.length - 1]._idx = 0;
          }
        } else if (sorting.length && sorting[0][0] == colIdx) {
          // Single column - already sorting on this column, modify the sort
          nextSortIdx = next(sorting[0]);
          sorting.length = 1;
          sorting[0][1] = asSorting[nextSortIdx];
          sorting[0]._idx = nextSortIdx;
        } else {
          // Single column - sort only on this column
          sorting.length = 0;
          sorting.push([colIdx, asSorting[0]]);
          sorting[0]._idx = 0;
        } // Run the sort by calling a full redraw


        _fnReDraw(settings); // callback used for async user interaction


        if (typeof callback == 'function') {
          callback(settings);
        }
      }
      /**
       * Attach a sort handler (click) to a node
       *  @param {object} settings dataTables settings object
       *  @param {node} attachTo node to attach the handler to
       *  @param {int} colIdx column sorting index
       *  @param {function} [callback] callback function
       *  @memberof DataTable#oApi
       */


      function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
        var col = settings.aoColumns[colIdx];

        _fnBindAction(attachTo, {}, function (e) {
          /* If the column is not sortable - don't to anything */
          if (col.bSortable === false) {
            return;
          } // If processing is enabled use a timeout to allow the processing
          // display to be shown - otherwise to it synchronously


          if (settings.oFeatures.bProcessing) {
            _fnProcessingDisplay(settings, true);

            setTimeout(function () {
              _fnSortListener(settings, colIdx, e.shiftKey, callback); // In server-side processing, the draw callback will remove the
              // processing display


              if (_fnDataSource(settings) !== 'ssp') {
                _fnProcessingDisplay(settings, false);
              }
            }, 0);
          } else {
            _fnSortListener(settings, colIdx, e.shiftKey, callback);
          }
        });
      }
      /**
       * Set the sorting classes on table's body, Note: it is safe to call this function
       * when bSort and bSortClasses are false
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnSortingClasses(settings) {
        var oldSort = settings.aLastSort;
        var sortClass = settings.oClasses.sSortColumn;

        var sort = _fnSortFlatten(settings);

        var features = settings.oFeatures;
        var i, ien, colIdx;

        if (features.bSort && features.bSortClasses) {
          // Remove old sorting classes
          for (i = 0, ien = oldSort.length; i < ien; i++) {
            colIdx = oldSort[i].src; // Remove column sorting

            $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
          } // Add new column sorting


          for (i = 0, ien = sort.length; i < ien; i++) {
            colIdx = sort[i].src;
            $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
          }
        }

        settings.aLastSort = sort;
      } // Get the data to sort a column, be it from cache, fresh (populating the
      // cache), or from a sort formatter


      function _fnSortData(settings, idx) {
        // Custom sorting function - provided by the sort data type
        var column = settings.aoColumns[idx];
        var customSort = DataTable.ext.order[column.sSortDataType];
        var customData;

        if (customSort) {
          customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
        } // Use / populate cache


        var row, cellData;
        var formatter = DataTable.ext.type.order[column.sType + "-pre"];

        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
          row = settings.aoData[i];

          if (!row._aSortData) {
            row._aSortData = [];
          }

          if (!row._aSortData[idx] || customSort) {
            cellData = customSort ? customData[i] : // If there was a custom sort function, use data from there
            _fnGetCellData(settings, i, idx, 'sort');
            row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
          }
        }
      }
      /**
       * Save the state of a table
       *  @param {object} oSettings dataTables settings object
       *  @memberof DataTable#oApi
       */


      function _fnSaveState(settings) {
        if (!settings.oFeatures.bStateSave || settings.bDestroying) {
          return;
        }
        /* Store the interesting variables */


        var state = {
          time: +new Date(),
          start: settings._iDisplayStart,
          length: settings._iDisplayLength,
          order: $.extend(true, [], settings.aaSorting),
          search: _fnSearchToCamel(settings.oPreviousSearch),
          columns: $.map(settings.aoColumns, function (col, i) {
            return {
              visible: col.bVisible,
              search: _fnSearchToCamel(settings.aoPreSearchCols[i])
            };
          })
        };

        _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

        settings.oSavedState = state;
        settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
      }
      /**
       * Attempt to load a saved table state
       *  @param {object} oSettings dataTables settings object
       *  @param {object} oInit DataTables init object so we can override settings
       *  @param {function} callback Callback to execute when the state has been loaded
       *  @memberof DataTable#oApi
       */


      function _fnLoadState(settings, oInit, callback) {
        var i, ien;
        var columns = settings.aoColumns;

        var loaded = function loaded(s) {
          if (!s || !s.time) {
            callback();
            return;
          } // Allow custom and plug-in manipulation functions to alter the saved data set and
          // cancelling of loading by returning false


          var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);

          if ($.inArray(false, abStateLoad) !== -1) {
            callback();
            return;
          } // Reject old data


          var duration = settings.iStateDuration;

          if (duration > 0 && s.time < +new Date() - duration * 1000) {
            callback();
            return;
          } // Number of columns have changed - all bets are off, no restore of settings


          if (s.columns && columns.length !== s.columns.length) {
            callback();
            return;
          } // Store the saved state so it might be accessed at any time


          settings.oLoadedState = $.extend(true, {}, s); // Restore key features - todo - for 1.11 this needs to be done by
          // subscribed events

          if (s.start !== undefined) {
            settings._iDisplayStart = s.start;
            settings.iInitDisplayStart = s.start;
          }

          if (s.length !== undefined) {
            settings._iDisplayLength = s.length;
          } // Order


          if (s.order !== undefined) {
            settings.aaSorting = [];
            $.each(s.order, function (i, col) {
              settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col);
            });
          } // Search


          if (s.search !== undefined) {
            $.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
          } // Columns
          //


          if (s.columns) {
            for (i = 0, ien = s.columns.length; i < ien; i++) {
              var col = s.columns[i]; // Visibility

              if (col.visible !== undefined) {
                columns[i].bVisible = col.visible;
              } // Search


              if (col.search !== undefined) {
                $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
              }
            }
          }

          _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);

          callback();
        };

        if (!settings.oFeatures.bStateSave) {
          callback();
          return;
        }

        var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);

        if (state !== undefined) {
          loaded(state);
        } // otherwise, wait for the loaded callback to be executed

      }
      /**
       * Return the settings object for a particular table
       *  @param {node} table table we are using as a dataTable
       *  @returns {object} Settings object - or null if not found
       *  @memberof DataTable#oApi
       */


      function _fnSettingsFromNode(table) {
        var settings = DataTable.settings;
        var idx = $.inArray(table, _pluck(settings, 'nTable'));
        return idx !== -1 ? settings[idx] : null;
      }
      /**
       * Log an error message
       *  @param {object} settings dataTables settings object
       *  @param {int} level log error messages, or display them to the user
       *  @param {string} msg error message
       *  @param {int} tn Technical note id to get more information about the error.
       *  @memberof DataTable#oApi
       */


      function _fnLog(settings, level, msg, tn) {
        msg = 'DataTables warning: ' + (settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

        if (tn) {
          msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn;
        }

        if (!level) {
          // Backwards compatibility pre 1.10
          var ext = DataTable.ext;
          var type = ext.sErrMode || ext.errMode;

          if (settings) {
            _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);
          }

          if (type == 'alert') {
            alert(msg);
          } else if (type == 'throw') {
            throw new Error(msg);
          } else if (typeof type == 'function') {
            type(settings, tn, msg);
          }
        } else if (window.console && console.log) {
          console.log(msg);
        }
      }
      /**
       * See if a property is defined on one object, if so assign it to the other object
       *  @param {object} ret target object
       *  @param {object} src source object
       *  @param {string} name property
       *  @param {string} [mappedName] name to map too - optional, name used if not given
       *  @memberof DataTable#oApi
       */


      function _fnMap(ret, src, name, mappedName) {
        if (Array.isArray(name)) {
          $.each(name, function (i, val) {
            if (Array.isArray(val)) {
              _fnMap(ret, src, val[0], val[1]);
            } else {
              _fnMap(ret, src, val);
            }
          });
          return;
        }

        if (mappedName === undefined) {
          mappedName = name;
        }

        if (src[name] !== undefined) {
          ret[mappedName] = src[name];
        }
      }
      /**
       * Extend objects - very similar to jQuery.extend, but deep copy objects, and
       * shallow copy arrays. The reason we need to do this, is that we don't want to
       * deep copy array init values (such as aaSorting) since the dev wouldn't be
       * able to override them, but we do want to deep copy arrays.
       *  @param {object} out Object to extend
       *  @param {object} extender Object from which the properties will be applied to
       *      out
       *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
       *      independent copy with the exception of the `data` or `aaData` parameters
       *      if they are present. This is so you can pass in a collection to
       *      DataTables and have that used as your data source without breaking the
       *      references
       *  @returns {object} out Reference, just for convenience - out === the return.
       *  @memberof DataTable#oApi
       *  @todo This doesn't take account of arrays inside the deep copied objects.
       */


      function _fnExtend(out, extender, breakRefs) {
        var val;

        for (var prop in extender) {
          if (extender.hasOwnProperty(prop)) {
            val = extender[prop];

            if ($.isPlainObject(val)) {
              if (!$.isPlainObject(out[prop])) {
                out[prop] = {};
              }

              $.extend(true, out[prop], val);
            } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val)) {
              out[prop] = val.slice();
            } else {
              out[prop] = val;
            }
          }
        }

        return out;
      }
      /**
       * Bind an event handers to allow a click or return key to activate the callback.
       * This is good for accessibility since a return on the keyboard will have the
       * same effect as a click, if the element has focus.
       *  @param {element} n Element to bind the action to
       *  @param {object} oData Data object to pass to the triggered function
       *  @param {function} fn Callback function for when the event is triggered
       *  @memberof DataTable#oApi
       */


      function _fnBindAction(n, oData, fn) {
        $(n).on('click.DT', oData, function (e) {
          $(n).trigger('blur'); // Remove focus outline for mouse users

          fn(e);
        }).on('keypress.DT', oData, function (e) {
          if (e.which === 13) {
            e.preventDefault();
            fn(e);
          }
        }).on('selectstart.DT', function () {
          /* Take the brutal approach to cancelling text selection */
          return false;
        });
      }
      /**
       * Register a callback function. Easily allows a callback function to be added to
       * an array store of callback functions that can then all be called together.
       *  @param {object} oSettings dataTables settings object
       *  @param {string} sStore Name of the array storage for the callbacks in oSettings
       *  @param {function} fn Function to be called back
       *  @param {string} sName Identifying name for the callback (i.e. a label)
       *  @memberof DataTable#oApi
       */


      function _fnCallbackReg(oSettings, sStore, fn, sName) {
        if (fn) {
          oSettings[sStore].push({
            "fn": fn,
            "sName": sName
          });
        }
      }
      /**
       * Fire callback functions and trigger events. Note that the loop over the
       * callback array store is done backwards! Further note that you do not want to
       * fire off triggers in time sensitive applications (for example cell creation)
       * as its slow.
       *  @param {object} settings dataTables settings object
       *  @param {string} callbackArr Name of the array storage for the callbacks in
       *      oSettings
       *  @param {string} eventName Name of the jQuery custom event to trigger. If
       *      null no trigger is fired
       *  @param {array} args Array of arguments to pass to the callback function /
       *      trigger
       *  @memberof DataTable#oApi
       */


      function _fnCallbackFire(settings, callbackArr, eventName, args) {
        var ret = [];

        if (callbackArr) {
          ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
            return val.fn.apply(settings.oInstance, args);
          });
        }

        if (eventName !== null) {
          var e = $.Event(eventName + '.dt');
          $(settings.nTable).trigger(e, args);
          ret.push(e.result);
        }

        return ret;
      }

      function _fnLengthOverflow(settings) {
        var start = settings._iDisplayStart,
            end = settings.fnDisplayEnd(),
            len = settings._iDisplayLength;
        /* If we have space to show extra rows (backing up from the end point - then do so */

        if (start >= end) {
          start = end - len;
        } // Keep the start record on the current page


        start -= start % len;

        if (len === -1 || start < 0) {
          start = 0;
        }

        settings._iDisplayStart = start;
      }

      function _fnRenderer(settings, type) {
        var renderer = settings.renderer;
        var host = DataTable.ext.renderer[type];

        if ($.isPlainObject(renderer) && renderer[type]) {
          // Specific renderer for this type. If available use it, otherwise use
          // the default.
          return host[renderer[type]] || host._;
        } else if (typeof renderer === 'string') {
          // Common renderer - if there is one available for this type use it,
          // otherwise use the default
          return host[renderer] || host._;
        } // Use the default


        return host._;
      }
      /**
       * Detect the data source being used for the table. Used to simplify the code
       * a little (ajax) and to make it compress a little smaller.
       *
       *  @param {object} settings dataTables settings object
       *  @returns {string} Data source
       *  @memberof DataTable#oApi
       */


      function _fnDataSource(settings) {
        if (settings.oFeatures.bServerSide) {
          return 'ssp';
        } else if (settings.ajax || settings.sAjaxSource) {
          return 'ajax';
        }

        return 'dom';
      }
      /**
       * Computed structure of the DataTables API, defined by the options passed to
       * `DataTable.Api.register()` when building the API.
       *
       * The structure is built in order to speed creation and extension of the Api
       * objects since the extensions are effectively pre-parsed.
       *
       * The array is an array of objects with the following structure, where this
       * base array represents the Api prototype base:
       *
       *     [
       *       {
       *         name:      'data'                -- string   - Property name
       *         val:       function () {},       -- function - Api method (or undefined if just an object
       *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
       *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
       *       },
       *       {
       *         name:     'row'
       *         val:       {},
       *         methodExt: [ ... ],
       *         propExt:   [
       *           {
       *             name:      'data'
       *             val:       function () {},
       *             methodExt: [ ... ],
       *             propExt:   [ ... ]
       *           },
       *           ...
       *         ]
       *       }
       *     ]
       *
       * @type {Array}
       * @ignore
       */


      var __apiStruct = [];
      /**
       * `Array.prototype` reference.
       *
       * @type object
       * @ignore
       */

      var __arrayProto = Array.prototype;
      /**
       * Abstraction for `context` parameter of the `Api` constructor to allow it to
       * take several different forms for ease of use.
       *
       * Each of the input parameter types will be converted to a DataTables settings
       * object where possible.
       *
       * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
       *   of:
       *
       *   * `string` - jQuery selector. Any DataTables' matching the given selector
       *     with be found and used.
       *   * `node` - `TABLE` node which has already been formed into a DataTable.
       *   * `jQuery` - A jQuery object of `TABLE` nodes.
       *   * `object` - DataTables settings object
       *   * `DataTables.Api` - API instance
       * @return {array|null} Matching DataTables settings objects. `null` or
       *   `undefined` is returned if no matching DataTable is found.
       * @ignore
       */

      var _toSettings = function _toSettings(mixed) {
        var idx, jq;
        var settings = DataTable.settings;
        var tables = $.map(settings, function (el, i) {
          return el.nTable;
        });

        if (!mixed) {
          return [];
        } else if (mixed.nTable && mixed.oApi) {
          // DataTables settings object
          return [mixed];
        } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
          // Table node
          idx = $.inArray(mixed, tables);
          return idx !== -1 ? [settings[idx]] : null;
        } else if (mixed && typeof mixed.settings === 'function') {
          return mixed.settings().toArray();
        } else if (typeof mixed === 'string') {
          // jQuery selector
          jq = $(mixed);
        } else if (mixed instanceof $) {
          // jQuery object (also DataTables instance)
          jq = mixed;
        }

        if (jq) {
          return jq.map(function (i) {
            idx = $.inArray(this, tables);
            return idx !== -1 ? settings[idx] : null;
          }).toArray();
        }
      };
      /**
       * DataTables API class - used to control and interface with  one or more
       * DataTables enhanced tables.
       *
       * The API class is heavily based on jQuery, presenting a chainable interface
       * that you can use to interact with tables. Each instance of the API class has
       * a "context" - i.e. the tables that it will operate on. This could be a single
       * table, all tables on a page or a sub-set thereof.
       *
       * Additionally the API is designed to allow you to easily work with the data in
       * the tables, retrieving and manipulating it as required. This is done by
       * presenting the API class as an array like interface. The contents of the
       * array depend upon the actions requested by each method (for example
       * `rows().nodes()` will return an array of nodes, while `rows().data()` will
       * return an array of objects or arrays depending upon your table's
       * configuration). The API object has a number of array like methods (`push`,
       * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
       * `unique` etc) to assist your working with the data held in a table.
       *
       * Most methods (those which return an Api instance) are chainable, which means
       * the return from a method call also has all of the methods available that the
       * top level object had. For example, these two calls are equivalent:
       *
       *     // Not chained
       *     api.row.add( {...} );
       *     api.draw();
       *
       *     // Chained
       *     api.row.add( {...} ).draw();
       *
       * @class DataTable.Api
       * @param {array|object|string|jQuery} context DataTable identifier. This is
       *   used to define which DataTables enhanced tables this API will operate on.
       *   Can be one of:
       *
       *   * `string` - jQuery selector. Any DataTables' matching the given selector
       *     with be found and used.
       *   * `node` - `TABLE` node which has already been formed into a DataTable.
       *   * `jQuery` - A jQuery object of `TABLE` nodes.
       *   * `object` - DataTables settings object
       * @param {array} [data] Data to initialise the Api instance with.
       *
       * @example
       *   // Direct initialisation during DataTables construction
       *   var api = $('#example').DataTable();
       *
       * @example
       *   // Initialisation using a DataTables jQuery object
       *   var api = $('#example').dataTable().api();
       *
       * @example
       *   // Initialisation as a constructor
       *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
       */


      _Api2 = function _Api(context, data) {
        if (!(this instanceof _Api2)) {
          return new _Api2(context, data);
        }

        var settings = [];

        var ctxSettings = function ctxSettings(o) {
          var a = _toSettings(o);

          if (a) {
            settings.push.apply(settings, a);
          }
        };

        if (Array.isArray(context)) {
          for (var i = 0, ien = context.length; i < ien; i++) {
            ctxSettings(context[i]);
          }
        } else {
          ctxSettings(context);
        } // Remove duplicates


        this.context = _unique(settings); // Initial data

        if (data) {
          $.merge(this, data);
        } // selector


        this.selector = {
          rows: null,
          cols: null,
          opts: null
        };

        _Api2.extend(this, this, __apiStruct);
      };

      DataTable.Api = _Api2; // Don't destroy the existing prototype, just extend it. Required for jQuery 2's
      // isPlainObject.

      $.extend(_Api2.prototype, {
        any: function any() {
          return this.count() !== 0;
        },
        concat: __arrayProto.concat,
        context: [],
        // array of table settings objects
        count: function count() {
          return this.flatten().length;
        },
        each: function each(fn) {
          for (var i = 0, ien = this.length; i < ien; i++) {
            fn.call(this, this[i], i, this);
          }

          return this;
        },
        eq: function eq(idx) {
          var ctx = this.context;
          return ctx.length > idx ? new _Api2(ctx[idx], this[idx]) : null;
        },
        filter: function filter(fn) {
          var a = [];

          if (__arrayProto.filter) {
            a = __arrayProto.filter.call(this, fn, this);
          } else {
            // Compatibility for browsers without EMCA-252-5 (JS 1.6)
            for (var i = 0, ien = this.length; i < ien; i++) {
              if (fn.call(this, this[i], i, this)) {
                a.push(this[i]);
              }
            }
          }

          return new _Api2(this.context, a);
        },
        flatten: function flatten() {
          var a = [];
          return new _Api2(this.context, a.concat.apply(a, this.toArray()));
        },
        join: __arrayProto.join,
        indexOf: __arrayProto.indexOf || function (obj, start) {
          for (var i = start || 0, ien = this.length; i < ien; i++) {
            if (this[i] === obj) {
              return i;
            }
          }

          return -1;
        },
        iterator: function iterator(flatten, type, fn, alwaysNew) {
          var a = [],
              ret,
              i,
              ien,
              j,
              jen,
              context = this.context,
              rows,
              items,
              item,
              selector = this.selector; // Argument shifting

          if (typeof flatten === 'string') {
            alwaysNew = fn;
            fn = type;
            type = flatten;
            flatten = false;
          }

          for (i = 0, ien = context.length; i < ien; i++) {
            var apiInst = new _Api2(context[i]);

            if (type === 'table') {
              ret = fn.call(apiInst, context[i], i);

              if (ret !== undefined) {
                a.push(ret);
              }
            } else if (type === 'columns' || type === 'rows') {
              // this has same length as context - one entry for each table
              ret = fn.call(apiInst, context[i], this[i], i);

              if (ret !== undefined) {
                a.push(ret);
              }
            } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
              // columns and rows share the same structure.
              // 'this' is an array of column indexes for each context
              items = this[i];

              if (type === 'column-rows') {
                rows = _selector_row_indexes(context[i], selector.opts);
              }

              for (j = 0, jen = items.length; j < jen; j++) {
                item = items[j];

                if (type === 'cell') {
                  ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
                } else {
                  ret = fn.call(apiInst, context[i], item, i, j, rows);
                }

                if (ret !== undefined) {
                  a.push(ret);
                }
              }
            }
          }

          if (a.length || alwaysNew) {
            var api = new _Api2(context, flatten ? a.concat.apply([], a) : a);
            var apiSelector = api.selector;
            apiSelector.rows = selector.rows;
            apiSelector.cols = selector.cols;
            apiSelector.opts = selector.opts;
            return api;
          }

          return this;
        },
        lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
          // Bit cheeky...
          return this.indexOf.apply(this.toArray.reverse(), arguments);
        },
        length: 0,
        map: function map(fn) {
          var a = [];

          if (__arrayProto.map) {
            a = __arrayProto.map.call(this, fn, this);
          } else {
            // Compatibility for browsers without EMCA-252-5 (JS 1.6)
            for (var i = 0, ien = this.length; i < ien; i++) {
              a.push(fn.call(this, this[i], i));
            }
          }

          return new _Api2(this.context, a);
        },
        pluck: function pluck(prop) {
          return this.map(function (el) {
            return el[prop];
          });
        },
        pop: __arrayProto.pop,
        push: __arrayProto.push,
        // Does not return an API instance
        reduce: __arrayProto.reduce || function (fn, init) {
          return _fnReduce(this, fn, init, 0, this.length, 1);
        },
        reduceRight: __arrayProto.reduceRight || function (fn, init) {
          return _fnReduce(this, fn, init, this.length - 1, -1, -1);
        },
        reverse: __arrayProto.reverse,
        // Object with rows, columns and opts
        selector: null,
        shift: __arrayProto.shift,
        slice: function slice() {
          return new _Api2(this.context, this);
        },
        sort: __arrayProto.sort,
        // ? name - order?
        splice: __arrayProto.splice,
        toArray: function toArray() {
          return __arrayProto.slice.call(this);
        },
        to$: function to$() {
          return $(this);
        },
        toJQuery: function toJQuery() {
          return $(this);
        },
        unique: function unique() {
          return new _Api2(this.context, _unique(this));
        },
        unshift: __arrayProto.unshift
      });

      _Api2.extend = function (scope, obj, ext) {
        // Only extend API instances and static properties of the API
        if (!ext.length || !obj || !(obj instanceof _Api2) && !obj.__dt_wrapper) {
          return;
        }

        var i,
            ien,
            struct,
            methodScoping = function methodScoping(scope, fn, struc) {
          return function () {
            var ret = fn.apply(scope, arguments); // Method extension

            _Api2.extend(ret, ret, struc.methodExt);

            return ret;
          };
        };

        for (i = 0, ien = ext.length; i < ien; i++) {
          struct = ext[i]; // Value

          obj[struct.name] = struct.type === 'function' ? methodScoping(scope, struct.val, struct) : struct.type === 'object' ? {} : struct.val;
          obj[struct.name].__dt_wrapper = true; // Property extension

          _Api2.extend(scope, obj[struct.name], struct.propExt);
        }
      }; // @todo - Is there need for an augment function?
      // _Api.augment = function ( inst, name )
      // {
      // 	// Find src object in the structure from the name
      // 	var parts = name.split('.');
      // 	_Api.extend( inst, obj );
      // };
      //     [
      //       {
      //         name:      'data'                -- string   - Property name
      //         val:       function () {},       -- function - Api method (or undefined if just an object
      //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
      //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
      //       },
      //       {
      //         name:     'row'
      //         val:       {},
      //         methodExt: [ ... ],
      //         propExt:   [
      //           {
      //             name:      'data'
      //             val:       function () {},
      //             methodExt: [ ... ],
      //             propExt:   [ ... ]
      //           },
      //           ...
      //         ]
      //       }
      //     ]


      _Api2.register = _api_register = function _api_register(name, val) {
        if (Array.isArray(name)) {
          for (var j = 0, jen = name.length; j < jen; j++) {
            _Api2.register(name[j], val);
          }

          return;
        }

        var i,
            ien,
            heir = name.split('.'),
            struct = __apiStruct,
            key,
            method;

        var find = function find(src, name) {
          for (var i = 0, ien = src.length; i < ien; i++) {
            if (src[i].name === name) {
              return src[i];
            }
          }

          return null;
        };

        for (i = 0, ien = heir.length; i < ien; i++) {
          method = heir[i].indexOf('()') !== -1;
          key = method ? heir[i].replace('()', '') : heir[i];
          var src = find(struct, key);

          if (!src) {
            src = {
              name: key,
              val: {},
              methodExt: [],
              propExt: [],
              type: 'object'
            };
            struct.push(src);
          }

          if (i === ien - 1) {
            src.val = val;
            src.type = typeof val === 'function' ? 'function' : $.isPlainObject(val) ? 'object' : 'other';
          } else {
            struct = method ? src.methodExt : src.propExt;
          }
        }
      };

      _Api2.registerPlural = _api_registerPlural = function _api_registerPlural(pluralName, singularName, val) {
        _Api2.register(pluralName, val);

        _Api2.register(singularName, function () {
          var ret = val.apply(this, arguments);

          if (ret === this) {
            // Returned item is the API instance that was passed in, return it
            return this;
          } else if (ret instanceof _Api2) {
            // New API instance returned, want the value from the first item
            // in the returned array for the singular result.
            return ret.length ? Array.isArray(ret[0]) ? new _Api2(ret.context, ret[0]) : // Array results are 'enhanced'
            ret[0] : undefined;
          } // Non-API return - just fire it back


          return ret;
        });
      };
      /**
       * Selector for HTML tables. Apply the given selector to the give array of
       * DataTables settings objects.
       *
       * @param {string|integer} [selector] jQuery selector string or integer
       * @param  {array} Array of DataTables settings objects to be filtered
       * @return {array}
       * @ignore
       */


      var __table_selector = function __table_selector(selector, a) {
        if (Array.isArray(selector)) {
          return $.map(selector, function (item) {
            return __table_selector(item, a);
          });
        } // Integer is used to pick out a table by index


        if (typeof selector === 'number') {
          return [a[selector]];
        } // Perform a jQuery selector on the table nodes


        var nodes = $.map(a, function (el, i) {
          return el.nTable;
        });
        return $(nodes).filter(selector).map(function (i) {
          // Need to translate back from the table node to the settings
          var idx = $.inArray(this, nodes);
          return a[idx];
        }).toArray();
      };
      /**
       * Context selector for the API's context (i.e. the tables the API instance
       * refers to.
       *
       * @name    DataTable.Api#tables
       * @param {string|integer} [selector] Selector to pick which tables the iterator
       *   should operate on. If not given, all tables in the current context are
       *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
       *   select multiple tables or as an integer to select a single table.
       * @returns {DataTable.Api} Returns a new API instance if a selector is given.
       */


      _api_register('tables()', function (selector) {
        // A new instance is created if there was a selector specified
        return selector !== undefined && selector !== null ? new _Api2(__table_selector(selector, this.context)) : this;
      });

      _api_register('table()', function (selector) {
        var tables = this.tables(selector);
        var ctx = tables.context; // Truncate to the first matched table

        return ctx.length ? new _Api2(ctx[0]) : tables;
      });

      _api_registerPlural('tables().nodes()', 'table().node()', function () {
        return this.iterator('table', function (ctx) {
          return ctx.nTable;
        }, 1);
      });

      _api_registerPlural('tables().body()', 'table().body()', function () {
        return this.iterator('table', function (ctx) {
          return ctx.nTBody;
        }, 1);
      });

      _api_registerPlural('tables().header()', 'table().header()', function () {
        return this.iterator('table', function (ctx) {
          return ctx.nTHead;
        }, 1);
      });

      _api_registerPlural('tables().footer()', 'table().footer()', function () {
        return this.iterator('table', function (ctx) {
          return ctx.nTFoot;
        }, 1);
      });

      _api_registerPlural('tables().containers()', 'table().container()', function () {
        return this.iterator('table', function (ctx) {
          return ctx.nTableWrapper;
        }, 1);
      });
      /**
       * Redraw the tables in the current context.
       */


      _api_register('draw()', function (paging) {
        return this.iterator('table', function (settings) {
          if (paging === 'page') {
            _fnDraw(settings);
          } else {
            if (typeof paging === 'string') {
              paging = paging === 'full-hold' ? false : true;
            }

            _fnReDraw(settings, paging === false);
          }
        });
      });
      /**
       * Get the current page index.
       *
       * @return {integer} Current page index (zero based)
       */

      /**
      * Set the current page.
      *
      * Note that if you attempt to show a page which does not exist, DataTables will
      * not throw an error, but rather reset the paging.
      *
      * @param {integer|string} action The paging action to take. This can be one of:
      *  * `integer` - The page index to jump to
      *  * `string` - An action to take:
      *    * `first` - Jump to first page.
      *    * `next` - Jump to the next page
      *    * `previous` - Jump to previous page
      *    * `last` - Jump to the last page.
      * @returns {DataTables.Api} this
      */


      _api_register('page()', function (action) {
        if (action === undefined) {
          return this.page.info().page; // not an expensive call
        } // else, have an action to take on all tables


        return this.iterator('table', function (settings) {
          _fnPageChange(settings, action);
        });
      });
      /**
       * Paging information for the first table in the current context.
       *
       * If you require paging information for another table, use the `table()` method
       * with a suitable selector.
       *
       * @return {object} Object with the following properties set:
       *  * `page` - Current page index (zero based - i.e. the first page is `0`)
       *  * `pages` - Total number of pages
       *  * `start` - Display index for the first record shown on the current page
       *  * `end` - Display index for the last record shown on the current page
       *  * `length` - Display length (number of records). Note that generally `start
       *    + length = end`, but this is not always true, for example if there are
       *    only 2 records to show on the final page, with a length of 10.
       *  * `recordsTotal` - Full data set length
       *  * `recordsDisplay` - Data set length once the current filtering criterion
       *    are applied.
       */


      _api_register('page.info()', function (action) {
        if (this.context.length === 0) {
          return undefined;
        }

        var settings = this.context[0],
            start = settings._iDisplayStart,
            len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
            visRecords = settings.fnRecordsDisplay(),
            all = len === -1;
        return {
          "page": all ? 0 : Math.floor(start / len),
          "pages": all ? 1 : Math.ceil(visRecords / len),
          "start": start,
          "end": settings.fnDisplayEnd(),
          "length": len,
          "recordsTotal": settings.fnRecordsTotal(),
          "recordsDisplay": visRecords,
          "serverSide": _fnDataSource(settings) === 'ssp'
        };
      });
      /**
       * Get the current page length.
       *
       * @return {integer} Current page length. Note `-1` indicates that all records
       *   are to be shown.
       */

      /**
      * Set the current page length.
      *
      * @param {integer} Page length to set. Use `-1` to show all records.
      * @returns {DataTables.Api} this
      */


      _api_register('page.len()', function (len) {
        // Note that we can't call this function 'length()' because `length`
        // is a Javascript property of functions which defines how many arguments
        // the function expects.
        if (len === undefined) {
          return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
        } // else, set the page length


        return this.iterator('table', function (settings) {
          _fnLengthChange(settings, len);
        });
      });

      var __reload = function __reload(settings, holdPosition, callback) {
        // Use the draw event to trigger a callback
        if (callback) {
          var api = new _Api2(settings);
          api.one('draw', function () {
            callback(api.ajax.json());
          });
        }

        if (_fnDataSource(settings) == 'ssp') {
          _fnReDraw(settings, holdPosition);
        } else {
          _fnProcessingDisplay(settings, true); // Cancel an existing request


          var xhr = settings.jqXHR;

          if (xhr && xhr.readyState !== 4) {
            xhr.abort();
          } // Trigger xhr


          _fnBuildAjax(settings, [], function (json) {
            _fnClearTable(settings);

            var data = _fnAjaxDataSrc(settings, json);

            for (var i = 0, ien = data.length; i < ien; i++) {
              _fnAddData(settings, data[i]);
            }

            _fnReDraw(settings, holdPosition);

            _fnProcessingDisplay(settings, false);
          });
        }
      };
      /**
       * Get the JSON response from the last Ajax request that DataTables made to the
       * server. Note that this returns the JSON from the first table in the current
       * context.
       *
       * @return {object} JSON received from the server.
       */


      _api_register('ajax.json()', function () {
        var ctx = this.context;

        if (ctx.length > 0) {
          return ctx[0].json;
        } // else return undefined;

      });
      /**
       * Get the data submitted in the last Ajax request
       */


      _api_register('ajax.params()', function () {
        var ctx = this.context;

        if (ctx.length > 0) {
          return ctx[0].oAjaxData;
        } // else return undefined;

      });
      /**
       * Reload tables from the Ajax data source. Note that this function will
       * automatically re-draw the table when the remote data has been loaded.
       *
       * @param {boolean} [reset=true] Reset (default) or hold the current paging
       *   position. A full re-sort and re-filter is performed when this method is
       *   called, which is why the pagination reset is the default action.
       * @returns {DataTables.Api} this
       */


      _api_register('ajax.reload()', function (callback, resetPaging) {
        return this.iterator('table', function (settings) {
          __reload(settings, resetPaging === false, callback);
        });
      });
      /**
       * Get the current Ajax URL. Note that this returns the URL from the first
       * table in the current context.
       *
       * @return {string} Current Ajax source URL
       */

      /**
      * Set the Ajax URL. Note that this will set the URL for all tables in the
      * current context.
      *
      * @param {string} url URL to set.
      * @returns {DataTables.Api} this
      */


      _api_register('ajax.url()', function (url) {
        var ctx = this.context;

        if (url === undefined) {
          // get
          if (ctx.length === 0) {
            return undefined;
          }

          ctx = ctx[0];
          return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
        } // set


        return this.iterator('table', function (settings) {
          if ($.isPlainObject(settings.ajax)) {
            settings.ajax.url = url;
          } else {
            settings.ajax = url;
          } // No need to consider sAjaxSource here since DataTables gives priority
          // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
          // value of `sAjaxSource` redundant.

        });
      });
      /**
       * Load data from the newly set Ajax URL. Note that this method is only
       * available when `ajax.url()` is used to set a URL. Additionally, this method
       * has the same effect as calling `ajax.reload()` but is provided for
       * convenience when setting a new URL. Like `ajax.reload()` it will
       * automatically redraw the table once the remote data has been loaded.
       *
       * @returns {DataTables.Api} this
       */


      _api_register('ajax.url().load()', function (callback, resetPaging) {
        // Same as a reload, but makes sense to present it for easy access after a
        // url change
        return this.iterator('table', function (ctx) {
          __reload(ctx, resetPaging === false, callback);
        });
      });

      var _selector_run = function _selector_run(type, selector, selectFn, settings, opts) {
        var out = [],
            res,
            a,
            i,
            ien,
            j,
            jen,
            selectorType = _typeof(selector); // Can't just check for isArray here, as an API or jQuery instance might be
        // given with their array like look


        if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
          selector = [selector];
        }

        for (i = 0, ien = selector.length; i < ien; i++) {
          // Only split on simple strings - complex expressions will be jQuery selectors
          a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ? selector[i].split(',') : [selector[i]];

          for (j = 0, jen = a.length; j < jen; j++) {
            res = selectFn(typeof a[j] === 'string' ? a[j].trim() : a[j]);

            if (res && res.length) {
              out = out.concat(res);
            }
          }
        } // selector extensions


        var ext = _ext.selector[type];

        if (ext.length) {
          for (i = 0, ien = ext.length; i < ien; i++) {
            out = ext[i](settings, opts, out);
          }
        }

        return _unique(out);
      };

      var _selector_opts = function _selector_opts(opts) {
        if (!opts) {
          opts = {};
        } // Backwards compatibility for 1.9- which used the terminology filter rather
        // than search


        if (opts.filter && opts.search === undefined) {
          opts.search = opts.filter;
        }

        return $.extend({
          search: 'none',
          order: 'current',
          page: 'all'
        }, opts);
      };

      var _selector_first = function _selector_first(inst) {
        // Reduce the API instance to the first item found
        for (var i = 0, ien = inst.length; i < ien; i++) {
          if (inst[i].length > 0) {
            // Assign the first element to the first item in the instance
            // and truncate the instance and context
            inst[0] = inst[i];
            inst[0].length = 1;
            inst.length = 1;
            inst.context = [inst.context[i]];
            return inst;
          }
        } // Not found - return an empty instance


        inst.length = 0;
        return inst;
      };

      var _selector_row_indexes = function _selector_row_indexes(settings, opts) {
        var i,
            ien,
            tmp,
            a = [],
            displayFiltered = settings.aiDisplay,
            displayMaster = settings.aiDisplayMaster;
        var search = opts.search,
            // none, applied, removed
        order = opts.order,
            // applied, current, index (original - compatibility with 1.9)
        page = opts.page; // all, current

        if (_fnDataSource(settings) == 'ssp') {
          // In server-side processing mode, most options are irrelevant since
          // rows not shown don't exist and the index order is the applied order
          // Removed is a special case - for consistency just return an empty
          // array
          return search === 'removed' ? [] : _range(0, displayMaster.length);
        } else if (page == 'current') {
          // Current page implies that order=current and fitler=applied, since it is
          // fairly senseless otherwise, regardless of what order and search actually
          // are
          for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
            a.push(displayFiltered[i]);
          }
        } else if (order == 'current' || order == 'applied') {
          if (search == 'none') {
            a = displayMaster.slice();
          } else if (search == 'applied') {
            a = displayFiltered.slice();
          } else if (search == 'removed') {
            // O(n+m) solution by creating a hash map
            var displayFilteredMap = {};

            for (var i = 0, ien = displayFiltered.length; i < ien; i++) {
              displayFilteredMap[displayFiltered[i]] = null;
            }

            a = $.map(displayMaster, function (el) {
              return !displayFilteredMap.hasOwnProperty(el) ? el : null;
            });
          }
        } else if (order == 'index' || order == 'original') {
          for (i = 0, ien = settings.aoData.length; i < ien; i++) {
            if (search == 'none') {
              a.push(i);
            } else {
              // applied | removed
              tmp = $.inArray(i, displayFiltered);

              if (tmp === -1 && search == 'removed' || tmp >= 0 && search == 'applied') {
                a.push(i);
              }
            }
          }
        }

        return a;
      };
      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
       * Rows
       *
       * {}          - no selector - use all available rows
       * {integer}   - row aoData index
       * {node}      - TR node
       * {string}    - jQuery selector to apply to the TR elements
       * {array}     - jQuery array of nodes, or simply an array of TR nodes
       *
       */


      var __row_selector = function __row_selector(settings, selector, opts) {
        var rows;

        var run = function run(sel) {
          var selInt = _intVal(sel);

          var i, ien;
          var aoData = settings.aoData; // Short cut - selector is a number and no options provided (default is
          // all records, so no need to check if the index is in there, since it
          // must be - dev error if the index doesn't exist).

          if (selInt !== null && !opts) {
            return [selInt];
          }

          if (!rows) {
            rows = _selector_row_indexes(settings, opts);
          }

          if (selInt !== null && $.inArray(selInt, rows) !== -1) {
            // Selector - integer
            return [selInt];
          } else if (sel === null || sel === undefined || sel === '') {
            // Selector - none
            return rows;
          } // Selector - function


          if (typeof sel === 'function') {
            return $.map(rows, function (idx) {
              var row = aoData[idx];
              return sel(idx, row._aData, row.nTr) ? idx : null;
            });
          } // Selector - node


          if (sel.nodeName) {
            var rowIdx = sel._DT_RowIndex; // Property added by DT for fast lookup

            var cellIdx = sel._DT_CellIndex;

            if (rowIdx !== undefined) {
              // Make sure that the row is actually still present in the table
              return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
            } else if (cellIdx) {
              return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
            } else {
              var host = $(sel).closest('*[data-dt-row]');
              return host.length ? [host.data('dt-row')] : [];
            }
          } // ID selector. Want to always be able to select rows by id, regardless
          // of if the tr element has been created or not, so can't rely upon
          // jQuery here - hence a custom implementation. This does not match
          // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
          // but to select it using a CSS selector engine (like Sizzle or
          // querySelect) it would need to need to be escaped for some characters.
          // DataTables simplifies this for row selectors since you can select
          // only a row. A # indicates an id any anything that follows is the id -
          // unescaped.


          if (typeof sel === 'string' && sel.charAt(0) === '#') {
            // get row index from id
            var rowObj = settings.aIds[sel.replace(/^#/, '')];

            if (rowObj !== undefined) {
              return [rowObj.idx];
            } // need to fall through to jQuery in case there is DOM id that
            // matches

          } // Get nodes in the order from the `rows` array with null values removed


          var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, 'nTr')); // Selector - jQuery selector string, array of nodes or jQuery object/
          // As jQuery's .filter() allows jQuery objects to be passed in filter,
          // it also allows arrays, so this will cope with all three options


          return $(nodes).filter(sel).map(function () {
            return this._DT_RowIndex;
          }).toArray();
        };

        return _selector_run('row', selector, run, settings, opts);
      };

      _api_register('rows()', function (selector, opts) {
        // argument shifting
        if (selector === undefined) {
          selector = '';
        } else if ($.isPlainObject(selector)) {
          opts = selector;
          selector = '';
        }

        opts = _selector_opts(opts);
        var inst = this.iterator('table', function (settings) {
          return __row_selector(settings, selector, opts);
        }, 1); // Want argument shifting here and in __row_selector?

        inst.selector.rows = selector;
        inst.selector.opts = opts;
        return inst;
      });

      _api_register('rows().nodes()', function () {
        return this.iterator('row', function (settings, row) {
          return settings.aoData[row].nTr || undefined;
        }, 1);
      });

      _api_register('rows().data()', function () {
        return this.iterator(true, 'rows', function (settings, rows) {
          return _pluck_order(settings.aoData, rows, '_aData');
        }, 1);
      });

      _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
        return this.iterator('row', function (settings, row) {
          var r = settings.aoData[row];
          return type === 'search' ? r._aFilterData : r._aSortData;
        }, 1);
      });

      _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
        return this.iterator('row', function (settings, row) {
          _fnInvalidate(settings, row, src);
        });
      });

      _api_registerPlural('rows().indexes()', 'row().index()', function () {
        return this.iterator('row', function (settings, row) {
          return row;
        }, 1);
      });

      _api_registerPlural('rows().ids()', 'row().id()', function (hash) {
        var a = [];
        var context = this.context; // `iterator` will drop undefined values, but in this case we want them

        for (var i = 0, ien = context.length; i < ien; i++) {
          for (var j = 0, jen = this[i].length; j < jen; j++) {
            var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
            a.push((hash === true ? '#' : '') + id);
          }
        }

        return new _Api2(context, a);
      });

      _api_registerPlural('rows().remove()', 'row().remove()', function () {
        var that = this;
        this.iterator('row', function (settings, row, thatIdx) {
          var data = settings.aoData;
          var rowData = data[row];
          var i, ien, j, jen;
          var loopRow, loopCells;
          data.splice(row, 1); // Update the cached indexes

          for (i = 0, ien = data.length; i < ien; i++) {
            loopRow = data[i];
            loopCells = loopRow.anCells; // Rows

            if (loopRow.nTr !== null) {
              loopRow.nTr._DT_RowIndex = i;
            } // Cells


            if (loopCells !== null) {
              for (j = 0, jen = loopCells.length; j < jen; j++) {
                loopCells[j]._DT_CellIndex.row = i;
              }
            }
          } // Delete from the display arrays


          _fnDeleteIndex(settings.aiDisplayMaster, row);

          _fnDeleteIndex(settings.aiDisplay, row);

          _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes
          // For server-side processing tables - subtract the deleted row from the count


          if (settings._iRecordsDisplay > 0) {
            settings._iRecordsDisplay--;
          } // Check for an 'overflow' they case for displaying the table


          _fnLengthOverflow(settings); // Remove the row's ID reference if there is one


          var id = settings.rowIdFn(rowData._aData);

          if (id !== undefined) {
            delete settings.aIds[id];
          }
        });
        this.iterator('table', function (settings) {
          for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
            settings.aoData[i].idx = i;
          }
        });
        return this;
      });

      _api_register('rows.add()', function (rows) {
        var newRows = this.iterator('table', function (settings) {
          var row, i, ien;
          var out = [];

          for (i = 0, ien = rows.length; i < ien; i++) {
            row = rows[i];

            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
              out.push(_fnAddTr(settings, row)[0]);
            } else {
              out.push(_fnAddData(settings, row));
            }
          }

          return out;
        }, 1); // Return an Api.rows() extended instance, so rows().nodes() etc can be used

        var modRows = this.rows(-1);
        modRows.pop();
        $.merge(modRows, newRows);
        return modRows;
      });
      /**
       *
       */


      _api_register('row()', function (selector, opts) {
        return _selector_first(this.rows(selector, opts));
      });

      _api_register('row().data()', function (data) {
        var ctx = this.context;

        if (data === undefined) {
          // Get
          return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
        } // Set


        var row = ctx[0].aoData[this[0]];
        row._aData = data; // If the DOM has an id, and the data source is an array

        if (Array.isArray(data) && row.nTr && row.nTr.id) {
          _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);
        } // Automatically invalidate


        _fnInvalidate(ctx[0], this[0], 'data');

        return this;
      });

      _api_register('row().node()', function () {
        var ctx = this.context;
        return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
      });

      _api_register('row.add()', function (row) {
        // Allow a jQuery object to be passed in - only a single row is added from
        // it though - the first element in the set
        if (row instanceof $ && row.length) {
          row = row[0];
        }

        var rows = this.iterator('table', function (settings) {
          if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
            return _fnAddTr(settings, row)[0];
          }

          return _fnAddData(settings, row);
        }); // Return an Api.rows() extended instance, with the newly added row selected

        return this.row(rows[0]);
      });

      var __details_add = function __details_add(ctx, row, data, klass) {
        // Convert to array of TR elements
        var rows = [];

        var addRow = function addRow(r, k) {
          // Recursion to allow for arrays of jQuery objects
          if (Array.isArray(r) || r instanceof $) {
            for (var i = 0, ien = r.length; i < ien; i++) {
              addRow(r[i], k);
            }

            return;
          } // If we get a TR element, then just add it directly - up to the dev
          // to add the correct number of columns etc


          if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
            rows.push(r);
          } else {
            // Otherwise create a row with a wrapper
            var created = $('<tr><td></td></tr>').addClass(k);
            $('td', created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
            rows.push(created[0]);
          }
        };

        addRow(data, klass);

        if (row._details) {
          row._details.detach();
        }

        row._details = $(rows); // If the children were already shown, that state should be retained

        if (row._detailsShow) {
          row._details.insertAfter(row.nTr);
        }
      };

      var __details_remove = function __details_remove(api, idx) {
        var ctx = api.context;

        if (ctx.length) {
          var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

          if (row && row._details) {
            row._details.remove();

            row._detailsShow = undefined;
            row._details = undefined;
          }
        }
      };

      var __details_display = function __details_display(api, show) {
        var ctx = api.context;

        if (ctx.length && api.length) {
          var row = ctx[0].aoData[api[0]];

          if (row._details) {
            row._detailsShow = show;

            if (show) {
              row._details.insertAfter(row.nTr);
            } else {
              row._details.detach();
            }

            __details_events(ctx[0]);
          }
        }
      };

      var __details_events = function __details_events(settings) {
        var api = new _Api2(settings);
        var namespace = '.dt.DT_details';
        var drawEvent = 'draw' + namespace;
        var colvisEvent = 'column-visibility' + namespace;
        var destroyEvent = 'destroy' + namespace;
        var data = settings.aoData;
        api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

        if (_pluck(data, '_details').length > 0) {
          // On each draw, insert the required elements into the document
          api.on(drawEvent, function (e, ctx) {
            if (settings !== ctx) {
              return;
            }

            api.rows({
              page: 'current'
            }).eq(0).each(function (idx) {
              // Internal data grab
              var row = data[idx];

              if (row._detailsShow) {
                row._details.insertAfter(row.nTr);
              }
            });
          }); // Column visibility change - update the colspan

          api.on(colvisEvent, function (e, ctx, idx, vis) {
            if (settings !== ctx) {
              return;
            } // Update the colspan for the details rows (note, only if it already has
            // a colspan)


            var row,
                visible = _fnVisbleColumns(ctx);

            for (var i = 0, ien = data.length; i < ien; i++) {
              row = data[i];

              if (row._details) {
                row._details.children('td[colspan]').attr('colspan', visible);
              }
            }
          }); // Table destroyed - nuke any child rows

          api.on(destroyEvent, function (e, ctx) {
            if (settings !== ctx) {
              return;
            }

            for (var i = 0, ien = data.length; i < ien; i++) {
              if (data[i]._details) {
                __details_remove(api, i);
              }
            }
          });
        }
      }; // Strings for the method names to help minification


      var _emp = '';

      var _child_obj = _emp + 'row().child';

      var _child_mth = _child_obj + '()'; // data can be:
      //  tr
      //  string
      //  jQuery or array of any of the above


      _api_register(_child_mth, function (data, klass) {
        var ctx = this.context;

        if (data === undefined) {
          // get
          return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
        } else if (data === true) {
          // show
          this.child.show();
        } else if (data === false) {
          // remove
          __details_remove(this);
        } else if (ctx.length && this.length) {
          // set
          __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
        }

        return this;
      });

      _api_register([_child_obj + '.show()', _child_mth + '.show()' // only when `child()` was called with parameters (without
      ], function (show) {
        // it returns an object and this method is not executed)
        __details_display(this, true);

        return this;
      });

      _api_register([_child_obj + '.hide()', _child_mth + '.hide()' // only when `child()` was called with parameters (without
      ], function () {
        // it returns an object and this method is not executed)
        __details_display(this, false);

        return this;
      });

      _api_register([_child_obj + '.remove()', _child_mth + '.remove()' // only when `child()` was called with parameters (without
      ], function () {
        // it returns an object and this method is not executed)
        __details_remove(this);

        return this;
      });

      _api_register(_child_obj + '.isShown()', function () {
        var ctx = this.context;

        if (ctx.length && this.length) {
          // _detailsShown as false or undefined will fall through to return false
          return ctx[0].aoData[this[0]]._detailsShow || false;
        }

        return false;
      });
      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
       * Columns
       *
       * {integer}           - column index (>=0 count from left, <0 count from right)
       * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
       * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
       * "{string}:name"     - column name
       * "{string}"          - jQuery selector on column header nodes
       *
       */
      // can be an array of these items, comma separated list, or an array of comma
      // separated lists


      var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/; // r1 and r2 are redundant - but it means that the parameters match for the
      // iterator callback in columns().data()

      var __columnData = function __columnData(settings, column, r1, r2, rows) {
        var a = [];

        for (var row = 0, ien = rows.length; row < ien; row++) {
          a.push(_fnGetCellData(settings, rows[row], column));
        }

        return a;
      };

      var __column_selector = function __column_selector(settings, selector, opts) {
        var columns = settings.aoColumns,
            names = _pluck(columns, 'sName'),
            nodes = _pluck(columns, 'nTh');

        var run = function run(s) {
          var selInt = _intVal(s); // Selector - all


          if (s === '') {
            return _range(columns.length);
          } // Selector - index


          if (selInt !== null) {
            return [selInt >= 0 ? selInt : // Count from left
            columns.length + selInt // Count from right (+ because its a negative value)
            ];
          } // Selector = function


          if (typeof s === 'function') {
            var rows = _selector_row_indexes(settings, opts);

            return $.map(columns, function (col, idx) {
              return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
            });
          } // jQuery or string selector


          var match = typeof s === 'string' ? s.match(__re_column_selector) : '';

          if (match) {
            switch (match[2]) {
              case 'visIdx':
              case 'visible':
                var idx = parseInt(match[1], 10); // Visible index given, convert to column index

                if (idx < 0) {
                  // Counting from the right
                  var visColumns = $.map(columns, function (col, i) {
                    return col.bVisible ? i : null;
                  });
                  return [visColumns[visColumns.length + idx]];
                } // Counting from the left


                return [_fnVisibleToColumnIndex(settings, idx)];

              case 'name':
                // match by name. `names` is column index complete and in order
                return $.map(names, function (name, i) {
                  return name === match[1] ? i : null;
                });

              default:
                return [];
            }
          } // Cell in the table body


          if (s.nodeName && s._DT_CellIndex) {
            return [s._DT_CellIndex.column];
          } // jQuery selector on the TH elements for the columns


          var jqResult = $(nodes).filter(s).map(function () {
            return $.inArray(this, nodes); // `nodes` is column index complete and in order
          }).toArray();

          if (jqResult.length || !s.nodeName) {
            return jqResult;
          } // Otherwise a node which might have a `dt-column` data attribute, or be
          // a child or such an element


          var host = $(s).closest('*[data-dt-column]');
          return host.length ? [host.data('dt-column')] : [];
        };

        return _selector_run('column', selector, run, settings, opts);
      };

      var __setColumnVis = function __setColumnVis(settings, column, vis) {
        var cols = settings.aoColumns,
            col = cols[column],
            data = settings.aoData,
            row,
            cells,
            i,
            ien,
            tr; // Get

        if (vis === undefined) {
          return col.bVisible;
        } // Set
        // No change


        if (col.bVisible === vis) {
          return;
        }

        if (vis) {
          // Insert column
          // Need to decide if we should use appendChild or insertBefore
          var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

          for (i = 0, ien = data.length; i < ien; i++) {
            tr = data[i].nTr;
            cells = data[i].anCells;

            if (tr) {
              // insertBefore can act like appendChild if 2nd arg is null
              tr.insertBefore(cells[column], cells[insertBefore] || null);
            }
          }
        } else {
          // Remove column
          $(_pluck(settings.aoData, 'anCells', column)).detach();
        } // Common actions


        col.bVisible = vis;
      };

      _api_register('columns()', function (selector, opts) {
        // argument shifting
        if (selector === undefined) {
          selector = '';
        } else if ($.isPlainObject(selector)) {
          opts = selector;
          selector = '';
        }

        opts = _selector_opts(opts);
        var inst = this.iterator('table', function (settings) {
          return __column_selector(settings, selector, opts);
        }, 1); // Want argument shifting here and in _row_selector?

        inst.selector.cols = selector;
        inst.selector.opts = opts;
        return inst;
      });

      _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
        return this.iterator('column', function (settings, column) {
          return settings.aoColumns[column].nTh;
        }, 1);
      });

      _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
        return this.iterator('column', function (settings, column) {
          return settings.aoColumns[column].nTf;
        }, 1);
      });

      _api_registerPlural('columns().data()', 'column().data()', function () {
        return this.iterator('column-rows', __columnData, 1);
      });

      _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
        return this.iterator('column', function (settings, column) {
          return settings.aoColumns[column].mData;
        }, 1);
      });

      _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
        return this.iterator('column-rows', function (settings, column, i, j, rows) {
          return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column);
        }, 1);
      });

      _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
        return this.iterator('column-rows', function (settings, column, i, j, rows) {
          return _pluck_order(settings.aoData, rows, 'anCells', column);
        }, 1);
      });

      _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
        var that = this;
        var ret = this.iterator('column', function (settings, column) {
          if (vis === undefined) {
            return settings.aoColumns[column].bVisible;
          } // else


          __setColumnVis(settings, column, vis);
        }); // Group the column visibility changes

        if (vis !== undefined) {
          this.iterator('table', function (settings) {
            // Redraw the header after changes
            _fnDrawHead(settings, settings.aoHeader);

            _fnDrawHead(settings, settings.aoFooter); // Update colspan for no records display. Child rows and extensions will use their own
            // listeners to do this - only need to update the empty table item here


            if (!settings.aiDisplay.length) {
              $(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
            }

            _fnSaveState(settings); // Second loop once the first is done for events


            that.iterator('column', function (settings, column) {
              _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);
            });

            if (calc === undefined || calc) {
              that.columns.adjust();
            }
          });
        }

        return ret;
      });

      _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
        return this.iterator('column', function (settings, column) {
          return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column;
        }, 1);
      });

      _api_register('columns.adjust()', function () {
        return this.iterator('table', function (settings) {
          _fnAdjustColumnSizing(settings);
        }, 1);
      });

      _api_register('column.index()', function (type, idx) {
        if (this.context.length !== 0) {
          var ctx = this.context[0];

          if (type === 'fromVisible' || type === 'toData') {
            return _fnVisibleToColumnIndex(ctx, idx);
          } else if (type === 'fromData' || type === 'toVisible') {
            return _fnColumnIndexToVisible(ctx, idx);
          }
        }
      });

      _api_register('column()', function (selector, opts) {
        return _selector_first(this.columns(selector, opts));
      });

      var __cell_selector = function __cell_selector(settings, selector, opts) {
        var data = settings.aoData;

        var rows = _selector_row_indexes(settings, opts);

        var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));

        var allCells = $(_flatten([], cells));
        var row;
        var columns = settings.aoColumns.length;
        var a, i, ien, j, o, host;

        var run = function run(s) {
          var fnSelector = typeof s === 'function';

          if (s === null || s === undefined || fnSelector) {
            // All cells and function selectors
            a = [];

            for (i = 0, ien = rows.length; i < ien; i++) {
              row = rows[i];

              for (j = 0; j < columns; j++) {
                o = {
                  row: row,
                  column: j
                };

                if (fnSelector) {
                  // Selector - function
                  host = data[row];

                  if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                    a.push(o);
                  }
                } else {
                  // Selector - all
                  a.push(o);
                }
              }
            }

            return a;
          } // Selector - index


          if ($.isPlainObject(s)) {
            // Valid cell index and its in the array of selectable rows
            return s.column !== undefined && s.row !== undefined && $.inArray(s.row, rows) !== -1 ? [s] : [];
          } // Selector - jQuery filtered cells


          var jqResult = allCells.filter(s).map(function (i, el) {
            return {
              // use a new object, in case someone changes the values
              row: el._DT_CellIndex.row,
              column: el._DT_CellIndex.column
            };
          }).toArray();

          if (jqResult.length || !s.nodeName) {
            return jqResult;
          } // Otherwise the selector is a node, and there is one last option - the
          // element might be a child of an element which has dt-row and dt-column
          // data attributes


          host = $(s).closest('*[data-dt-row]');
          return host.length ? [{
            row: host.data('dt-row'),
            column: host.data('dt-column')
          }] : [];
        };

        return _selector_run('cell', selector, run, settings, opts);
      };

      _api_register('cells()', function (rowSelector, columnSelector, opts) {
        // Argument shifting
        if ($.isPlainObject(rowSelector)) {
          // Indexes
          if (rowSelector.row === undefined) {
            // Selector options in first parameter
            opts = rowSelector;
            rowSelector = null;
          } else {
            // Cell index objects in first parameter
            opts = columnSelector;
            columnSelector = null;
          }
        }

        if ($.isPlainObject(columnSelector)) {
          opts = columnSelector;
          columnSelector = null;
        } // Cell selector


        if (columnSelector === null || columnSelector === undefined) {
          return this.iterator('table', function (settings) {
            return __cell_selector(settings, rowSelector, _selector_opts(opts));
          });
        } // The default built in options need to apply to row and columns


        var internalOpts = opts ? {
          page: opts.page,
          order: opts.order,
          search: opts.search
        } : {}; // Row + column selector

        var columns = this.columns(columnSelector, internalOpts);
        var rows = this.rows(rowSelector, internalOpts);
        var i, ien, j, jen;
        var cellsNoOpts = this.iterator('table', function (settings, idx) {
          var a = [];

          for (i = 0, ien = rows[idx].length; i < ien; i++) {
            for (j = 0, jen = columns[idx].length; j < jen; j++) {
              a.push({
                row: rows[idx][i],
                column: columns[idx][j]
              });
            }
          }

          return a;
        }, 1); // There is currently only one extension which uses a cell selector extension
        // It is a _major_ performance drag to run this if it isn't needed, so this is
        // an extension specific check at the moment

        var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
        $.extend(cells.selector, {
          cols: columnSelector,
          rows: rowSelector,
          opts: opts
        });
        return cells;
      });

      _api_registerPlural('cells().nodes()', 'cell().node()', function () {
        return this.iterator('cell', function (settings, row, column) {
          var data = settings.aoData[row];
          return data && data.anCells ? data.anCells[column] : undefined;
        }, 1);
      });

      _api_register('cells().data()', function () {
        return this.iterator('cell', function (settings, row, column) {
          return _fnGetCellData(settings, row, column);
        }, 1);
      });

      _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
        type = type === 'search' ? '_aFilterData' : '_aSortData';
        return this.iterator('cell', function (settings, row, column) {
          return settings.aoData[row][type][column];
        }, 1);
      });

      _api_registerPlural('cells().render()', 'cell().render()', function (type) {
        return this.iterator('cell', function (settings, row, column) {
          return _fnGetCellData(settings, row, column, type);
        }, 1);
      });

      _api_registerPlural('cells().indexes()', 'cell().index()', function () {
        return this.iterator('cell', function (settings, row, column) {
          return {
            row: row,
            column: column,
            columnVisible: _fnColumnIndexToVisible(settings, column)
          };
        }, 1);
      });

      _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
        return this.iterator('cell', function (settings, row, column) {
          _fnInvalidate(settings, row, src, column);
        });
      });

      _api_register('cell()', function (rowSelector, columnSelector, opts) {
        return _selector_first(this.cells(rowSelector, columnSelector, opts));
      });

      _api_register('cell().data()', function (data) {
        var ctx = this.context;
        var cell = this[0];

        if (data === undefined) {
          // Get
          return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
        } // Set


        _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);

        _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

        return this;
      });
      /**
       * Get current ordering (sorting) that has been applied to the table.
       *
       * @returns {array} 2D array containing the sorting information for the first
       *   table in the current context. Each element in the parent array represents
       *   a column being sorted upon (i.e. multi-sorting with two columns would have
       *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
       *   the column index that the sorting condition applies to, the second is the
       *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
       *   index of the sorting order from the `column.sorting` initialisation array.
       */

      /**
      * Set the ordering for the table.
      *
      * @param {integer} order Column index to sort upon.
      * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
      * @returns {DataTables.Api} this
      */

      /**
      * Set the ordering for the table.
      *
      * @param {array} order 1D array of sorting information to be applied.
      * @param {array} [...] Optional additional sorting conditions
      * @returns {DataTables.Api} this
      */

      /**
      * Set the ordering for the table.
      *
      * @param {array} order 2D array of sorting information to be applied.
      * @returns {DataTables.Api} this
      */


      _api_register('order()', function (order, dir) {
        var ctx = this.context;

        if (order === undefined) {
          // get
          return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
        } // set


        if (typeof order === 'number') {
          // Simple column / direction passed in
          order = [[order, dir]];
        } else if (order.length && !Array.isArray(order[0])) {
          // Arguments passed in (list of 1D arrays)
          order = Array.prototype.slice.call(arguments);
        } // otherwise a 2D array was passed in


        return this.iterator('table', function (settings) {
          settings.aaSorting = order.slice();
        });
      });
      /**
       * Attach a sort listener to an element for a given column
       *
       * @param {node|jQuery|string} node Identifier for the element(s) to attach the
       *   listener to. This can take the form of a single DOM node, a jQuery
       *   collection of nodes or a jQuery selector which will identify the node(s).
       * @param {integer} column the column that a click on this node will sort on
       * @param {function} [callback] callback function when sort is run
       * @returns {DataTables.Api} this
       */


      _api_register('order.listener()', function (node, column, callback) {
        return this.iterator('table', function (settings) {
          _fnSortAttachListener(settings, node, column, callback);
        });
      });

      _api_register('order.fixed()', function (set) {
        if (!set) {
          var ctx = this.context;
          var fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;
          return Array.isArray(fixed) ? {
            pre: fixed
          } : fixed;
        }

        return this.iterator('table', function (settings) {
          settings.aaSortingFixed = $.extend(true, {}, set);
        });
      }); // Order by the selected column(s)


      _api_register(['columns().order()', 'column().order()'], function (dir) {
        var that = this;
        return this.iterator('table', function (settings, i) {
          var sort = [];
          $.each(that[i], function (j, col) {
            sort.push([col, dir]);
          });
          settings.aaSorting = sort;
        });
      });

      _api_register('search()', function (input, regex, smart, caseInsen) {
        var ctx = this.context;

        if (input === undefined) {
          // get
          return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
        } // set


        return this.iterator('table', function (settings) {
          if (!settings.oFeatures.bFilter) {
            return;
          }

          _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
            "sSearch": input + "",
            "bRegex": regex === null ? false : regex,
            "bSmart": smart === null ? true : smart,
            "bCaseInsensitive": caseInsen === null ? true : caseInsen
          }), 1);
        });
      });

      _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {
        return this.iterator('column', function (settings, column) {
          var preSearch = settings.aoPreSearchCols;

          if (input === undefined) {
            // get
            return preSearch[column].sSearch;
          } // set


          if (!settings.oFeatures.bFilter) {
            return;
          }

          $.extend(preSearch[column], {
            "sSearch": input + "",
            "bRegex": regex === null ? false : regex,
            "bSmart": smart === null ? true : smart,
            "bCaseInsensitive": caseInsen === null ? true : caseInsen
          });

          _fnFilterComplete(settings, settings.oPreviousSearch, 1);
        });
      });
      /*
       * State API methods
       */


      _api_register('state()', function () {
        return this.context.length ? this.context[0].oSavedState : null;
      });

      _api_register('state.clear()', function () {
        return this.iterator('table', function (settings) {
          // Save an empty object
          settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
        });
      });

      _api_register('state.loaded()', function () {
        return this.context.length ? this.context[0].oLoadedState : null;
      });

      _api_register('state.save()', function () {
        return this.iterator('table', function (settings) {
          _fnSaveState(settings);
        });
      });
      /**
       * Provide a common method for plug-ins to check the version of DataTables being
       * used, in order to ensure compatibility.
       *
       *  @param {string} version Version string to check for, in the format "X.Y.Z".
       *    Note that the formats "X" and "X.Y" are also acceptable.
       *  @returns {boolean} true if this version of DataTables is greater or equal to
       *    the required version, or false if this version of DataTales is not
       *    suitable
       *  @static
       *  @dtopt API-Static
       *
       *  @example
       *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
       */


      DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
        var aThis = DataTable.version.split('.');
        var aThat = version.split('.');
        var iThis, iThat;

        for (var i = 0, iLen = aThat.length; i < iLen; i++) {
          iThis = parseInt(aThis[i], 10) || 0;
          iThat = parseInt(aThat[i], 10) || 0; // Parts are the same, keep comparing

          if (iThis === iThat) {
            continue;
          } // Parts are different, return immediately


          return iThis > iThat;
        }

        return true;
      };
      /**
       * Check if a `<table>` node is a DataTable table already or not.
       *
       *  @param {node|jquery|string} table Table node, jQuery object or jQuery
       *      selector for the table to test. Note that if more than more than one
       *      table is passed on, only the first will be checked
       *  @returns {boolean} true the table given is a DataTable, or false otherwise
       *  @static
       *  @dtopt API-Static
       *
       *  @example
       *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
       *      $('#example').dataTable();
       *    }
       */


      DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
        var t = $(table).get(0);
        var is = false;

        if (table instanceof DataTable.Api) {
          return true;
        }

        $.each(DataTable.settings, function (i, o) {
          var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
          var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

          if (o.nTable === t || head === t || foot === t) {
            is = true;
          }
        });
        return is;
      };
      /**
       * Get all DataTable tables that have been initialised - optionally you can
       * select to get only currently visible tables.
       *
       *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
       *    or visible tables only.
       *  @returns {array} Array of `table` nodes (not DataTable instances) which are
       *    DataTables
       *  @static
       *  @dtopt API-Static
       *
       *  @example
       *    $.each( $.fn.dataTable.tables(true), function () {
       *      $(table).DataTable().columns.adjust();
       *    } );
       */


      DataTable.tables = DataTable.fnTables = function (visible) {
        var api = false;

        if ($.isPlainObject(visible)) {
          api = visible.api;
          visible = visible.visible;
        }

        var a = $.map(DataTable.settings, function (o) {
          if (!visible || visible && $(o.nTable).is(':visible')) {
            return o.nTable;
          }
        });
        return api ? new _Api2(a) : a;
      };
      /**
       * Convert from camel case parameters to Hungarian notation. This is made public
       * for the extensions to provide the same ability as DataTables core to accept
       * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
       * parameters.
       *
       *  @param {object} src The model object which holds all parameters that can be
       *    mapped.
       *  @param {object} user The object to convert from camel case to Hungarian.
       *  @param {boolean} force When set to `true`, properties which already have a
       *    Hungarian value in the `user` object will be overwritten. Otherwise they
       *    won't be.
       */


      DataTable.camelToHungarian = _fnCamelToHungarian;
      /**
       *
       */

      _api_register('$()', function (selector, opts) {
        var rows = this.rows(opts).nodes(),
            // Get all rows
        jqRows = $(rows);
        return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
      }); // jQuery functions to operate on the tables


      $.each(['on', 'one', 'off'], function (i, key) {
        _api_register(key + '()', function ()
        /* event, handler */
        {
          var args = Array.prototype.slice.call(arguments); // Add the `dt` namespace automatically if it isn't already present

          args[0] = $.map(args[0].split(/\s/), function (e) {
            return !e.match(/\.dt\b/) ? e + '.dt' : e;
          }).join(' ');
          var inst = $(this.tables().nodes());
          inst[key].apply(inst, args);
          return this;
        });
      });

      _api_register('clear()', function () {
        return this.iterator('table', function (settings) {
          _fnClearTable(settings);
        });
      });

      _api_register('settings()', function () {
        return new _Api2(this.context, this.context);
      });

      _api_register('init()', function () {
        var ctx = this.context;
        return ctx.length ? ctx[0].oInit : null;
      });

      _api_register('data()', function () {
        return this.iterator('table', function (settings) {
          return _pluck(settings.aoData, '_aData');
        }).flatten();
      });

      _api_register('destroy()', function (remove) {
        remove = remove || false;
        return this.iterator('table', function (settings) {
          var orig = settings.nTableWrapper.parentNode;
          var classes = settings.oClasses;
          var table = settings.nTable;
          var tbody = settings.nTBody;
          var thead = settings.nTHead;
          var tfoot = settings.nTFoot;
          var jqTable = $(table);
          var jqTbody = $(tbody);
          var jqWrapper = $(settings.nTableWrapper);
          var rows = $.map(settings.aoData, function (r) {
            return r.nTr;
          });
          var i, ien; // Flag to note that the table is currently being destroyed - no action
          // should be taken

          settings.bDestroying = true; // Fire off the destroy callbacks for plug-ins etc

          _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]); // If not being removed from the document, make all columns visible


          if (!remove) {
            new _Api2(settings).columns().visible(true);
          } // Blitz all `DT` namespaced events (these are internal events, the
          // lowercase, `dt` events are user subscribed and they are responsible
          // for removing them


          jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
          $(window).off('.DT-' + settings.sInstance); // When scrolling we had to break the table up - restore it

          if (table != thead.parentNode) {
            jqTable.children('thead').detach();
            jqTable.append(thead);
          }

          if (tfoot && table != tfoot.parentNode) {
            jqTable.children('tfoot').detach();
            jqTable.append(tfoot);
          }

          settings.aaSorting = [];
          settings.aaSortingFixed = [];

          _fnSortingClasses(settings);

          $(rows).removeClass(settings.asStripeClasses.join(' '));
          $('th, td', thead).removeClass(classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone); // Add the TR elements back into the table in their original order

          jqTbody.children().detach();
          jqTbody.append(rows); // Remove the DataTables generated nodes, events and classes

          var removedMethod = remove ? 'remove' : 'detach';
          jqTable[removedMethod]();
          jqWrapper[removedMethod](); // If we need to reattach the table to the document

          if (!remove && orig) {
            // insertBefore acts like appendChild if !arg[1]
            orig.insertBefore(table, settings.nTableReinsertBefore); // Restore the width of the original table - was read from the style property,
            // so we can restore directly to that

            jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable); // If the were originally stripe classes - then we add them back here.
            // Note this is not fool proof (for example if not all rows had stripe
            // classes - but it's a good effort without getting carried away

            ien = settings.asDestroyStripes.length;

            if (ien) {
              jqTbody.children().each(function (i) {
                $(this).addClass(settings.asDestroyStripes[i % ien]);
              });
            }
          }
          /* Remove the settings object from the settings array */


          var idx = $.inArray(settings, DataTable.settings);

          if (idx !== -1) {
            DataTable.settings.splice(idx, 1);
          }
        });
      }); // Add the `every()` method for rows, columns and cells in a compact form


      $.each(['column', 'row', 'cell'], function (i, type) {
        _api_register(type + 's().every()', function (fn) {
          var opts = this.selector.opts;
          var api = this;
          return this.iterator(type, function (settings, arg1, arg2, arg3, arg4) {
            // Rows and columns:
            //  arg1 - index
            //  arg2 - table counter
            //  arg3 - loop counter
            //  arg4 - undefined
            // Cells:
            //  arg1 - row index
            //  arg2 - column index
            //  arg3 - table counter
            //  arg4 - loop counter
            fn.call(api[type](arg1, type === 'cell' ? arg2 : opts, type === 'cell' ? opts : undefined), arg1, arg2, arg3, arg4);
          });
        });
      }); // i18n method for extensions to be able to use the language object from the
      // DataTable

      _api_register('i18n()', function (token, def, plural) {
        var ctx = this.context[0];

        var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

        if (resolved === undefined) {
          resolved = def;
        }

        if (plural !== undefined && $.isPlainObject(resolved)) {
          resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
        }

        return resolved.replace('%d', plural); // nb: plural might be undefined,
      });
      /**
       * Version string for plug-ins to check compatibility. Allowed format is
       * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
       * only for non-release builds. See http://semver.org/ for more information.
       *  @member
       *  @type string
       *  @default Version number
       */


      DataTable.version = "1.10.24";
      /**
       * Private data store, containing all of the settings objects that are
       * created for the tables on a given page.
       *
       * Note that the `DataTable.settings` object is aliased to
       * `jQuery.fn.dataTableExt` through which it may be accessed and
       * manipulated, or `jQuery.fn.dataTable.settings`.
       *  @member
       *  @type array
       *  @default []
       *  @private
       */

      DataTable.settings = [];
      /**
       * Object models container, for the various models that DataTables has
       * available to it. These models define the objects that are used to hold
       * the active state and configuration of the table.
       *  @namespace
       */

      DataTable.models = {};
      /**
       * Template object for the way in which DataTables holds information about
       * search information for the global filter and individual column filters.
       *  @namespace
       */

      DataTable.models.oSearch = {
        /**
         * Flag to indicate if the filtering should be case insensitive or not
         *  @type boolean
         *  @default true
         */
        "bCaseInsensitive": true,

        /**
         * Applied search term
         *  @type string
         *  @default <i>Empty string</i>
         */
        "sSearch": "",

        /**
         * Flag to indicate if the search term should be interpreted as a
         * regular expression (true) or not (false) and therefore and special
         * regex characters escaped.
         *  @type boolean
         *  @default false
         */
        "bRegex": false,

        /**
         * Flag to indicate if DataTables is to use its smart filtering or not.
         *  @type boolean
         *  @default true
         */
        "bSmart": true
      };
      /**
       * Template object for the way in which DataTables holds information about
       * each individual row. This is the object format used for the settings
       * aoData array.
       *  @namespace
       */

      DataTable.models.oRow = {
        /**
         * TR element for the row
         *  @type node
         *  @default null
         */
        "nTr": null,

        /**
         * Array of TD elements for each row. This is null until the row has been
         * created.
         *  @type array nodes
         *  @default []
         */
        "anCells": null,

        /**
         * Data object from the original data source for the row. This is either
         * an array if using the traditional form of DataTables, or an object if
         * using mData options. The exact type will depend on the passed in
         * data from the data source, or will be an array if using DOM a data
         * source.
         *  @type array|object
         *  @default []
         */
        "_aData": [],

        /**
         * Sorting data cache - this array is ostensibly the same length as the
         * number of columns (although each index is generated only as it is
         * needed), and holds the data that is used for sorting each column in the
         * row. We do this cache generation at the start of the sort in order that
         * the formatting of the sort data need be done only once for each cell
         * per sort. This array should not be read from or written to by anything
         * other than the master sorting methods.
         *  @type array
         *  @default null
         *  @private
         */
        "_aSortData": null,

        /**
         * Per cell filtering data cache. As per the sort data cache, used to
         * increase the performance of the filtering in DataTables
         *  @type array
         *  @default null
         *  @private
         */
        "_aFilterData": null,

        /**
         * Filtering data cache. This is the same as the cell filtering cache, but
         * in this case a string rather than an array. This is easily computed with
         * a join on `_aFilterData`, but is provided as a cache so the join isn't
         * needed on every search (memory traded for performance)
         *  @type array
         *  @default null
         *  @private
         */
        "_sFilterRow": null,

        /**
         * Cache of the class name that DataTables has applied to the row, so we
         * can quickly look at this variable rather than needing to do a DOM check
         * on className for the nTr property.
         *  @type string
         *  @default <i>Empty string</i>
         *  @private
         */
        "_sRowStripe": "",

        /**
         * Denote if the original data source was from the DOM, or the data source
         * object. This is used for invalidating data, so DataTables can
         * automatically read data from the original source, unless uninstructed
         * otherwise.
         *  @type string
         *  @default null
         *  @private
         */
        "src": null,

        /**
         * Index in the aoData array. This saves an indexOf lookup when we have the
         * object, but want to know the index
         *  @type integer
         *  @default -1
         *  @private
         */
        "idx": -1
      };
      /**
       * Template object for the column information object in DataTables. This object
       * is held in the settings aoColumns array and contains all the information that
       * DataTables needs about each individual column.
       *
       * Note that this object is related to {@link DataTable.defaults.column}
       * but this one is the internal data store for DataTables's cache of columns.
       * It should NOT be manipulated outside of DataTables. Any configuration should
       * be done through the initialisation options.
       *  @namespace
       */

      DataTable.models.oColumn = {
        /**
         * Column index. This could be worked out on-the-fly with $.inArray, but it
         * is faster to just hold it as a variable
         *  @type integer
         *  @default null
         */
        "idx": null,

        /**
         * A list of the columns that sorting should occur on when this column
         * is sorted. That this property is an array allows multi-column sorting
         * to be defined for a column (for example first name / last name columns
         * would benefit from this). The values are integers pointing to the
         * columns to be sorted on (typically it will be a single integer pointing
         * at itself, but that doesn't need to be the case).
         *  @type array
         */
        "aDataSort": null,

        /**
         * Define the sorting directions that are applied to the column, in sequence
         * as the column is repeatedly sorted upon - i.e. the first value is used
         * as the sorting direction when the column if first sorted (clicked on).
         * Sort it again (click again) and it will move on to the next index.
         * Repeat until loop.
         *  @type array
         */
        "asSorting": null,

        /**
         * Flag to indicate if the column is searchable, and thus should be included
         * in the filtering or not.
         *  @type boolean
         */
        "bSearchable": null,

        /**
         * Flag to indicate if the column is sortable or not.
         *  @type boolean
         */
        "bSortable": null,

        /**
         * Flag to indicate if the column is currently visible in the table or not
         *  @type boolean
         */
        "bVisible": null,

        /**
         * Store for manual type assignment using the `column.type` option. This
         * is held in store so we can manipulate the column's `sType` property.
         *  @type string
         *  @default null
         *  @private
         */
        "_sManualType": null,

        /**
         * Flag to indicate if HTML5 data attributes should be used as the data
         * source for filtering or sorting. True is either are.
         *  @type boolean
         *  @default false
         *  @private
         */
        "_bAttrSrc": false,

        /**
         * Developer definable function that is called whenever a cell is created (Ajax source,
         * etc) or processed for input (DOM source). This can be used as a compliment to mRender
         * allowing you to modify the DOM element (add background colour for example) when the
         * element is available.
         *  @type function
         *  @param {element} nTd The TD node that has been created
         *  @param {*} sData The Data for the cell
         *  @param {array|object} oData The data for the whole row
         *  @param {int} iRow The row index for the aoData data store
         *  @default null
         */
        "fnCreatedCell": null,

        /**
         * Function to get data from a cell in a column. You should <b>never</b>
         * access data directly through _aData internally in DataTables - always use
         * the method attached to this property. It allows mData to function as
         * required. This function is automatically assigned by the column
         * initialisation method
         *  @type function
         *  @param {array|object} oData The data array/object for the array
         *    (i.e. aoData[]._aData)
         *  @param {string} sSpecific The specific data type you want to get -
         *    'display', 'type' 'filter' 'sort'
         *  @returns {*} The data for the cell from the given row's data
         *  @default null
         */
        "fnGetData": null,

        /**
         * Function to set data for a cell in the column. You should <b>never</b>
         * set the data directly to _aData internally in DataTables - always use
         * this method. It allows mData to function as required. This function
         * is automatically assigned by the column initialisation method
         *  @type function
         *  @param {array|object} oData The data array/object for the array
         *    (i.e. aoData[]._aData)
         *  @param {*} sValue Value to set
         *  @default null
         */
        "fnSetData": null,

        /**
         * Property to read the value for the cells in the column from the data
         * source array / object. If null, then the default content is used, if a
         * function is given then the return from the function is used.
         *  @type function|int|string|null
         *  @default null
         */
        "mData": null,

        /**
         * Partner property to mData which is used (only when defined) to get
         * the data - i.e. it is basically the same as mData, but without the
         * 'set' option, and also the data fed to it is the result from mData.
         * This is the rendering method to match the data method of mData.
         *  @type function|int|string|null
         *  @default null
         */
        "mRender": null,

        /**
         * Unique header TH/TD element for this column - this is what the sorting
         * listener is attached to (if sorting is enabled.)
         *  @type node
         *  @default null
         */
        "nTh": null,

        /**
         * Unique footer TH/TD element for this column (if there is one). Not used
         * in DataTables as such, but can be used for plug-ins to reference the
         * footer for each column.
         *  @type node
         *  @default null
         */
        "nTf": null,

        /**
         * The class to apply to all TD elements in the table's TBODY for the column
         *  @type string
         *  @default null
         */
        "sClass": null,

        /**
         * When DataTables calculates the column widths to assign to each column,
         * it finds the longest string in each column and then constructs a
         * temporary table and reads the widths from that. The problem with this
         * is that "mmm" is much wider then "iiii", but the latter is a longer
         * string - thus the calculation can go wrong (doing it properly and putting
         * it into an DOM object and measuring that is horribly(!) slow). Thus as
         * a "work around" we provide this option. It will append its value to the
         * text that is found to be the longest string for the column - i.e. padding.
         *  @type string
         */
        "sContentPadding": null,

        /**
         * Allows a default value to be given for a column's data, and will be used
         * whenever a null data source is encountered (this can be because mData
         * is set to null, or because the data source itself is null).
         *  @type string
         *  @default null
         */
        "sDefaultContent": null,

        /**
         * Name for the column, allowing reference to the column by name as well as
         * by index (needs a lookup to work by name).
         *  @type string
         */
        "sName": null,

        /**
         * Custom sorting data type - defines which of the available plug-ins in
         * afnSortData the custom sorting will use - if any is defined.
         *  @type string
         *  @default std
         */
        "sSortDataType": 'std',

        /**
         * Class to be applied to the header element when sorting on this column
         *  @type string
         *  @default null
         */
        "sSortingClass": null,

        /**
         * Class to be applied to the header element when sorting on this column -
         * when jQuery UI theming is used.
         *  @type string
         *  @default null
         */
        "sSortingClassJUI": null,

        /**
         * Title of the column - what is seen in the TH element (nTh).
         *  @type string
         */
        "sTitle": null,

        /**
         * Column sorting and filtering type
         *  @type string
         *  @default null
         */
        "sType": null,

        /**
         * Width of the column
         *  @type string
         *  @default null
         */
        "sWidth": null,

        /**
         * Width of the column when it was first "encountered"
         *  @type string
         *  @default null
         */
        "sWidthOrig": null
      };
      /*
       * Developer note: The properties of the object below are given in Hungarian
       * notation, that was used as the interface for DataTables prior to v1.10, however
       * from v1.10 onwards the primary interface is camel case. In order to avoid
       * breaking backwards compatibility utterly with this change, the Hungarian
       * version is still, internally the primary interface, but is is not documented
       * - hence the @name tags in each doc comment. This allows a Javascript function
       * to create a map from Hungarian notation to camel case (going the other direction
       * would require each property to be listed, which would add around 3K to the size
       * of DataTables, while this method is about a 0.5K hit).
       *
       * Ultimately this does pave the way for Hungarian notation to be dropped
       * completely, but that is a massive amount of work and will break current
       * installs (therefore is on-hold until v2).
       */

      /**
       * Initialisation options that can be given to DataTables at initialisation
       * time.
       *  @namespace
       */

      DataTable.defaults = {
        /**
         * An array of data to use for the table, passed in at initialisation which
         * will be used in preference to any data which is already in the DOM. This is
         * particularly useful for constructing tables purely in Javascript, for
         * example with a custom Ajax call.
         *  @type array
         *  @default null
         *
         *  @dtopt Option
         *  @name DataTable.defaults.data
         *
         *  @example
         *    // Using a 2D array data source
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "data": [
         *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
         *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
         *        ],
         *        "columns": [
         *          { "title": "Engine" },
         *          { "title": "Browser" },
         *          { "title": "Platform" },
         *          { "title": "Version" },
         *          { "title": "Grade" }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using an array of objects as a data source (`data`)
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "data": [
         *          {
         *            "engine":   "Trident",
         *            "browser":  "Internet Explorer 4.0",
         *            "platform": "Win 95+",
         *            "version":  4,
         *            "grade":    "X"
         *          },
         *          {
         *            "engine":   "Trident",
         *            "browser":  "Internet Explorer 5.0",
         *            "platform": "Win 95+",
         *            "version":  5,
         *            "grade":    "C"
         *          }
         *        ],
         *        "columns": [
         *          { "title": "Engine",   "data": "engine" },
         *          { "title": "Browser",  "data": "browser" },
         *          { "title": "Platform", "data": "platform" },
         *          { "title": "Version",  "data": "version" },
         *          { "title": "Grade",    "data": "grade" }
         *        ]
         *      } );
         *    } );
         */
        "aaData": null,

        /**
         * If ordering is enabled, then DataTables will perform a first pass sort on
         * initialisation. You can define which column(s) the sort is performed
         * upon, and the sorting direction, with this variable. The `sorting` array
         * should contain an array for each column to be sorted initially containing
         * the column's index and a direction string ('asc' or 'desc').
         *  @type array
         *  @default [[0,'asc']]
         *
         *  @dtopt Option
         *  @name DataTable.defaults.order
         *
         *  @example
         *    // Sort by 3rd column first, and then 4th column
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "order": [[2,'asc'], [3,'desc']]
         *      } );
         *    } );
         *
         *    // No initial sorting
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "order": []
         *      } );
         *    } );
         */
        "aaSorting": [[0, 'asc']],

        /**
         * This parameter is basically identical to the `sorting` parameter, but
         * cannot be overridden by user interaction with the table. What this means
         * is that you could have a column (visible or hidden) which the sorting
         * will always be forced on first - any sorting after that (from the user)
         * will then be performed as required. This can be useful for grouping rows
         * together.
         *  @type array
         *  @default null
         *
         *  @dtopt Option
         *  @name DataTable.defaults.orderFixed
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "orderFixed": [[0,'asc']]
         *      } );
         *    } )
         */
        "aaSortingFixed": [],

        /**
         * DataTables can be instructed to load data to display in the table from a
         * Ajax source. This option defines how that Ajax call is made and where to.
         *
         * The `ajax` property has three different modes of operation, depending on
         * how it is defined. These are:
         *
         * * `string` - Set the URL from where the data should be loaded from.
         * * `object` - Define properties for `jQuery.ajax`.
         * * `function` - Custom data get function
         *
         * `string`
         * --------
         *
         * As a string, the `ajax` property simply defines the URL from which
         * DataTables will load data.
         *
         * `object`
         * --------
         *
         * As an object, the parameters in the object are passed to
         * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
         * of the Ajax request. DataTables has a number of default parameters which
         * you can override using this option. Please refer to the jQuery
         * documentation for a full description of the options available, although
         * the following parameters provide additional options in DataTables or
         * require special consideration:
         *
         * * `data` - As with jQuery, `data` can be provided as an object, but it
         *   can also be used as a function to manipulate the data DataTables sends
         *   to the server. The function takes a single parameter, an object of
         *   parameters with the values that DataTables has readied for sending. An
         *   object may be returned which will be merged into the DataTables
         *   defaults, or you can add the items to the object that was passed in and
         *   not return anything from the function. This supersedes `fnServerParams`
         *   from DataTables 1.9-.
         *
         * * `dataSrc` - By default DataTables will look for the property `data` (or
         *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
         *   from an Ajax source or for server-side processing - this parameter
         *   allows that property to be changed. You can use Javascript dotted
         *   object notation to get a data source for multiple levels of nesting, or
         *   it my be used as a function. As a function it takes a single parameter,
         *   the JSON returned from the server, which can be manipulated as
         *   required, with the returned value being that used by DataTables as the
         *   data source for the table. This supersedes `sAjaxDataProp` from
         *   DataTables 1.9-.
         *
         * * `success` - Should not be overridden it is used internally in
         *   DataTables. To manipulate / transform the data returned by the server
         *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
         *
         * `function`
         * ----------
         *
         * As a function, making the Ajax call is left up to yourself allowing
         * complete control of the Ajax request. Indeed, if desired, a method other
         * than Ajax could be used to obtain the required data, such as Web storage
         * or an AIR database.
         *
         * The function is given four parameters and no return is required. The
         * parameters are:
         *
         * 1. _object_ - Data to send to the server
         * 2. _function_ - Callback function that must be executed when the required
         *    data has been obtained. That data should be passed into the callback
         *    as the only parameter
         * 3. _object_ - DataTables settings object for the table
         *
         * Note that this supersedes `fnServerData` from DataTables 1.9-.
         *
         *  @type string|object|function
         *  @default null
         *
         *  @dtopt Option
         *  @name DataTable.defaults.ajax
         *  @since 1.10.0
         *
         * @example
         *   // Get JSON data from a file via Ajax.
         *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
         *   $('#example').dataTable( {
         *     "ajax": "data.json"
         *   } );
         *
         * @example
         *   // Get JSON data from a file via Ajax, using `dataSrc` to change
         *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
         *   $('#example').dataTable( {
         *     "ajax": {
         *       "url": "data.json",
         *       "dataSrc": "tableData"
         *     }
         *   } );
         *
         * @example
         *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
         *   // from a plain array rather than an array in an object
         *   $('#example').dataTable( {
         *     "ajax": {
         *       "url": "data.json",
         *       "dataSrc": ""
         *     }
         *   } );
         *
         * @example
         *   // Manipulate the data returned from the server - add a link to data
         *   // (note this can, should, be done using `render` for the column - this
         *   // is just a simple example of how the data can be manipulated).
         *   $('#example').dataTable( {
         *     "ajax": {
         *       "url": "data.json",
         *       "dataSrc": function ( json ) {
         *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
         *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
         *         }
         *         return json;
         *       }
         *     }
         *   } );
         *
         * @example
         *   // Add data to the request
         *   $('#example').dataTable( {
         *     "ajax": {
         *       "url": "data.json",
         *       "data": function ( d ) {
         *         return {
         *           "extra_search": $('#extra').val()
         *         };
         *       }
         *     }
         *   } );
         *
         * @example
         *   // Send request as POST
         *   $('#example').dataTable( {
         *     "ajax": {
         *       "url": "data.json",
         *       "type": "POST"
         *     }
         *   } );
         *
         * @example
         *   // Get the data from localStorage (could interface with a form for
         *   // adding, editing and removing rows).
         *   $('#example').dataTable( {
         *     "ajax": function (data, callback, settings) {
         *       callback(
         *         JSON.parse( localStorage.getItem('dataTablesData') )
         *       );
         *     }
         *   } );
         */
        "ajax": null,

        /**
         * This parameter allows you to readily specify the entries in the length drop
         * down menu that DataTables shows when pagination is enabled. It can be
         * either a 1D array of options which will be used for both the displayed
         * option and the value, or a 2D array which will use the array in the first
         * position as the value, and the array in the second position as the
         * displayed options (useful for language strings such as 'All').
         *
         * Note that the `pageLength` property will be automatically set to the
         * first value given in this array, unless `pageLength` is also provided.
         *  @type array
         *  @default [ 10, 25, 50, 100 ]
         *
         *  @dtopt Option
         *  @name DataTable.defaults.lengthMenu
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
         *      } );
         *    } );
         */
        "aLengthMenu": [10, 25, 50, 100],

        /**
         * The `columns` option in the initialisation parameter allows you to define
         * details about the way individual columns behave. For a full list of
         * column options that can be set, please see
         * {@link DataTable.defaults.column}. Note that if you use `columns` to
         * define your columns, you must have an entry in the array for every single
         * column that you have in your table (these can be null if you don't which
         * to specify any options).
         *  @member
         *
         *  @name DataTable.defaults.column
         */
        "aoColumns": null,

        /**
         * Very similar to `columns`, `columnDefs` allows you to target a specific
         * column, multiple columns, or all columns, using the `targets` property of
         * each object in the array. This allows great flexibility when creating
         * tables, as the `columnDefs` arrays can be of any length, targeting the
         * columns you specifically want. `columnDefs` may use any of the column
         * options available: {@link DataTable.defaults.column}, but it _must_
         * have `targets` defined in each object in the array. Values in the `targets`
         * array may be:
         *   <ul>
         *     <li>a string - class name will be matched on the TH for the column</li>
         *     <li>0 or a positive integer - column index counting from the left</li>
         *     <li>a negative integer - column index counting from the right</li>
         *     <li>the string "_all" - all columns (i.e. assign a default)</li>
         *   </ul>
         *  @member
         *
         *  @name DataTable.defaults.columnDefs
         */
        "aoColumnDefs": null,

        /**
         * Basically the same as `search`, this parameter defines the individual column
         * filtering state at initialisation time. The array must be of the same size
         * as the number of columns, and each element be an object with the parameters
         * `search` and `escapeRegex` (the latter is optional). 'null' is also
         * accepted and the default will be used.
         *  @type array
         *  @default []
         *
         *  @dtopt Option
         *  @name DataTable.defaults.searchCols
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "searchCols": [
         *          null,
         *          { "search": "My filter" },
         *          null,
         *          { "search": "^[0-9]", "escapeRegex": false }
         *        ]
         *      } );
         *    } )
         */
        "aoSearchCols": [],

        /**
         * An array of CSS classes that should be applied to displayed rows. This
         * array may be of any length, and DataTables will apply each class
         * sequentially, looping when required.
         *  @type array
         *  @default null <i>Will take the values determined by the `oClasses.stripe*`
         *    options</i>
         *
         *  @dtopt Option
         *  @name DataTable.defaults.stripeClasses
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
         *      } );
         *    } )
         */
        "asStripeClasses": null,

        /**
         * Enable or disable automatic column width calculation. This can be disabled
         * as an optimisation (it takes some time to calculate the widths) if the
         * tables widths are passed in using `columns`.
         *  @type boolean
         *  @default true
         *
         *  @dtopt Features
         *  @name DataTable.defaults.autoWidth
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "autoWidth": false
         *      } );
         *    } );
         */
        "bAutoWidth": true,

        /**
         * Deferred rendering can provide DataTables with a huge speed boost when you
         * are using an Ajax or JS data source for the table. This option, when set to
         * true, will cause DataTables to defer the creation of the table elements for
         * each row until they are needed for a draw - saving a significant amount of
         * time.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Features
         *  @name DataTable.defaults.deferRender
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "ajax": "sources/arrays.txt",
         *        "deferRender": true
         *      } );
         *    } );
         */
        "bDeferRender": false,

        /**
         * Replace a DataTable which matches the given selector and replace it with
         * one which has the properties of the new initialisation object passed. If no
         * table matches the selector, then the new DataTable will be constructed as
         * per normal.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Options
         *  @name DataTable.defaults.destroy
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "srollY": "200px",
         *        "paginate": false
         *      } );
         *
         *      // Some time later....
         *      $('#example').dataTable( {
         *        "filter": false,
         *        "destroy": true
         *      } );
         *    } );
         */
        "bDestroy": false,

        /**
         * Enable or disable filtering of data. Filtering in DataTables is "smart" in
         * that it allows the end user to input multiple words (space separated) and
         * will match a row containing those words, even if not in the order that was
         * specified (this allow matching across multiple columns). Note that if you
         * wish to use filtering in DataTables this must remain 'true' - to remove the
         * default filtering input box and retain filtering abilities, please use
         * {@link DataTable.defaults.dom}.
         *  @type boolean
         *  @default true
         *
         *  @dtopt Features
         *  @name DataTable.defaults.searching
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "searching": false
         *      } );
         *    } );
         */
        "bFilter": true,

        /**
         * Enable or disable the table information display. This shows information
         * about the data that is currently visible on the page, including information
         * about filtered data if that action is being performed.
         *  @type boolean
         *  @default true
         *
         *  @dtopt Features
         *  @name DataTable.defaults.info
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "info": false
         *      } );
         *    } );
         */
        "bInfo": true,

        /**
         * Allows the end user to select the size of a formatted page from a select
         * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
         *  @type boolean
         *  @default true
         *
         *  @dtopt Features
         *  @name DataTable.defaults.lengthChange
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "lengthChange": false
         *      } );
         *    } );
         */
        "bLengthChange": true,

        /**
         * Enable or disable pagination.
         *  @type boolean
         *  @default true
         *
         *  @dtopt Features
         *  @name DataTable.defaults.paging
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "paging": false
         *      } );
         *    } );
         */
        "bPaginate": true,

        /**
         * Enable or disable the display of a 'processing' indicator when the table is
         * being processed (e.g. a sort). This is particularly useful for tables with
         * large amounts of data where it can take a noticeable amount of time to sort
         * the entries.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Features
         *  @name DataTable.defaults.processing
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "processing": true
         *      } );
         *    } );
         */
        "bProcessing": false,

        /**
         * Retrieve the DataTables object for the given selector. Note that if the
         * table has already been initialised, this parameter will cause DataTables
         * to simply return the object that has already been set up - it will not take
         * account of any changes you might have made to the initialisation object
         * passed to DataTables (setting this parameter to true is an acknowledgement
         * that you understand this). `destroy` can be used to reinitialise a table if
         * you need.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Options
         *  @name DataTable.defaults.retrieve
         *
         *  @example
         *    $(document).ready( function() {
         *      initTable();
         *      tableActions();
         *    } );
         *
         *    function initTable ()
         *    {
         *      return $('#example').dataTable( {
         *        "scrollY": "200px",
         *        "paginate": false,
         *        "retrieve": true
         *      } );
         *    }
         *
         *    function tableActions ()
         *    {
         *      var table = initTable();
         *      // perform API operations with oTable
         *    }
         */
        "bRetrieve": false,

        /**
         * When vertical (y) scrolling is enabled, DataTables will force the height of
         * the table's viewport to the given height at all times (useful for layout).
         * However, this can look odd when filtering data down to a small data set,
         * and the footer is left "floating" further down. This parameter (when
         * enabled) will cause DataTables to collapse the table's viewport down when
         * the result set will fit within the given Y height.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Options
         *  @name DataTable.defaults.scrollCollapse
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "scrollY": "200",
         *        "scrollCollapse": true
         *      } );
         *    } );
         */
        "bScrollCollapse": false,

        /**
         * Configure DataTables to use server-side processing. Note that the
         * `ajax` parameter must also be given in order to give DataTables a
         * source to obtain the required data for each draw.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Features
         *  @dtopt Server-side
         *  @name DataTable.defaults.serverSide
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "serverSide": true,
         *        "ajax": "xhr.php"
         *      } );
         *    } );
         */
        "bServerSide": false,

        /**
         * Enable or disable sorting of columns. Sorting of individual columns can be
         * disabled by the `sortable` option for each column.
         *  @type boolean
         *  @default true
         *
         *  @dtopt Features
         *  @name DataTable.defaults.ordering
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "ordering": false
         *      } );
         *    } );
         */
        "bSort": true,

        /**
         * Enable or display DataTables' ability to sort multiple columns at the
         * same time (activated by shift-click by the user).
         *  @type boolean
         *  @default true
         *
         *  @dtopt Options
         *  @name DataTable.defaults.orderMulti
         *
         *  @example
         *    // Disable multiple column sorting ability
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "orderMulti": false
         *      } );
         *    } );
         */
        "bSortMulti": true,

        /**
         * Allows control over whether DataTables should use the top (true) unique
         * cell that is found for a single column, or the bottom (false - default).
         * This is useful when using complex headers.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Options
         *  @name DataTable.defaults.orderCellsTop
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "orderCellsTop": true
         *      } );
         *    } );
         */
        "bSortCellsTop": false,

        /**
         * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
         * `sorting\_3` to the columns which are currently being sorted on. This is
         * presented as a feature switch as it can increase processing time (while
         * classes are removed and added) so for large data sets you might want to
         * turn this off.
         *  @type boolean
         *  @default true
         *
         *  @dtopt Features
         *  @name DataTable.defaults.orderClasses
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "orderClasses": false
         *      } );
         *    } );
         */
        "bSortClasses": true,

        /**
         * Enable or disable state saving. When enabled HTML5 `localStorage` will be
         * used to save table display information such as pagination information,
         * display length, filtering and sorting. As such when the end user reloads
         * the page the display display will match what thy had previously set up.
         *
         * Due to the use of `localStorage` the default state saving is not supported
         * in IE6 or 7. If state saving is required in those browsers, use
         * `stateSaveCallback` to provide a storage solution such as cookies.
         *  @type boolean
         *  @default false
         *
         *  @dtopt Features
         *  @name DataTable.defaults.stateSave
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "stateSave": true
         *      } );
         *    } );
         */
        "bStateSave": false,

        /**
         * This function is called when a TR element is created (and all TD child
         * elements have been inserted), or registered if using a DOM source, allowing
         * manipulation of the TR element (adding classes etc).
         *  @type function
         *  @param {node} row "TR" element for the current row
         *  @param {array} data Raw data array for this row
         *  @param {int} dataIndex The index of this row in the internal aoData array
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.createdRow
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "createdRow": function( row, data, dataIndex ) {
         *          // Bold the grade for all 'A' grade browsers
         *          if ( data[4] == "A" )
         *          {
         *            $('td:eq(4)', row).html( '<b>A</b>' );
         *          }
         *        }
         *      } );
         *    } );
         */
        "fnCreatedRow": null,

        /**
         * This function is called on every 'draw' event, and allows you to
         * dynamically modify any aspect you want about the created DOM.
         *  @type function
         *  @param {object} settings DataTables settings object
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.drawCallback
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "drawCallback": function( settings ) {
         *          alert( 'DataTables has redrawn the table' );
         *        }
         *      } );
         *    } );
         */
        "fnDrawCallback": null,

        /**
         * Identical to fnHeaderCallback() but for the table footer this function
         * allows you to modify the table footer on every 'draw' event.
         *  @type function
         *  @param {node} foot "TR" element for the footer
         *  @param {array} data Full table data (as derived from the original HTML)
         *  @param {int} start Index for the current display starting point in the
         *    display array
         *  @param {int} end Index for the current display ending point in the
         *    display array
         *  @param {array int} display Index array to translate the visual position
         *    to the full data array
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.footerCallback
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "footerCallback": function( tfoot, data, start, end, display ) {
         *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
         *        }
         *      } );
         *    } )
         */
        "fnFooterCallback": null,

        /**
         * When rendering large numbers in the information element for the table
         * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
         * to have a comma separator for the 'thousands' units (e.g. 1 million is
         * rendered as "1,000,000") to help readability for the end user. This
         * function will override the default method DataTables uses.
         *  @type function
         *  @member
         *  @param {int} toFormat number to be formatted
         *  @returns {string} formatted string for DataTables to show the number
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.formatNumber
         *
         *  @example
         *    // Format a number using a single quote for the separator (note that
         *    // this can also be done with the language.thousands option)
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "formatNumber": function ( toFormat ) {
         *          return toFormat.toString().replace(
         *            /\B(?=(\d{3})+(?!\d))/g, "'"
         *          );
         *        };
         *      } );
         *    } );
         */
        "fnFormatNumber": function fnFormatNumber(toFormat) {
          return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
        },

        /**
         * This function is called on every 'draw' event, and allows you to
         * dynamically modify the header row. This can be used to calculate and
         * display useful information about the table.
         *  @type function
         *  @param {node} head "TR" element for the header
         *  @param {array} data Full table data (as derived from the original HTML)
         *  @param {int} start Index for the current display starting point in the
         *    display array
         *  @param {int} end Index for the current display ending point in the
         *    display array
         *  @param {array int} display Index array to translate the visual position
         *    to the full data array
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.headerCallback
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fheaderCallback": function( head, data, start, end, display ) {
         *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
         *        }
         *      } );
         *    } )
         */
        "fnHeaderCallback": null,

        /**
         * The information element can be used to convey information about the current
         * state of the table. Although the internationalisation options presented by
         * DataTables are quite capable of dealing with most customisations, there may
         * be times where you wish to customise the string further. This callback
         * allows you to do exactly that.
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @param {int} start Starting position in data for the draw
         *  @param {int} end End position in data for the draw
         *  @param {int} max Total number of rows in the table (regardless of
         *    filtering)
         *  @param {int} total Total number of rows in the data set, after filtering
         *  @param {string} pre The string that DataTables has formatted using it's
         *    own rules
         *  @returns {string} The string to be displayed in the information element.
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.infoCallback
         *
         *  @example
         *    $('#example').dataTable( {
         *      "infoCallback": function( settings, start, end, max, total, pre ) {
         *        return start +" to "+ end;
         *      }
         *    } );
         */
        "fnInfoCallback": null,

        /**
         * Called when the table has been initialised. Normally DataTables will
         * initialise sequentially and there will be no need for this function,
         * however, this does not hold true when using external language information
         * since that is obtained using an async XHR call.
         *  @type function
         *  @param {object} settings DataTables settings object
         *  @param {object} json The JSON object request from the server - only
         *    present if client-side Ajax sourced data is used
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.initComplete
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "initComplete": function(settings, json) {
         *          alert( 'DataTables has finished its initialisation.' );
         *        }
         *      } );
         *    } )
         */
        "fnInitComplete": null,

        /**
         * Called at the very start of each table draw and can be used to cancel the
         * draw by returning false, any other return (including undefined) results in
         * the full draw occurring).
         *  @type function
         *  @param {object} settings DataTables settings object
         *  @returns {boolean} False will cancel the draw, anything else (including no
         *    return) will allow it to complete.
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.preDrawCallback
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "preDrawCallback": function( settings ) {
         *          if ( $('#test').val() == 1 ) {
         *            return false;
         *          }
         *        }
         *      } );
         *    } );
         */
        "fnPreDrawCallback": null,

        /**
         * This function allows you to 'post process' each row after it have been
         * generated for each table draw, but before it is rendered on screen. This
         * function might be used for setting the row class name etc.
         *  @type function
         *  @param {node} row "TR" element for the current row
         *  @param {array} data Raw data array for this row
         *  @param {int} displayIndex The display index for the current table draw
         *  @param {int} displayIndexFull The index of the data in the full list of
         *    rows (after filtering)
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.rowCallback
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
         *          // Bold the grade for all 'A' grade browsers
         *          if ( data[4] == "A" ) {
         *            $('td:eq(4)', row).html( '<b>A</b>' );
         *          }
         *        }
         *      } );
         *    } );
         */
        "fnRowCallback": null,

        /**
         * __Deprecated__ The functionality provided by this parameter has now been
         * superseded by that provided through `ajax`, which should be used instead.
         *
         * This parameter allows you to override the default function which obtains
         * the data from the server so something more suitable for your application.
         * For example you could use POST data, or pull information from a Gears or
         * AIR database.
         *  @type function
         *  @member
         *  @param {string} source HTTP source to obtain the data from (`ajax`)
         *  @param {array} data A key/value pair object containing the data to send
         *    to the server
         *  @param {function} callback to be called on completion of the data get
         *    process that will draw the data on the page.
         *  @param {object} settings DataTables settings object
         *
         *  @dtopt Callbacks
         *  @dtopt Server-side
         *  @name DataTable.defaults.serverData
         *
         *  @deprecated 1.10. Please use `ajax` for this functionality now.
         */
        "fnServerData": null,

        /**
         * __Deprecated__ The functionality provided by this parameter has now been
         * superseded by that provided through `ajax`, which should be used instead.
         *
         *  It is often useful to send extra data to the server when making an Ajax
         * request - for example custom filtering information, and this callback
         * function makes it trivial to send extra information to the server. The
         * passed in parameter is the data set that has been constructed by
         * DataTables, and you can add to this or modify it as you require.
         *  @type function
         *  @param {array} data Data array (array of objects which are name/value
         *    pairs) that has been constructed by DataTables and will be sent to the
         *    server. In the case of Ajax sourced data with server-side processing
         *    this will be an empty array, for server-side processing there will be a
         *    significant number of parameters!
         *  @returns {undefined} Ensure that you modify the data array passed in,
         *    as this is passed by reference.
         *
         *  @dtopt Callbacks
         *  @dtopt Server-side
         *  @name DataTable.defaults.serverParams
         *
         *  @deprecated 1.10. Please use `ajax` for this functionality now.
         */
        "fnServerParams": null,

        /**
         * Load the table state. With this function you can define from where, and how, the
         * state of a table is loaded. By default DataTables will load from `localStorage`
         * but you might wish to use a server-side database or cookies.
         *  @type function
         *  @member
         *  @param {object} settings DataTables settings object
         *  @param {object} callback Callback that can be executed when done. It
         *    should be passed the loaded state object.
         *  @return {object} The DataTables state object to be loaded
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.stateLoadCallback
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stateSave": true,
         *        "stateLoadCallback": function (settings, callback) {
         *          $.ajax( {
         *            "url": "/state_load",
         *            "dataType": "json",
         *            "success": function (json) {
         *              callback( json );
         *            }
         *          } );
         *        }
         *      } );
         *    } );
         */
        "fnStateLoadCallback": function fnStateLoadCallback(settings) {
          try {
            return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem('DataTables_' + settings.sInstance + '_' + location.pathname));
          } catch (e) {
            return {};
          }
        },

        /**
         * Callback which allows modification of the saved state prior to loading that state.
         * This callback is called when the table is loading state from the stored data, but
         * prior to the settings object being modified by the saved state. Note that for
         * plug-in authors, you should use the `stateLoadParams` event to load parameters for
         * a plug-in.
         *  @type function
         *  @param {object} settings DataTables settings object
         *  @param {object} data The state object that is to be loaded
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.stateLoadParams
         *
         *  @example
         *    // Remove a saved filter, so filtering is never loaded
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stateSave": true,
         *        "stateLoadParams": function (settings, data) {
         *          data.oSearch.sSearch = "";
         *        }
         *      } );
         *    } );
         *
         *  @example
         *    // Disallow state loading by returning false
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stateSave": true,
         *        "stateLoadParams": function (settings, data) {
         *          return false;
         *        }
         *      } );
         *    } );
         */
        "fnStateLoadParams": null,

        /**
         * Callback that is called when the state has been loaded from the state saving method
         * and the DataTables settings object has been modified as a result of the loaded state.
         *  @type function
         *  @param {object} settings DataTables settings object
         *  @param {object} data The state object that was loaded
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.stateLoaded
         *
         *  @example
         *    // Show an alert with the filtering value that was saved
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stateSave": true,
         *        "stateLoaded": function (settings, data) {
         *          alert( 'Saved filter was: '+data.oSearch.sSearch );
         *        }
         *      } );
         *    } );
         */
        "fnStateLoaded": null,

        /**
         * Save the table state. This function allows you to define where and how the state
         * information for the table is stored By default DataTables will use `localStorage`
         * but you might wish to use a server-side database or cookies.
         *  @type function
         *  @member
         *  @param {object} settings DataTables settings object
         *  @param {object} data The state object to be saved
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.stateSaveCallback
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stateSave": true,
         *        "stateSaveCallback": function (settings, data) {
         *          // Send an Ajax request to the server with the state object
         *          $.ajax( {
         *            "url": "/state_save",
         *            "data": data,
         *            "dataType": "json",
         *            "method": "POST"
         *            "success": function () {}
         *          } );
         *        }
         *      } );
         *    } );
         */
        "fnStateSaveCallback": function fnStateSaveCallback(settings, data) {
          try {
            (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem('DataTables_' + settings.sInstance + '_' + location.pathname, JSON.stringify(data));
          } catch (e) {}
        },

        /**
         * Callback which allows modification of the state to be saved. Called when the table
         * has changed state a new state save is required. This method allows modification of
         * the state saving object prior to actually doing the save, including addition or
         * other state properties or modification. Note that for plug-in authors, you should
         * use the `stateSaveParams` event to save parameters for a plug-in.
         *  @type function
         *  @param {object} settings DataTables settings object
         *  @param {object} data The state object to be saved
         *
         *  @dtopt Callbacks
         *  @name DataTable.defaults.stateSaveParams
         *
         *  @example
         *    // Remove a saved filter, so filtering is never saved
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stateSave": true,
         *        "stateSaveParams": function (settings, data) {
         *          data.oSearch.sSearch = "";
         *        }
         *      } );
         *    } );
         */
        "fnStateSaveParams": null,

        /**
         * Duration for which the saved state information is considered valid. After this period
         * has elapsed the state will be returned to the default.
         * Value is given in seconds.
         *  @type int
         *  @default 7200 <i>(2 hours)</i>
         *
         *  @dtopt Options
         *  @name DataTable.defaults.stateDuration
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "stateDuration": 60*60*24; // 1 day
         *      } );
         *    } )
         */
        "iStateDuration": 7200,

        /**
         * When enabled DataTables will not make a request to the server for the first
         * page draw - rather it will use the data already on the page (no sorting etc
         * will be applied to it), thus saving on an XHR at load time. `deferLoading`
         * is used to indicate that deferred loading is required, but it is also used
         * to tell DataTables how many records there are in the full table (allowing
         * the information element and pagination to be displayed correctly). In the case
         * where a filtering is applied to the table on initial load, this can be
         * indicated by giving the parameter as an array, where the first element is
         * the number of records available after filtering and the second element is the
         * number of records without filtering (allowing the table information element
         * to be shown correctly).
         *  @type int | array
         *  @default null
         *
         *  @dtopt Options
         *  @name DataTable.defaults.deferLoading
         *
         *  @example
         *    // 57 records available in the table, no filtering applied
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "serverSide": true,
         *        "ajax": "scripts/server_processing.php",
         *        "deferLoading": 57
         *      } );
         *    } );
         *
         *  @example
         *    // 57 records after filtering, 100 without filtering (an initial filter applied)
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "serverSide": true,
         *        "ajax": "scripts/server_processing.php",
         *        "deferLoading": [ 57, 100 ],
         *        "search": {
         *          "search": "my_filter"
         *        }
         *      } );
         *    } );
         */
        "iDeferLoading": null,

        /**
         * Number of rows to display on a single page when using pagination. If
         * feature enabled (`lengthChange`) then the end user will be able to override
         * this to a custom setting using a pop-up menu.
         *  @type int
         *  @default 10
         *
         *  @dtopt Options
         *  @name DataTable.defaults.pageLength
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "pageLength": 50
         *      } );
         *    } )
         */
        "iDisplayLength": 10,

        /**
         * Define the starting point for data display when using DataTables with
         * pagination. Note that this parameter is the number of records, rather than
         * the page number, so if you have 10 records per page and want to start on
         * the third page, it should be "20".
         *  @type int
         *  @default 0
         *
         *  @dtopt Options
         *  @name DataTable.defaults.displayStart
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "displayStart": 20
         *      } );
         *    } )
         */
        "iDisplayStart": 0,

        /**
         * By default DataTables allows keyboard navigation of the table (sorting, paging,
         * and filtering) by adding a `tabindex` attribute to the required elements. This
         * allows you to tab through the controls and press the enter key to activate them.
         * The tabindex is default 0, meaning that the tab follows the flow of the document.
         * You can overrule this using this parameter if you wish. Use a value of -1 to
         * disable built-in keyboard navigation.
         *  @type int
         *  @default 0
         *
         *  @dtopt Options
         *  @name DataTable.defaults.tabIndex
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "tabIndex": 1
         *      } );
         *    } );
         */
        "iTabIndex": 0,

        /**
         * Classes that DataTables assigns to the various components and features
         * that it adds to the HTML table. This allows classes to be configured
         * during initialisation in addition to through the static
         * {@link DataTable.ext.oStdClasses} object).
         *  @namespace
         *  @name DataTable.defaults.classes
         */
        "oClasses": {},

        /**
         * All strings that DataTables uses in the user interface that it creates
         * are defined in this object, allowing you to modified them individually or
         * completely replace them all as required.
         *  @namespace
         *  @name DataTable.defaults.language
         */
        "oLanguage": {
          /**
           * Strings that are used for WAI-ARIA labels and controls only (these are not
           * actually visible on the page, but will be read by screenreaders, and thus
           * must be internationalised as well).
           *  @namespace
           *  @name DataTable.defaults.language.aria
           */
          "oAria": {
            /**
             * ARIA label that is added to the table headers when the column may be
             * sorted ascending by activing the column (click or return when focused).
             * Note that the column header is prefixed to this string.
             *  @type string
             *  @default : activate to sort column ascending
             *
             *  @dtopt Language
             *  @name DataTable.defaults.language.aria.sortAscending
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "language": {
             *          "aria": {
             *            "sortAscending": " - click/return to sort ascending"
             *          }
             *        }
             *      } );
             *    } );
             */
            "sSortAscending": ": activate to sort column ascending",

            /**
             * ARIA label that is added to the table headers when the column may be
             * sorted descending by activing the column (click or return when focused).
             * Note that the column header is prefixed to this string.
             *  @type string
             *  @default : activate to sort column ascending
             *
             *  @dtopt Language
             *  @name DataTable.defaults.language.aria.sortDescending
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "language": {
             *          "aria": {
             *            "sortDescending": " - click/return to sort descending"
             *          }
             *        }
             *      } );
             *    } );
             */
            "sSortDescending": ": activate to sort column descending"
          },

          /**
           * Pagination string used by DataTables for the built-in pagination
           * control types.
           *  @namespace
           *  @name DataTable.defaults.language.paginate
           */
          "oPaginate": {
            /**
             * Text to use when using the 'full_numbers' type of pagination for the
             * button to take the user to the first page.
             *  @type string
             *  @default First
             *
             *  @dtopt Language
             *  @name DataTable.defaults.language.paginate.first
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "language": {
             *          "paginate": {
             *            "first": "First page"
             *          }
             *        }
             *      } );
             *    } );
             */
            "sFirst": "First",

            /**
             * Text to use when using the 'full_numbers' type of pagination for the
             * button to take the user to the last page.
             *  @type string
             *  @default Last
             *
             *  @dtopt Language
             *  @name DataTable.defaults.language.paginate.last
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "language": {
             *          "paginate": {
             *            "last": "Last page"
             *          }
             *        }
             *      } );
             *    } );
             */
            "sLast": "Last",

            /**
             * Text to use for the 'next' pagination button (to take the user to the
             * next page).
             *  @type string
             *  @default Next
             *
             *  @dtopt Language
             *  @name DataTable.defaults.language.paginate.next
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "language": {
             *          "paginate": {
             *            "next": "Next page"
             *          }
             *        }
             *      } );
             *    } );
             */
            "sNext": "Next",

            /**
             * Text to use for the 'previous' pagination button (to take the user to
             * the previous page).
             *  @type string
             *  @default Previous
             *
             *  @dtopt Language
             *  @name DataTable.defaults.language.paginate.previous
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "language": {
             *          "paginate": {
             *            "previous": "Previous page"
             *          }
             *        }
             *      } );
             *    } );
             */
            "sPrevious": "Previous"
          },

          /**
           * This string is shown in preference to `zeroRecords` when the table is
           * empty of data (regardless of filtering). Note that this is an optional
           * parameter - if it is not given, the value of `zeroRecords` will be used
           * instead (either the default or given value).
           *  @type string
           *  @default No data available in table
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.emptyTable
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "emptyTable": "No data available in table"
           *        }
           *      } );
           *    } );
           */
          "sEmptyTable": "No data available in table",

          /**
           * This string gives information to the end user about the information
           * that is current on display on the page. The following tokens can be
           * used in the string and will be dynamically replaced as the table
           * display updates. This tokens can be placed anywhere in the string, or
           * removed as needed by the language requires:
           *
           * * `\_START\_` - Display index of the first record on the current page
           * * `\_END\_` - Display index of the last record on the current page
           * * `\_TOTAL\_` - Number of records in the table after filtering
           * * `\_MAX\_` - Number of records in the table without filtering
           * * `\_PAGE\_` - Current page number
           * * `\_PAGES\_` - Total number of pages of data in the table
           *
           *  @type string
           *  @default Showing _START_ to _END_ of _TOTAL_ entries
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.info
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "info": "Showing page _PAGE_ of _PAGES_"
           *        }
           *      } );
           *    } );
           */
          "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",

          /**
           * Display information string for when the table is empty. Typically the
           * format of this string should match `info`.
           *  @type string
           *  @default Showing 0 to 0 of 0 entries
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.infoEmpty
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "infoEmpty": "No entries to show"
           *        }
           *      } );
           *    } );
           */
          "sInfoEmpty": "Showing 0 to 0 of 0 entries",

          /**
           * When a user filters the information in a table, this string is appended
           * to the information (`info`) to give an idea of how strong the filtering
           * is. The variable _MAX_ is dynamically updated.
           *  @type string
           *  @default (filtered from _MAX_ total entries)
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.infoFiltered
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "infoFiltered": " - filtering from _MAX_ records"
           *        }
           *      } );
           *    } );
           */
          "sInfoFiltered": "(filtered from _MAX_ total entries)",

          /**
           * If can be useful to append extra information to the info string at times,
           * and this variable does exactly that. This information will be appended to
           * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
           * being used) at all times.
           *  @type string
           *  @default <i>Empty string</i>
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.infoPostFix
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "infoPostFix": "All records shown are derived from real information."
           *        }
           *      } );
           *    } );
           */
          "sInfoPostFix": "",

          /**
           * This decimal place operator is a little different from the other
           * language options since DataTables doesn't output floating point
           * numbers, so it won't ever use this for display of a number. Rather,
           * what this parameter does is modify the sort methods of the table so
           * that numbers which are in a format which has a character other than
           * a period (`.`) as a decimal place will be sorted numerically.
           *
           * Note that numbers with different decimal places cannot be shown in
           * the same table and still be sortable, the table must be consistent.
           * However, multiple different tables on the page can use different
           * decimal place characters.
           *  @type string
           *  @default 
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.decimal
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "decimal": ","
           *          "thousands": "."
           *        }
           *      } );
           *    } );
           */
          "sDecimal": "",

          /**
           * DataTables has a build in number formatter (`formatNumber`) which is
           * used to format large numbers that are used in the table information.
           * By default a comma is used, but this can be trivially changed to any
           * character you wish with this parameter.
           *  @type string
           *  @default ,
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.thousands
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "thousands": "'"
           *        }
           *      } );
           *    } );
           */
          "sThousands": ",",

          /**
           * Detail the action that will be taken when the drop down menu for the
           * pagination length option is changed. The '_MENU_' variable is replaced
           * with a default select list of 10, 25, 50 and 100, and can be replaced
           * with a custom select box if required.
           *  @type string
           *  @default Show _MENU_ entries
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.lengthMenu
           *
           *  @example
           *    // Language change only
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "lengthMenu": "Display _MENU_ records"
           *        }
           *      } );
           *    } );
           *
           *  @example
           *    // Language and options change
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "lengthMenu": 'Display <select>'+
           *            '<option value="10">10</option>'+
           *            '<option value="20">20</option>'+
           *            '<option value="30">30</option>'+
           *            '<option value="40">40</option>'+
           *            '<option value="50">50</option>'+
           *            '<option value="-1">All</option>'+
           *            '</select> records'
           *        }
           *      } );
           *    } );
           */
          "sLengthMenu": "Show _MENU_ entries",

          /**
           * When using Ajax sourced data and during the first draw when DataTables is
           * gathering the data, this message is shown in an empty row in the table to
           * indicate to the end user the the data is being loaded. Note that this
           * parameter is not used when loading data by server-side processing, just
           * Ajax sourced data with client-side processing.
           *  @type string
           *  @default Loading...
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.loadingRecords
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "loadingRecords": "Please wait - loading..."
           *        }
           *      } );
           *    } );
           */
          "sLoadingRecords": "Loading...",

          /**
           * Text which is displayed when the table is processing a user action
           * (usually a sort command or similar).
           *  @type string
           *  @default Processing...
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.processing
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "processing": "DataTables is currently busy"
           *        }
           *      } );
           *    } );
           */
          "sProcessing": "Processing...",

          /**
           * Details the actions that will be taken when the user types into the
           * filtering input text box. The variable "_INPUT_", if used in the string,
           * is replaced with the HTML text box for the filtering input allowing
           * control over where it appears in the string. If "_INPUT_" is not given
           * then the input box is appended to the string automatically.
           *  @type string
           *  @default Search:
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.search
           *
           *  @example
           *    // Input text box will be appended at the end automatically
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "search": "Filter records:"
           *        }
           *      } );
           *    } );
           *
           *  @example
           *    // Specify where the filter should appear
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "search": "Apply filter _INPUT_ to table"
           *        }
           *      } );
           *    } );
           */
          "sSearch": "Search:",

          /**
           * Assign a `placeholder` attribute to the search `input` element
           *  @type string
           *  @default 
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.searchPlaceholder
           */
          "sSearchPlaceholder": "",

          /**
           * All of the language information can be stored in a file on the
           * server-side, which DataTables will look up if this parameter is passed.
           * It must store the URL of the language file, which is in a JSON format,
           * and the object has the same properties as the oLanguage object in the
           * initialiser object (i.e. the above parameters). Please refer to one of
           * the example language files to see how this works in action.
           *  @type string
           *  @default <i>Empty string - i.e. disabled</i>
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.url
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
           *        }
           *      } );
           *    } );
           */
          "sUrl": "",

          /**
           * Text shown inside the table records when the is no information to be
           * displayed after filtering. `emptyTable` is shown when there is simply no
           * information in the table at all (regardless of filtering).
           *  @type string
           *  @default No matching records found
           *
           *  @dtopt Language
           *  @name DataTable.defaults.language.zeroRecords
           *
           *  @example
           *    $(document).ready( function() {
           *      $('#example').dataTable( {
           *        "language": {
           *          "zeroRecords": "No records to display"
           *        }
           *      } );
           *    } );
           */
          "sZeroRecords": "No matching records found"
        },

        /**
         * This parameter allows you to have define the global filtering state at
         * initialisation time. As an object the `search` parameter must be
         * defined, but all other parameters are optional. When `regex` is true,
         * the search string will be treated as a regular expression, when false
         * (default) it will be treated as a straight string. When `smart`
         * DataTables will use it's smart filtering methods (to word match at
         * any point in the data), when false this will not be done.
         *  @namespace
         *  @extends DataTable.models.oSearch
         *
         *  @dtopt Options
         *  @name DataTable.defaults.search
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "search": {"search": "Initial search"}
         *      } );
         *    } )
         */
        "oSearch": $.extend({}, DataTable.models.oSearch),

        /**
         * __Deprecated__ The functionality provided by this parameter has now been
         * superseded by that provided through `ajax`, which should be used instead.
         *
         * By default DataTables will look for the property `data` (or `aaData` for
         * compatibility with DataTables 1.9-) when obtaining data from an Ajax
         * source or for server-side processing - this parameter allows that
         * property to be changed. You can use Javascript dotted object notation to
         * get a data source for multiple levels of nesting.
         *  @type string
         *  @default data
         *
         *  @dtopt Options
         *  @dtopt Server-side
         *  @name DataTable.defaults.ajaxDataProp
         *
         *  @deprecated 1.10. Please use `ajax` for this functionality now.
         */
        "sAjaxDataProp": "data",

        /**
         * __Deprecated__ The functionality provided by this parameter has now been
         * superseded by that provided through `ajax`, which should be used instead.
         *
         * You can instruct DataTables to load data from an external
         * source using this parameter (use aData if you want to pass data in you
         * already have). Simply provide a url a JSON object can be obtained from.
         *  @type string
         *  @default null
         *
         *  @dtopt Options
         *  @dtopt Server-side
         *  @name DataTable.defaults.ajaxSource
         *
         *  @deprecated 1.10. Please use `ajax` for this functionality now.
         */
        "sAjaxSource": null,

        /**
         * This initialisation variable allows you to specify exactly where in the
         * DOM you want DataTables to inject the various controls it adds to the page
         * (for example you might want the pagination controls at the top of the
         * table). DIV elements (with or without a custom class) can also be added to
         * aid styling. The follow syntax is used:
         *   <ul>
         *     <li>The following options are allowed:
         *       <ul>
         *         <li>'l' - Length changing</li>
         *         <li>'f' - Filtering input</li>
         *         <li>'t' - The table!</li>
         *         <li>'i' - Information</li>
         *         <li>'p' - Pagination</li>
         *         <li>'r' - pRocessing</li>
         *       </ul>
         *     </li>
         *     <li>The following constants are allowed:
         *       <ul>
         *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
         *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
         *       </ul>
         *     </li>
         *     <li>The following syntax is expected:
         *       <ul>
         *         <li>'&lt;' and '&gt;' - div elements</li>
         *         <li>'&lt;"class" and '&gt;' - div with a class</li>
         *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
         *       </ul>
         *     </li>
         *     <li>Examples:
         *       <ul>
         *         <li>'&lt;"wrapper"flipt&gt;'</li>
         *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
         *       </ul>
         *     </li>
         *   </ul>
         *  @type string
         *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
         *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
         *
         *  @dtopt Options
         *  @name DataTable.defaults.dom
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
         *      } );
         *    } );
         */
        "sDom": "lfrtip",

        /**
         * Search delay option. This will throttle full table searches that use the
         * DataTables provided search input element (it does not effect calls to
         * `dt-api search()`, providing a delay before the search is made.
         *  @type integer
         *  @default 0
         *
         *  @dtopt Options
         *  @name DataTable.defaults.searchDelay
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "searchDelay": 200
         *      } );
         *    } )
         */
        "searchDelay": null,

        /**
         * DataTables features six different built-in options for the buttons to
         * display for pagination control:
         *
         * * `numbers` - Page number buttons only
         * * `simple` - 'Previous' and 'Next' buttons only
         * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
         * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
         * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
         * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
         *  
         * Further methods can be added using {@link DataTable.ext.oPagination}.
         *  @type string
         *  @default simple_numbers
         *
         *  @dtopt Options
         *  @name DataTable.defaults.pagingType
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "pagingType": "full_numbers"
         *      } );
         *    } )
         */
        "sPaginationType": "simple_numbers",

        /**
         * Enable horizontal scrolling. When a table is too wide to fit into a
         * certain layout, or you have a large number of columns in the table, you
         * can enable x-scrolling to show the table in a viewport, which can be
         * scrolled. This property can be `true` which will allow the table to
         * scroll horizontally when needed, or any CSS unit, or a number (in which
         * case it will be treated as a pixel measurement). Setting as simply `true`
         * is recommended.
         *  @type boolean|string
         *  @default <i>blank string - i.e. disabled</i>
         *
         *  @dtopt Features
         *  @name DataTable.defaults.scrollX
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "scrollX": true,
         *        "scrollCollapse": true
         *      } );
         *    } );
         */
        "sScrollX": "",

        /**
         * This property can be used to force a DataTable to use more width than it
         * might otherwise do when x-scrolling is enabled. For example if you have a
         * table which requires to be well spaced, this parameter is useful for
         * "over-sizing" the table, and thus forcing scrolling. This property can by
         * any CSS unit, or a number (in which case it will be treated as a pixel
         * measurement).
         *  @type string
         *  @default <i>blank string - i.e. disabled</i>
         *
         *  @dtopt Options
         *  @name DataTable.defaults.scrollXInner
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "scrollX": "100%",
         *        "scrollXInner": "110%"
         *      } );
         *    } );
         */
        "sScrollXInner": "",

        /**
         * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
         * to the given height, and enable scrolling for any data which overflows the
         * current viewport. This can be used as an alternative to paging to display
         * a lot of data in a small area (although paging and scrolling can both be
         * enabled at the same time). This property can be any CSS unit, or a number
         * (in which case it will be treated as a pixel measurement).
         *  @type string
         *  @default <i>blank string - i.e. disabled</i>
         *
         *  @dtopt Features
         *  @name DataTable.defaults.scrollY
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "scrollY": "200px",
         *        "paginate": false
         *      } );
         *    } );
         */
        "sScrollY": "",

        /**
         * __Deprecated__ The functionality provided by this parameter has now been
         * superseded by that provided through `ajax`, which should be used instead.
         *
         * Set the HTTP method that is used to make the Ajax call for server-side
         * processing or Ajax sourced data.
         *  @type string
         *  @default GET
         *
         *  @dtopt Options
         *  @dtopt Server-side
         *  @name DataTable.defaults.serverMethod
         *
         *  @deprecated 1.10. Please use `ajax` for this functionality now.
         */
        "sServerMethod": "GET",

        /**
         * DataTables makes use of renderers when displaying HTML elements for
         * a table. These renderers can be added or modified by plug-ins to
         * generate suitable mark-up for a site. For example the Bootstrap
         * integration plug-in for DataTables uses a paging button renderer to
         * display pagination buttons in the mark-up required by Bootstrap.
         *
         * For further information about the renderers available see
         * DataTable.ext.renderer
         *  @type string|object
         *  @default null
         *
         *  @name DataTable.defaults.renderer
         *
         */
        "renderer": null,

        /**
         * Set the data property name that DataTables should use to get a row's id
         * to set as the `id` property in the node.
         *  @type string
         *  @default DT_RowId
         *
         *  @name DataTable.defaults.rowId
         */
        "rowId": "DT_RowId"
      };

      _fnHungarianMap(DataTable.defaults);
      /*
       * Developer note - See note in model.defaults.js about the use of Hungarian
       * notation and camel case.
       */

      /**
       * Column options that can be given to DataTables at initialisation time.
       *  @namespace
       */


      DataTable.defaults.column = {
        /**
         * Define which column(s) an order will occur on for this column. This
         * allows a column's ordering to take multiple columns into account when
         * doing a sort or use the data from a different column. For example first
         * name / last name columns make sense to do a multi-column sort over the
         * two columns.
         *  @type array|int
         *  @default null <i>Takes the value of the column index automatically</i>
         *
         *  @name DataTable.defaults.column.orderData
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
         *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
         *          { "orderData": 2, "targets": [ 2 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "orderData": [ 0, 1 ] },
         *          { "orderData": [ 1, 0 ] },
         *          { "orderData": 2 },
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "aDataSort": null,
        "iDataSort": -1,

        /**
         * You can control the default ordering direction, and even alter the
         * behaviour of the sort handler (i.e. only allow ascending ordering etc)
         * using this parameter.
         *  @type array
         *  @default [ 'asc', 'desc' ]
         *
         *  @name DataTable.defaults.column.orderSequence
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
         *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
         *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          null,
         *          { "orderSequence": [ "asc" ] },
         *          { "orderSequence": [ "desc", "asc", "asc" ] },
         *          { "orderSequence": [ "desc" ] },
         *          null
         *        ]
         *      } );
         *    } );
         */
        "asSorting": ['asc', 'desc'],

        /**
         * Enable or disable filtering on the data in this column.
         *  @type boolean
         *  @default true
         *
         *  @name DataTable.defaults.column.searchable
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "searchable": false, "targets": [ 0 ] }
         *        ] } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "searchable": false },
         *          null,
         *          null,
         *          null,
         *          null
         *        ] } );
         *    } );
         */
        "bSearchable": true,

        /**
         * Enable or disable ordering on this column.
         *  @type boolean
         *  @default true
         *
         *  @name DataTable.defaults.column.orderable
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "orderable": false, "targets": [ 0 ] }
         *        ] } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "orderable": false },
         *          null,
         *          null,
         *          null,
         *          null
         *        ] } );
         *    } );
         */
        "bSortable": true,

        /**
         * Enable or disable the display of this column.
         *  @type boolean
         *  @default true
         *
         *  @name DataTable.defaults.column.visible
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "visible": false, "targets": [ 0 ] }
         *        ] } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "visible": false },
         *          null,
         *          null,
         *          null,
         *          null
         *        ] } );
         *    } );
         */
        "bVisible": true,

        /**
         * Developer definable function that is called whenever a cell is created (Ajax source,
         * etc) or processed for input (DOM source). This can be used as a compliment to mRender
         * allowing you to modify the DOM element (add background colour for example) when the
         * element is available.
         *  @type function
         *  @param {element} td The TD node that has been created
         *  @param {*} cellData The Data for the cell
         *  @param {array|object} rowData The data for the whole row
         *  @param {int} row The row index for the aoData data store
         *  @param {int} col The column index for aoColumns
         *
         *  @name DataTable.defaults.column.createdCell
         *  @dtopt Columns
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [3],
         *          "createdCell": function (td, cellData, rowData, row, col) {
         *            if ( cellData == "1.7" ) {
         *              $(td).css('color', 'blue')
         *            }
         *          }
         *        } ]
         *      });
         *    } );
         */
        "fnCreatedCell": null,

        /**
         * This parameter has been replaced by `data` in DataTables to ensure naming
         * consistency. `dataProp` can still be used, as there is backwards
         * compatibility in DataTables for this option, but it is strongly
         * recommended that you use `data` in preference to `dataProp`.
         *  @name DataTable.defaults.column.dataProp
         */

        /**
         * This property can be used to read data from any data source property,
         * including deeply nested objects / properties. `data` can be given in a
         * number of different ways which effect its behaviour:
         *
         * * `integer` - treated as an array index for the data source. This is the
         *   default that DataTables uses (incrementally increased for each column).
         * * `string` - read an object property from the data source. There are
         *   three 'special' options that can be used in the string to alter how
         *   DataTables reads the data from the source object:
         *    * `.` - Dotted Javascript notation. Just as you use a `.` in
         *      Javascript to read from nested objects, so to can the options
         *      specified in `data`. For example: `browser.version` or
         *      `browser.name`. If your object parameter name contains a period, use
         *      `\\` to escape it - i.e. `first\\.name`.
         *    * `[]` - Array notation. DataTables can automatically combine data
         *      from and array source, joining the data with the characters provided
         *      between the two brackets. For example: `name[, ]` would provide a
         *      comma-space separated list from the source array. If no characters
         *      are provided between the brackets, the original array source is
         *      returned.
         *    * `()` - Function notation. Adding `()` to the end of a parameter will
         *      execute a function of the name given. For example: `browser()` for a
         *      simple function on the data source, `browser.version()` for a
         *      function in a nested property or even `browser().version` to get an
         *      object property if the function called returns an object. Note that
         *      function notation is recommended for use in `render` rather than
         *      `data` as it is much simpler to use as a renderer.
         * * `null` - use the original data source for the row rather than plucking
         *   data directly from it. This action has effects on two other
         *   initialisation options:
         *    * `defaultContent` - When null is given as the `data` option and
         *      `defaultContent` is specified for the column, the value defined by
         *      `defaultContent` will be used for the cell.
         *    * `render` - When null is used for the `data` option and the `render`
         *      option is specified for the column, the whole data source for the
         *      row is used for the renderer.
         * * `function` - the function given will be executed whenever DataTables
         *   needs to set or get the data for a cell in the column. The function
         *   takes three parameters:
         *    * Parameters:
         *      * `{array|object}` The data source for the row
         *      * `{string}` The type call data requested - this will be 'set' when
         *        setting data or 'filter', 'display', 'type', 'sort' or undefined
         *        when gathering data. Note that when `undefined` is given for the
         *        type DataTables expects to get the raw data for the object back<
         *      * `{*}` Data to set when the second parameter is 'set'.
         *    * Return:
         *      * The return value from the function is not required when 'set' is
         *        the type of call, but otherwise the return is what will be used
         *        for the data requested.
         *
         * Note that `data` is a getter and setter option. If you just require
         * formatting of data for output, you will likely want to use `render` which
         * is simply a getter and thus simpler to use.
         *
         * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
         * name change reflects the flexibility of this property and is consistent
         * with the naming of mRender. If 'mDataProp' is given, then it will still
         * be used by DataTables, as it automatically maps the old name to the new
         * if required.
         *
         *  @type string|int|function|null
         *  @default null <i>Use automatically calculated column index</i>
         *
         *  @name DataTable.defaults.column.data
         *  @dtopt Columns
         *
         *  @example
         *    // Read table data from objects
         *    // JSON structure for each row:
         *    //   {
         *    //      "engine": {value},
         *    //      "browser": {value},
         *    //      "platform": {value},
         *    //      "version": {value},
         *    //      "grade": {value}
         *    //   }
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "ajaxSource": "sources/objects.txt",
         *        "columns": [
         *          { "data": "engine" },
         *          { "data": "browser" },
         *          { "data": "platform" },
         *          { "data": "version" },
         *          { "data": "grade" }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Read information from deeply nested objects
         *    // JSON structure for each row:
         *    //   {
         *    //      "engine": {value},
         *    //      "browser": {value},
         *    //      "platform": {
         *    //         "inner": {value}
         *    //      },
         *    //      "details": [
         *    //         {value}, {value}
         *    //      ]
         *    //   }
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "ajaxSource": "sources/deep.txt",
         *        "columns": [
         *          { "data": "engine" },
         *          { "data": "browser" },
         *          { "data": "platform.inner" },
         *          { "data": "details.0" },
         *          { "data": "details.1" }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `data` as a function to provide different information for
         *    // sorting, filtering and display. In this case, currency (price)
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [ 0 ],
         *          "data": function ( source, type, val ) {
         *            if (type === 'set') {
         *              source.price = val;
         *              // Store the computed dislay and filter values for efficiency
         *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
         *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
         *              return;
         *            }
         *            else if (type === 'display') {
         *              return source.price_display;
         *            }
         *            else if (type === 'filter') {
         *              return source.price_filter;
         *            }
         *            // 'sort', 'type' and undefined all just use the integer
         *            return source.price;
         *          }
         *        } ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using default content
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [ 0 ],
         *          "data": null,
         *          "defaultContent": "Click to edit"
         *        } ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using array notation - outputting a list from an array
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [ 0 ],
         *          "data": "name[, ]"
         *        } ]
         *      } );
         *    } );
         *
         */
        "mData": null,

        /**
         * This property is the rendering partner to `data` and it is suggested that
         * when you want to manipulate data for display (including filtering,
         * sorting etc) without altering the underlying data for the table, use this
         * property. `render` can be considered to be the the read only companion to
         * `data` which is read / write (then as such more complex). Like `data`
         * this option can be given in a number of different ways to effect its
         * behaviour:
         *
         * * `integer` - treated as an array index for the data source. This is the
         *   default that DataTables uses (incrementally increased for each column).
         * * `string` - read an object property from the data source. There are
         *   three 'special' options that can be used in the string to alter how
         *   DataTables reads the data from the source object:
         *    * `.` - Dotted Javascript notation. Just as you use a `.` in
         *      Javascript to read from nested objects, so to can the options
         *      specified in `data`. For example: `browser.version` or
         *      `browser.name`. If your object parameter name contains a period, use
         *      `\\` to escape it - i.e. `first\\.name`.
         *    * `[]` - Array notation. DataTables can automatically combine data
         *      from and array source, joining the data with the characters provided
         *      between the two brackets. For example: `name[, ]` would provide a
         *      comma-space separated list from the source array. If no characters
         *      are provided between the brackets, the original array source is
         *      returned.
         *    * `()` - Function notation. Adding `()` to the end of a parameter will
         *      execute a function of the name given. For example: `browser()` for a
         *      simple function on the data source, `browser.version()` for a
         *      function in a nested property or even `browser().version` to get an
         *      object property if the function called returns an object.
         * * `object` - use different data for the different data types requested by
         *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
         *   of the object is the data type the property refers to and the value can
         *   defined using an integer, string or function using the same rules as
         *   `render` normally does. Note that an `_` option _must_ be specified.
         *   This is the default value to use if you haven't specified a value for
         *   the data type requested by DataTables.
         * * `function` - the function given will be executed whenever DataTables
         *   needs to set or get the data for a cell in the column. The function
         *   takes three parameters:
         *    * Parameters:
         *      * {array|object} The data source for the row (based on `data`)
         *      * {string} The type call data requested - this will be 'filter',
         *        'display', 'type' or 'sort'.
         *      * {array|object} The full data source for the row (not based on
         *        `data`)
         *    * Return:
         *      * The return value from the function is what will be used for the
         *        data requested.
         *
         *  @type string|int|function|object|null
         *  @default null Use the data source value.
         *
         *  @name DataTable.defaults.column.render
         *  @dtopt Columns
         *
         *  @example
         *    // Create a comma separated list from an array of objects
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "ajaxSource": "sources/deep.txt",
         *        "columns": [
         *          { "data": "engine" },
         *          { "data": "browser" },
         *          {
         *            "data": "platform",
         *            "render": "[, ].name"
         *          }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Execute a function to obtain data
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [ 0 ],
         *          "data": null, // Use the full data source object for the renderer's source
         *          "render": "browserName()"
         *        } ]
         *      } );
         *    } );
         *
         *  @example
         *    // As an object, extracting different data for the different types
         *    // This would be used with a data source such as:
         *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
         *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
         *    // (which has both forms) is used for filtering for if a user inputs either format, while
         *    // the formatted phone number is the one that is shown in the table.
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [ 0 ],
         *          "data": null, // Use the full data source object for the renderer's source
         *          "render": {
         *            "_": "phone",
         *            "filter": "phone_filter",
         *            "display": "phone_display"
         *          }
         *        } ]
         *      } );
         *    } );
         *
         *  @example
         *    // Use as a function to create a link from the data source
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [ 0 ],
         *          "data": "download_link",
         *          "render": function ( data, type, full ) {
         *            return '<a href="'+data+'">Download</a>';
         *          }
         *        } ]
         *      } );
         *    } );
         */
        "mRender": null,

        /**
         * Change the cell type created for the column - either TD cells or TH cells. This
         * can be useful as TH cells have semantic meaning in the table body, allowing them
         * to act as a header for a row (you may wish to add scope='row' to the TH elements).
         *  @type string
         *  @default td
         *
         *  @name DataTable.defaults.column.cellType
         *  @dtopt Columns
         *
         *  @example
         *    // Make the first column use TH cells
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [ {
         *          "targets": [ 0 ],
         *          "cellType": "th"
         *        } ]
         *      } );
         *    } );
         */
        "sCellType": "td",

        /**
         * Class to give to each cell in this column.
         *  @type string
         *  @default <i>Empty string</i>
         *
         *  @name DataTable.defaults.column.class
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "class": "my_class", "targets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "class": "my_class" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sClass": "",

        /**
         * When DataTables calculates the column widths to assign to each column,
         * it finds the longest string in each column and then constructs a
         * temporary table and reads the widths from that. The problem with this
         * is that "mmm" is much wider then "iiii", but the latter is a longer
         * string - thus the calculation can go wrong (doing it properly and putting
         * it into an DOM object and measuring that is horribly(!) slow). Thus as
         * a "work around" we provide this option. It will append its value to the
         * text that is found to be the longest string for the column - i.e. padding.
         * Generally you shouldn't need this!
         *  @type string
         *  @default <i>Empty string<i>
         *
         *  @name DataTable.defaults.column.contentPadding
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          null,
         *          null,
         *          null,
         *          {
         *            "contentPadding": "mmm"
         *          }
         *        ]
         *      } );
         *    } );
         */
        "sContentPadding": "",

        /**
         * Allows a default value to be given for a column's data, and will be used
         * whenever a null data source is encountered (this can be because `data`
         * is set to null, or because the data source itself is null).
         *  @type string
         *  @default null
         *
         *  @name DataTable.defaults.column.defaultContent
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          {
         *            "data": null,
         *            "defaultContent": "Edit",
         *            "targets": [ -1 ]
         *          }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          null,
         *          null,
         *          null,
         *          {
         *            "data": null,
         *            "defaultContent": "Edit"
         *          }
         *        ]
         *      } );
         *    } );
         */
        "sDefaultContent": null,

        /**
         * This parameter is only used in DataTables' server-side processing. It can
         * be exceptionally useful to know what columns are being displayed on the
         * client side, and to map these to database fields. When defined, the names
         * also allow DataTables to reorder information from the server if it comes
         * back in an unexpected order (i.e. if you switch your columns around on the
         * client-side, your server-side code does not also need updating).
         *  @type string
         *  @default <i>Empty string</i>
         *
         *  @name DataTable.defaults.column.name
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "name": "engine", "targets": [ 0 ] },
         *          { "name": "browser", "targets": [ 1 ] },
         *          { "name": "platform", "targets": [ 2 ] },
         *          { "name": "version", "targets": [ 3 ] },
         *          { "name": "grade", "targets": [ 4 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "name": "engine" },
         *          { "name": "browser" },
         *          { "name": "platform" },
         *          { "name": "version" },
         *          { "name": "grade" }
         *        ]
         *      } );
         *    } );
         */
        "sName": "",

        /**
         * Defines a data source type for the ordering which can be used to read
         * real-time information from the table (updating the internally cached
         * version) prior to ordering. This allows ordering to occur on user
         * editable elements such as form inputs.
         *  @type string
         *  @default std
         *
         *  @name DataTable.defaults.column.orderDataType
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
         *          { "type": "numeric", "targets": [ 3 ] },
         *          { "orderDataType": "dom-select", "targets": [ 4 ] },
         *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          null,
         *          null,
         *          { "orderDataType": "dom-text" },
         *          { "orderDataType": "dom-text", "type": "numeric" },
         *          { "orderDataType": "dom-select" },
         *          { "orderDataType": "dom-checkbox" }
         *        ]
         *      } );
         *    } );
         */
        "sSortDataType": "std",

        /**
         * The title of this column.
         *  @type string
         *  @default null <i>Derived from the 'TH' value for this column in the
         *    original HTML table.</i>
         *
         *  @name DataTable.defaults.column.title
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "title": "My column title", "targets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "title": "My column title" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sTitle": null,

        /**
         * The type allows you to specify how the data for this column will be
         * ordered. Four types (string, numeric, date and html (which will strip
         * HTML tags before ordering)) are currently available. Note that only date
         * formats understood by Javascript's Date() object will be accepted as type
         * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
         * 'numeric', 'date' or 'html' (by default). Further types can be adding
         * through plug-ins.
         *  @type string
         *  @default null <i>Auto-detected from raw data</i>
         *
         *  @name DataTable.defaults.column.type
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "type": "html", "targets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "type": "html" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sType": null,

        /**
         * Defining the width of the column, this parameter may take any CSS value
         * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
         * been given a specific width through this interface ensuring that the table
         * remains readable.
         *  @type string
         *  @default null <i>Automatic</i>
         *
         *  @name DataTable.defaults.column.width
         *  @dtopt Columns
         *
         *  @example
         *    // Using `columnDefs`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columnDefs": [
         *          { "width": "20%", "targets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using `columns`
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "columns": [
         *          { "width": "20%" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sWidth": null
      };

      _fnHungarianMap(DataTable.defaults.column);
      /**
       * DataTables settings object - this holds all the information needed for a
       * given table, including configuration, data and current application of the
       * table options. DataTables does not have a single instance for each DataTable
       * with the settings attached to that instance, but rather instances of the
       * DataTable "class" are created on-the-fly as needed (typically by a
       * $().dataTable() call) and the settings object is then applied to that
       * instance.
       *
       * Note that this object is related to {@link DataTable.defaults} but this
       * one is the internal data store for DataTables's cache of columns. It should
       * NOT be manipulated outside of DataTables. Any configuration should be done
       * through the initialisation options.
       *  @namespace
       *  @todo Really should attach the settings object to individual instances so we
       *    don't need to create new instances on each $().dataTable() call (if the
       *    table already exists). It would also save passing oSettings around and
       *    into every single function. However, this is a very significant
       *    architecture change for DataTables and will almost certainly break
       *    backwards compatibility with older installations. This is something that
       *    will be done in 2.0.
       */


      DataTable.models.oSettings = {
        /**
         * Primary features of DataTables and their enablement state.
         *  @namespace
         */
        "oFeatures": {
          /**
           * Flag to say if DataTables should automatically try to calculate the
           * optimum table and columns widths (true) or not (false).
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bAutoWidth": null,

          /**
           * Delay the creation of TR and TD elements until they are actually
           * needed by a driven page draw. This can give a significant speed
           * increase for Ajax source and Javascript source data, but makes no
           * difference at all fro DOM and server-side processing tables.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bDeferRender": null,

          /**
           * Enable filtering on the table or not. Note that if this is disabled
           * then there is no filtering at all on the table, including fnFilter.
           * To just remove the filtering input use sDom and remove the 'f' option.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bFilter": null,

          /**
           * Table information element (the 'Showing x of y records' div) enable
           * flag.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bInfo": null,

          /**
           * Present a user control allowing the end user to change the page size
           * when pagination is enabled.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bLengthChange": null,

          /**
           * Pagination enabled or not. Note that if this is disabled then length
           * changing must also be disabled.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bPaginate": null,

          /**
           * Processing indicator enable flag whenever DataTables is enacting a
           * user request - typically an Ajax request for server-side processing.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bProcessing": null,

          /**
           * Server-side processing enabled flag - when enabled DataTables will
           * get all data from the server for every draw - there is no filtering,
           * sorting or paging done on the client-side.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bServerSide": null,

          /**
           * Sorting enablement flag.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bSort": null,

          /**
           * Multi-column sorting
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bSortMulti": null,

          /**
           * Apply a class to the columns which are being sorted to provide a
           * visual highlight or not. This can slow things down when enabled since
           * there is a lot of DOM interaction.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bSortClasses": null,

          /**
           * State saving enablement flag.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bStateSave": null
        },

        /**
         * Scrolling settings for a table.
         *  @namespace
         */
        "oScroll": {
          /**
           * When the table is shorter in height than sScrollY, collapse the
           * table container down to the height of the table (when true).
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type boolean
           */
          "bCollapse": null,

          /**
           * Width of the scrollbar for the web-browser's platform. Calculated
           * during table initialisation.
           *  @type int
           *  @default 0
           */
          "iBarWidth": 0,

          /**
           * Viewport width for horizontal scrolling. Horizontal scrolling is
           * disabled if an empty string.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type string
           */
          "sX": null,

          /**
           * Width to expand the table to when using x-scrolling. Typically you
           * should not need to use this.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type string
           *  @deprecated
           */
          "sXInner": null,

          /**
           * Viewport height for vertical scrolling. Vertical scrolling is disabled
           * if an empty string.
           * Note that this parameter will be set by the initialisation routine. To
           * set a default use {@link DataTable.defaults}.
           *  @type string
           */
          "sY": null
        },

        /**
         * Language information for the table.
         *  @namespace
         *  @extends DataTable.defaults.oLanguage
         */
        "oLanguage": {
          /**
           * Information callback function. See
           * {@link DataTable.defaults.fnInfoCallback}
           *  @type function
           *  @default null
           */
          "fnInfoCallback": null
        },

        /**
         * Browser support parameters
         *  @namespace
         */
        "oBrowser": {
          /**
           * Indicate if the browser incorrectly calculates width:100% inside a
           * scrolling element (IE6/7)
           *  @type boolean
           *  @default false
           */
          "bScrollOversize": false,

          /**
           * Determine if the vertical scrollbar is on the right or left of the
           * scrolling container - needed for rtl language layout, although not
           * all browsers move the scrollbar (Safari).
           *  @type boolean
           *  @default false
           */
          "bScrollbarLeft": false,

          /**
           * Flag for if `getBoundingClientRect` is fully supported or not
           *  @type boolean
           *  @default false
           */
          "bBounding": false,

          /**
           * Browser scrollbar width
           *  @type integer
           *  @default 0
           */
          "barWidth": 0
        },
        "ajax": null,

        /**
         * Array referencing the nodes which are used for the features. The
         * parameters of this object match what is allowed by sDom - i.e.
         *   <ul>
         *     <li>'l' - Length changing</li>
         *     <li>'f' - Filtering input</li>
         *     <li>'t' - The table!</li>
         *     <li>'i' - Information</li>
         *     <li>'p' - Pagination</li>
         *     <li>'r' - pRocessing</li>
         *   </ul>
         *  @type array
         *  @default []
         */
        "aanFeatures": [],

        /**
         * Store data information - see {@link DataTable.models.oRow} for detailed
         * information.
         *  @type array
         *  @default []
         */
        "aoData": [],

        /**
         * Array of indexes which are in the current display (after filtering etc)
         *  @type array
         *  @default []
         */
        "aiDisplay": [],

        /**
         * Array of indexes for display - no filtering
         *  @type array
         *  @default []
         */
        "aiDisplayMaster": [],

        /**
         * Map of row ids to data indexes
         *  @type object
         *  @default {}
         */
        "aIds": {},

        /**
         * Store information about each column that is in use
         *  @type array
         *  @default []
         */
        "aoColumns": [],

        /**
         * Store information about the table's header
         *  @type array
         *  @default []
         */
        "aoHeader": [],

        /**
         * Store information about the table's footer
         *  @type array
         *  @default []
         */
        "aoFooter": [],

        /**
         * Store the applied global search information in case we want to force a
         * research or compare the old search to a new one.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @namespace
         *  @extends DataTable.models.oSearch
         */
        "oPreviousSearch": {},

        /**
         * Store the applied search for each column - see
         * {@link DataTable.models.oSearch} for the format that is used for the
         * filtering information for each column.
         *  @type array
         *  @default []
         */
        "aoPreSearchCols": [],

        /**
         * Sorting that is applied to the table. Note that the inner arrays are
         * used in the following manner:
         * <ul>
         *   <li>Index 0 - column number</li>
         *   <li>Index 1 - current sorting direction</li>
         * </ul>
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array
         *  @todo These inner arrays should really be objects
         */
        "aaSorting": null,

        /**
         * Sorting that is always applied to the table (i.e. prefixed in front of
         * aaSorting).
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array
         *  @default []
         */
        "aaSortingFixed": [],

        /**
         * Classes to use for the striping of a table.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array
         *  @default []
         */
        "asStripeClasses": null,

        /**
         * If restoring a table - we should restore its striping classes as well
         *  @type array
         *  @default []
         */
        "asDestroyStripes": [],

        /**
         * If restoring a table - we should restore its width
         *  @type int
         *  @default 0
         */
        "sDestroyWidth": 0,

        /**
         * Callback functions array for every time a row is inserted (i.e. on a draw).
         *  @type array
         *  @default []
         */
        "aoRowCallback": [],

        /**
         * Callback functions for the header on each draw.
         *  @type array
         *  @default []
         */
        "aoHeaderCallback": [],

        /**
         * Callback function for the footer on each draw.
         *  @type array
         *  @default []
         */
        "aoFooterCallback": [],

        /**
         * Array of callback functions for draw callback functions
         *  @type array
         *  @default []
         */
        "aoDrawCallback": [],

        /**
         * Array of callback functions for row created function
         *  @type array
         *  @default []
         */
        "aoRowCreatedCallback": [],

        /**
         * Callback functions for just before the table is redrawn. A return of
         * false will be used to cancel the draw.
         *  @type array
         *  @default []
         */
        "aoPreDrawCallback": [],

        /**
         * Callback functions for when the table has been initialised.
         *  @type array
         *  @default []
         */
        "aoInitComplete": [],

        /**
         * Callbacks for modifying the settings to be stored for state saving, prior to
         * saving state.
         *  @type array
         *  @default []
         */
        "aoStateSaveParams": [],

        /**
         * Callbacks for modifying the settings that have been stored for state saving
         * prior to using the stored values to restore the state.
         *  @type array
         *  @default []
         */
        "aoStateLoadParams": [],

        /**
         * Callbacks for operating on the settings object once the saved state has been
         * loaded
         *  @type array
         *  @default []
         */
        "aoStateLoaded": [],

        /**
         * Cache the table ID for quick access
         *  @type string
         *  @default <i>Empty string</i>
         */
        "sTableId": "",

        /**
         * The TABLE node for the main table
         *  @type node
         *  @default null
         */
        "nTable": null,

        /**
         * Permanent ref to the thead element
         *  @type node
         *  @default null
         */
        "nTHead": null,

        /**
         * Permanent ref to the tfoot element - if it exists
         *  @type node
         *  @default null
         */
        "nTFoot": null,

        /**
         * Permanent ref to the tbody element
         *  @type node
         *  @default null
         */
        "nTBody": null,

        /**
         * Cache the wrapper node (contains all DataTables controlled elements)
         *  @type node
         *  @default null
         */
        "nTableWrapper": null,

        /**
         * Indicate if when using server-side processing the loading of data
         * should be deferred until the second draw.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         *  @default false
         */
        "bDeferLoading": false,

        /**
         * Indicate if all required information has been read in
         *  @type boolean
         *  @default false
         */
        "bInitialised": false,

        /**
         * Information about open rows. Each object in the array has the parameters
         * 'nTr' and 'nParent'
         *  @type array
         *  @default []
         */
        "aoOpenRows": [],

        /**
         * Dictate the positioning of DataTables' control elements - see
         * {@link DataTable.model.oInit.sDom}.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @default null
         */
        "sDom": null,

        /**
         * Search delay (in mS)
         *  @type integer
         *  @default null
         */
        "searchDelay": null,

        /**
         * Which type of pagination should be used.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @default two_button
         */
        "sPaginationType": "two_button",

        /**
         * The state duration (for `stateSave`) in seconds.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type int
         *  @default 0
         */
        "iStateDuration": 0,

        /**
         * Array of callback functions for state saving. Each array element is an
         * object with the following parameters:
         *   <ul>
         *     <li>function:fn - function to call. Takes two parameters, oSettings
         *       and the JSON string to save that has been thus far created. Returns
         *       a JSON string to be inserted into a json object
         *       (i.e. '"param": [ 0, 1, 2]')</li>
         *     <li>string:sName - name of callback</li>
         *   </ul>
         *  @type array
         *  @default []
         */
        "aoStateSave": [],

        /**
         * Array of callback functions for state loading. Each array element is an
         * object with the following parameters:
         *   <ul>
         *     <li>function:fn - function to call. Takes two parameters, oSettings
         *       and the object stored. May return false to cancel state loading</li>
         *     <li>string:sName - name of callback</li>
         *   </ul>
         *  @type array
         *  @default []
         */
        "aoStateLoad": [],

        /**
         * State that was saved. Useful for back reference
         *  @type object
         *  @default null
         */
        "oSavedState": null,

        /**
         * State that was loaded. Useful for back reference
         *  @type object
         *  @default null
         */
        "oLoadedState": null,

        /**
         * Source url for AJAX data for the table.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @default null
         */
        "sAjaxSource": null,

        /**
         * Property from a given object from which to read the table data from. This
         * can be an empty string (when not server-side processing), in which case
         * it is  assumed an an array is given directly.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         */
        "sAjaxDataProp": null,

        /**
         * Note if draw should be blocked while getting data
         *  @type boolean
         *  @default true
         */
        "bAjaxDataGet": true,

        /**
         * The last jQuery XHR object that was used for server-side data gathering.
         * This can be used for working with the XHR information in one of the
         * callbacks
         *  @type object
         *  @default null
         */
        "jqXHR": null,

        /**
         * JSON returned from the server in the last Ajax request
         *  @type object
         *  @default undefined
         */
        "json": undefined,

        /**
         * Data submitted as part of the last Ajax request
         *  @type object
         *  @default undefined
         */
        "oAjaxData": undefined,

        /**
         * Function to get the server-side data.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type function
         */
        "fnServerData": null,

        /**
         * Functions which are called prior to sending an Ajax request so extra
         * parameters can easily be sent to the server
         *  @type array
         *  @default []
         */
        "aoServerParams": [],

        /**
         * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
         * required).
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         */
        "sServerMethod": null,

        /**
         * Format numbers for display.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type function
         */
        "fnFormatNumber": null,

        /**
         * List of options that can be used for the user selectable length menu.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array
         *  @default []
         */
        "aLengthMenu": null,

        /**
         * Counter for the draws that the table does. Also used as a tracker for
         * server-side processing
         *  @type int
         *  @default 0
         */
        "iDraw": 0,

        /**
         * Indicate if a redraw is being done - useful for Ajax
         *  @type boolean
         *  @default false
         */
        "bDrawing": false,

        /**
         * Draw index (iDraw) of the last error when parsing the returned data
         *  @type int
         *  @default -1
         */
        "iDrawError": -1,

        /**
         * Paging display length
         *  @type int
         *  @default 10
         */
        "_iDisplayLength": 10,

        /**
         * Paging start point - aiDisplay index
         *  @type int
         *  @default 0
         */
        "_iDisplayStart": 0,

        /**
         * Server-side processing - number of records in the result set
         * (i.e. before filtering), Use fnRecordsTotal rather than
         * this property to get the value of the number of records, regardless of
         * the server-side processing setting.
         *  @type int
         *  @default 0
         *  @private
         */
        "_iRecordsTotal": 0,

        /**
         * Server-side processing - number of records in the current display set
         * (i.e. after filtering). Use fnRecordsDisplay rather than
         * this property to get the value of the number of records, regardless of
         * the server-side processing setting.
         *  @type boolean
         *  @default 0
         *  @private
         */
        "_iRecordsDisplay": 0,

        /**
         * The classes to use for the table
         *  @type object
         *  @default {}
         */
        "oClasses": {},

        /**
         * Flag attached to the settings object so you can check in the draw
         * callback if filtering has been done in the draw. Deprecated in favour of
         * events.
         *  @type boolean
         *  @default false
         *  @deprecated
         */
        "bFiltered": false,

        /**
         * Flag attached to the settings object so you can check in the draw
         * callback if sorting has been done in the draw. Deprecated in favour of
         * events.
         *  @type boolean
         *  @default false
         *  @deprecated
         */
        "bSorted": false,

        /**
         * Indicate that if multiple rows are in the header and there is more than
         * one unique cell per column, if the top one (true) or bottom one (false)
         * should be used for sorting / title by DataTables.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bSortCellsTop": null,

        /**
         * Initialisation object that is used for the table
         *  @type object
         *  @default null
         */
        "oInit": null,

        /**
         * Destroy callback functions - for plug-ins to attach themselves to the
         * destroy so they can clean up markup and events.
         *  @type array
         *  @default []
         */
        "aoDestroyCallback": [],

        /**
         * Get the number of records in the current record set, before filtering
         *  @type function
         */
        "fnRecordsTotal": function fnRecordsTotal() {
          return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
        },

        /**
         * Get the number of records in the current record set, after filtering
         *  @type function
         */
        "fnRecordsDisplay": function fnRecordsDisplay() {
          return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
        },

        /**
         * Get the display end point - aiDisplay index
         *  @type function
         */
        "fnDisplayEnd": function fnDisplayEnd() {
          var len = this._iDisplayLength,
              start = this._iDisplayStart,
              calc = start + len,
              records = this.aiDisplay.length,
              features = this.oFeatures,
              paginate = features.bPaginate;

          if (features.bServerSide) {
            return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
          } else {
            return !paginate || calc > records || len === -1 ? records : calc;
          }
        },

        /**
         * The DataTables object for this table
         *  @type object
         *  @default null
         */
        "oInstance": null,

        /**
         * Unique identifier for each instance of the DataTables object. If there
         * is an ID on the table node, then it takes that value, otherwise an
         * incrementing internal counter is used.
         *  @type string
         *  @default null
         */
        "sInstance": null,

        /**
         * tabindex attribute value that is added to DataTables control elements, allowing
         * keyboard navigation of the table and its controls.
         */
        "iTabIndex": 0,

        /**
         * DIV container for the footer scrolling table if scrolling
         */
        "nScrollHead": null,

        /**
         * DIV container for the footer scrolling table if scrolling
         */
        "nScrollFoot": null,

        /**
         * Last applied sort
         *  @type array
         *  @default []
         */
        "aLastSort": [],

        /**
         * Stored plug-in instances
         *  @type object
         *  @default {}
         */
        "oPlugins": {},

        /**
         * Function used to get a row's id from the row's data
         *  @type function
         *  @default null
         */
        "rowIdFn": null,

        /**
         * Data location where to store a row's id
         *  @type string
         *  @default null
         */
        "rowId": null
      };
      /**
       * Extension object for DataTables that is used to provide all extension
       * options.
       *
       * Note that the `DataTable.ext` object is available through
       * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
       * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
       *  @namespace
       *  @extends DataTable.models.ext
       */

      /**
       * DataTables extensions
       * 
       * This namespace acts as a collection area for plug-ins that can be used to
       * extend DataTables capabilities. Indeed many of the build in methods
       * use this method to provide their own capabilities (sorting methods for
       * example).
       *
       * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
       * reasons
       *
       *  @namespace
       */

      DataTable.ext = _ext = {
        /**
         * Buttons. For use with the Buttons extension for DataTables. This is
         * defined here so other extensions can define buttons regardless of load
         * order. It is _not_ used by DataTables core.
         *
         *  @type object
         *  @default {}
         */
        buttons: {},

        /**
         * Element class names
         *
         *  @type object
         *  @default {}
         */
        classes: {},

        /**
         * DataTables build type (expanded by the download builder)
         *
         *  @type string
         */
        builder: "-source-",

        /**
         * Error reporting.
         * 
         * How should DataTables report an error. Can take the value 'alert',
         * 'throw', 'none' or a function.
         *
         *  @type string|function
         *  @default alert
         */
        errMode: "alert",

        /**
         * Feature plug-ins.
         * 
         * This is an array of objects which describe the feature plug-ins that are
         * available to DataTables. These feature plug-ins are then available for
         * use through the `dom` initialisation option.
         * 
         * Each feature plug-in is described by an object which must have the
         * following properties:
         * 
         * * `fnInit` - function that is used to initialise the plug-in,
         * * `cFeature` - a character so the feature can be enabled by the `dom`
         *   instillation option. This is case sensitive.
         *
         * The `fnInit` function has the following input parameters:
         *
         * 1. `{object}` DataTables settings object: see
         *    {@link DataTable.models.oSettings}
         *
         * And the following return is expected:
         * 
         * * {node|null} The element which contains your feature. Note that the
         *   return may also be void if your plug-in does not require to inject any
         *   DOM elements into DataTables control (`dom`) - for example this might
         *   be useful when developing a plug-in which allows table control via
         *   keyboard entry
         *
         *  @type array
         *
         *  @example
         *    $.fn.dataTable.ext.features.push( {
         *      "fnInit": function( oSettings ) {
         *        return new TableTools( { "oDTSettings": oSettings } );
         *      },
         *      "cFeature": "T"
         *    } );
         */
        feature: [],

        /**
         * Row searching.
         * 
         * This method of searching is complimentary to the default type based
         * searching, and a lot more comprehensive as it allows you complete control
         * over the searching logic. Each element in this array is a function
         * (parameters described below) that is called for every row in the table,
         * and your logic decides if it should be included in the searching data set
         * or not.
         *
         * Searching functions have the following input parameters:
         *
         * 1. `{object}` DataTables settings object: see
         *    {@link DataTable.models.oSettings}
         * 2. `{array|object}` Data for the row to be processed (same as the
         *    original format that was passed in as the data source, or an array
         *    from a DOM data source
         * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
         *    can be useful to retrieve the `TR` element if you need DOM interaction.
         *
         * And the following return is expected:
         *
         * * {boolean} Include the row in the searched result set (true) or not
         *   (false)
         *
         * Note that as with the main search ability in DataTables, technically this
         * is "filtering", since it is subtractive. However, for consistency in
         * naming we call it searching here.
         *
         *  @type array
         *  @default []
         *
         *  @example
         *    // The following example shows custom search being applied to the
         *    // fourth column (i.e. the data[3] index) based on two input values
         *    // from the end-user, matching the data in a certain range.
         *    $.fn.dataTable.ext.search.push(
         *      function( settings, data, dataIndex ) {
         *        var min = document.getElementById('min').value * 1;
         *        var max = document.getElementById('max').value * 1;
         *        var version = data[3] == "-" ? 0 : data[3]*1;
         *
         *        if ( min == "" && max == "" ) {
         *          return true;
         *        }
         *        else if ( min == "" && version < max ) {
         *          return true;
         *        }
         *        else if ( min < version && "" == max ) {
         *          return true;
         *        }
         *        else if ( min < version && version < max ) {
         *          return true;
         *        }
         *        return false;
         *      }
         *    );
         */
        search: [],

        /**
         * Selector extensions
         *
         * The `selector` option can be used to extend the options available for the
         * selector modifier options (`selector-modifier` object data type) that
         * each of the three built in selector types offer (row, column and cell +
         * their plural counterparts). For example the Select extension uses this
         * mechanism to provide an option to select only rows, columns and cells
         * that have been marked as selected by the end user (`{selected: true}`),
         * which can be used in conjunction with the existing built in selector
         * options.
         *
         * Each property is an array to which functions can be pushed. The functions
         * take three attributes:
         *
         * * Settings object for the host table
         * * Options object (`selector-modifier` object type)
         * * Array of selected item indexes
         *
         * The return is an array of the resulting item indexes after the custom
         * selector has been applied.
         *
         *  @type object
         */
        selector: {
          cell: [],
          column: [],
          row: []
        },

        /**
         * Internal functions, exposed for used in plug-ins.
         * 
         * Please note that you should not need to use the internal methods for
         * anything other than a plug-in (and even then, try to avoid if possible).
         * The internal function may change between releases.
         *
         *  @type object
         *  @default {}
         */
        internal: {},

        /**
         * Legacy configuration options. Enable and disable legacy options that
         * are available in DataTables.
         *
         *  @type object
         */
        legacy: {
          /**
           * Enable / disable DataTables 1.9 compatible server-side processing
           * requests
           *
           *  @type boolean
           *  @default null
           */
          ajax: null
        },

        /**
         * Pagination plug-in methods.
         * 
         * Each entry in this object is a function and defines which buttons should
         * be shown by the pagination rendering method that is used for the table:
         * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
         * buttons are displayed in the document, while the functions here tell it
         * what buttons to display. This is done by returning an array of button
         * descriptions (what each button will do).
         *
         * Pagination types (the four built in options and any additional plug-in
         * options defined here) can be used through the `paginationType`
         * initialisation parameter.
         *
         * The functions defined take two parameters:
         *
         * 1. `{int} page` The current page index
         * 2. `{int} pages` The number of pages in the table
         *
         * Each function is expected to return an array where each element of the
         * array can be one of:
         *
         * * `first` - Jump to first page when activated
         * * `last` - Jump to last page when activated
         * * `previous` - Show previous page when activated
         * * `next` - Show next page when activated
         * * `{int}` - Show page of the index given
         * * `{array}` - A nested array containing the above elements to add a
         *   containing 'DIV' element (might be useful for styling).
         *
         * Note that DataTables v1.9- used this object slightly differently whereby
         * an object with two functions would be defined for each plug-in. That
         * ability is still supported by DataTables 1.10+ to provide backwards
         * compatibility, but this option of use is now decremented and no longer
         * documented in DataTables 1.10+.
         *
         *  @type object
         *  @default {}
         *
         *  @example
         *    // Show previous, next and current page buttons only
         *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
         *      return [ 'previous', page, 'next' ];
         *    };
         */
        pager: {},
        renderer: {
          pageButton: {},
          header: {}
        },

        /**
         * Ordering plug-ins - custom data source
         * 
         * The extension options for ordering of data available here is complimentary
         * to the default type based ordering that DataTables typically uses. It
         * allows much greater control over the the data that is being used to
         * order a column, but is necessarily therefore more complex.
         * 
         * This type of ordering is useful if you want to do ordering based on data
         * live from the DOM (for example the contents of an 'input' element) rather
         * than just the static string that DataTables knows of.
         * 
         * The way these plug-ins work is that you create an array of the values you
         * wish to be ordering for the column in question and then return that
         * array. The data in the array much be in the index order of the rows in
         * the table (not the currently ordering order!). Which order data gathering
         * function is run here depends on the `dt-init columns.orderDataType`
         * parameter that is used for the column (if any).
         *
         * The functions defined take two parameters:
         *
         * 1. `{object}` DataTables settings object: see
         *    {@link DataTable.models.oSettings}
         * 2. `{int}` Target column index
         *
         * Each function is expected to return an array:
         *
         * * `{array}` Data for the column to be ordering upon
         *
         *  @type array
         *
         *  @example
         *    // Ordering using `input` node values
         *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
         *    {
         *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
         *        return $('input', td).val();
         *      } );
         *    }
         */
        order: {},

        /**
         * Type based plug-ins.
         *
         * Each column in DataTables has a type assigned to it, either by automatic
         * detection or by direct assignment using the `type` option for the column.
         * The type of a column will effect how it is ordering and search (plug-ins
         * can also make use of the column type if required).
         *
         * @namespace
         */
        type: {
          /**
           * Type detection functions.
           *
           * The functions defined in this object are used to automatically detect
           * a column's type, making initialisation of DataTables super easy, even
           * when complex data is in the table.
           *
           * The functions defined take two parameters:
           *
              *  1. `{*}` Data from the column cell to be analysed
              *  2. `{settings}` DataTables settings object. This can be used to
              *     perform context specific type detection - for example detection
              *     based on language settings such as using a comma for a decimal
              *     place. Generally speaking the options from the settings will not
              *     be required
           *
           * Each function is expected to return:
           *
           * * `{string|null}` Data type detected, or null if unknown (and thus
           *   pass it on to the other type detection functions.
           *
           *  @type array
           *
           *  @example
           *    // Currency type detection plug-in:
           *    $.fn.dataTable.ext.type.detect.push(
           *      function ( data, settings ) {
           *        // Check the numeric part
           *        if ( ! data.substring(1).match(/[0-9]/) ) {
           *          return null;
           *        }
           *
           *        // Check prefixed by currency
           *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
           *          return 'currency';
           *        }
           *        return null;
           *      }
           *    );
           */
          detect: [],

          /**
           * Type based search formatting.
           *
           * The type based searching functions can be used to pre-format the
           * data to be search on. For example, it can be used to strip HTML
           * tags or to de-format telephone numbers for numeric only searching.
           *
           * Note that is a search is not defined for a column of a given type,
           * no search formatting will be performed.
           * 
           * Pre-processing of searching data plug-ins - When you assign the sType
           * for a column (or have it automatically detected for you by DataTables
           * or a type detection plug-in), you will typically be using this for
           * custom sorting, but it can also be used to provide custom searching
           * by allowing you to pre-processing the data and returning the data in
           * the format that should be searched upon. This is done by adding
           * functions this object with a parameter name which matches the sType
           * for that target column. This is the corollary of <i>afnSortData</i>
           * for searching data.
           *
           * The functions defined take a single parameter:
           *
              *  1. `{*}` Data from the column cell to be prepared for searching
           *
           * Each function is expected to return:
           *
           * * `{string|null}` Formatted string that will be used for the searching.
           *
           *  @type object
           *  @default {}
           *
           *  @example
           *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
           *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
           *    }
           */
          search: {},

          /**
           * Type based ordering.
           *
           * The column type tells DataTables what ordering to apply to the table
           * when a column is sorted upon. The order for each type that is defined,
           * is defined by the functions available in this object.
           *
           * Each ordering option can be described by three properties added to
           * this object:
           *
           * * `{type}-pre` - Pre-formatting function
           * * `{type}-asc` - Ascending order function
           * * `{type}-desc` - Descending order function
           *
           * All three can be used together, only `{type}-pre` or only
           * `{type}-asc` and `{type}-desc` together. It is generally recommended
           * that only `{type}-pre` is used, as this provides the optimal
           * implementation in terms of speed, although the others are provided
           * for compatibility with existing Javascript sort functions.
           *
           * `{type}-pre`: Functions defined take a single parameter:
           *
              *  1. `{*}` Data from the column cell to be prepared for ordering
           *
           * And return:
           *
           * * `{*}` Data to be sorted upon
           *
           * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
           * functions, taking two parameters:
           *
              *  1. `{*}` Data to compare to the second parameter
              *  2. `{*}` Data to compare to the first parameter
           *
           * And returning:
           *
           * * `{*}` Ordering match: <0 if first parameter should be sorted lower
           *   than the second parameter, ===0 if the two parameters are equal and
           *   >0 if the first parameter should be sorted height than the second
           *   parameter.
           * 
           *  @type object
           *  @default {}
           *
           *  @example
           *    // Numeric ordering of formatted numbers with a pre-formatter
           *    $.extend( $.fn.dataTable.ext.type.order, {
           *      "string-pre": function(x) {
           *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
           *        return parseFloat( a );
           *      }
           *    } );
           *
           *  @example
           *    // Case-sensitive string ordering, with no pre-formatting method
           *    $.extend( $.fn.dataTable.ext.order, {
           *      "string-case-asc": function(x,y) {
           *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
           *      },
           *      "string-case-desc": function(x,y) {
           *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
           *      }
           *    } );
           */
          order: {}
        },

        /**
         * Unique DataTables instance counter
         *
         * @type int
         * @private
         */
        _unique: 0,
        //
        // Depreciated
        // The following properties are retained for backwards compatiblity only.
        // The should not be used in new projects and will be removed in a future
        // version
        //

        /**
         * Version check function.
         *  @type function
         *  @depreciated Since 1.10
         */
        fnVersionCheck: DataTable.fnVersionCheck,

        /**
         * Index for what 'this' index API functions should use
         *  @type int
         *  @deprecated Since v1.10
         */
        iApiIndex: 0,

        /**
         * jQuery UI class container
         *  @type object
         *  @deprecated Since v1.10
         */
        oJUIClasses: {},

        /**
         * Software version
         *  @type string
         *  @deprecated Since v1.10
         */
        sVersion: DataTable.version
      }; //
      // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
      //

      $.extend(_ext, {
        afnFiltering: _ext.search,
        aTypes: _ext.type.detect,
        ofnSearch: _ext.type.search,
        oSort: _ext.type.order,
        afnSortData: _ext.order,
        aoFeatures: _ext.feature,
        oApi: _ext.internal,
        oStdClasses: _ext.classes,
        oPagination: _ext.pager
      });
      $.extend(DataTable.ext.classes, {
        "sTable": "dataTable",
        "sNoFooter": "no-footer",

        /* Paging buttons */
        "sPageButton": "paginate_button",
        "sPageButtonActive": "current",
        "sPageButtonDisabled": "disabled",

        /* Striping classes */
        "sStripeOdd": "odd",
        "sStripeEven": "even",

        /* Empty row */
        "sRowEmpty": "dataTables_empty",

        /* Features */
        "sWrapper": "dataTables_wrapper",
        "sFilter": "dataTables_filter",
        "sInfo": "dataTables_info",
        "sPaging": "dataTables_paginate paging_",

        /* Note that the type is postfixed */
        "sLength": "dataTables_length",
        "sProcessing": "dataTables_processing",

        /* Sorting */
        "sSortAsc": "sorting_asc",
        "sSortDesc": "sorting_desc",
        "sSortable": "sorting",

        /* Sortable in both directions */
        "sSortableAsc": "sorting_desc_disabled",
        "sSortableDesc": "sorting_asc_disabled",
        "sSortableNone": "sorting_disabled",
        "sSortColumn": "sorting_",

        /* Note that an int is postfixed for the sorting order */

        /* Filtering */
        "sFilterInput": "",

        /* Page length */
        "sLengthSelect": "",

        /* Scrolling */
        "sScrollWrapper": "dataTables_scroll",
        "sScrollHead": "dataTables_scrollHead",
        "sScrollHeadInner": "dataTables_scrollHeadInner",
        "sScrollBody": "dataTables_scrollBody",
        "sScrollFoot": "dataTables_scrollFoot",
        "sScrollFootInner": "dataTables_scrollFootInner",

        /* Misc */
        "sHeaderTH": "",
        "sFooterTH": "",
        // Deprecated
        "sSortJUIAsc": "",
        "sSortJUIDesc": "",
        "sSortJUI": "",
        "sSortJUIAscAllowed": "",
        "sSortJUIDescAllowed": "",
        "sSortJUIWrapper": "",
        "sSortIcon": "",
        "sJUIHeader": "",
        "sJUIFooter": ""
      });
      var extPagination = DataTable.ext.pager;

      function _numbers(page, pages) {
        var numbers = [],
            buttons = extPagination.numbers_length,
            half = Math.floor(buttons / 2),
            i = 1;

        if (pages <= buttons) {
          numbers = _range(0, pages);
        } else if (page <= half) {
          numbers = _range(0, buttons - 2);
          numbers.push('ellipsis');
          numbers.push(pages - 1);
        } else if (page >= pages - 1 - half) {
          numbers = _range(pages - (buttons - 2), pages);
          numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6

          numbers.splice(0, 0, 0);
        } else {
          numbers = _range(page - half + 2, page + half - 1);
          numbers.push('ellipsis');
          numbers.push(pages - 1);
          numbers.splice(0, 0, 'ellipsis');
          numbers.splice(0, 0, 0);
        }

        numbers.DT_el = 'span';
        return numbers;
      }

      $.extend(extPagination, {
        simple: function simple(page, pages) {
          return ['previous', 'next'];
        },
        full: function full(page, pages) {
          return ['first', 'previous', 'next', 'last'];
        },
        numbers: function numbers(page, pages) {
          return [_numbers(page, pages)];
        },
        simple_numbers: function simple_numbers(page, pages) {
          return ['previous', _numbers(page, pages), 'next'];
        },
        full_numbers: function full_numbers(page, pages) {
          return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
        },
        first_last_numbers: function first_last_numbers(page, pages) {
          return ['first', _numbers(page, pages), 'last'];
        },
        // For testing and plug-ins to use
        _numbers: _numbers,
        // Number of number buttons (including ellipsis) to show. _Must be odd!_
        numbers_length: 7
      });
      $.extend(true, DataTable.ext.renderer, {
        pageButton: {
          _: function _(settings, host, idx, buttons, page, pages) {
            var classes = settings.oClasses;
            var lang = settings.oLanguage.oPaginate;
            var aria = settings.oLanguage.oAria.paginate || {};
            var btnDisplay,
                btnClass,
                counter = 0;

            var attach = function attach(container, buttons) {
              var i, ien, node, button, tabIndex;
              var disabledClass = classes.sPageButtonDisabled;

              var clickHandler = function clickHandler(e) {
                _fnPageChange(settings, e.data.action, true);
              };

              for (i = 0, ien = buttons.length; i < ien; i++) {
                button = buttons[i];

                if (Array.isArray(button)) {
                  var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container);
                  attach(inner, button);
                } else {
                  btnDisplay = null;
                  btnClass = button;
                  tabIndex = settings.iTabIndex;

                  switch (button) {
                    case 'ellipsis':
                      container.append('<span class="ellipsis">&#x2026;</span>');
                      break;

                    case 'first':
                      btnDisplay = lang.sFirst;

                      if (page === 0) {
                        tabIndex = -1;
                        btnClass += ' ' + disabledClass;
                      }

                      break;

                    case 'previous':
                      btnDisplay = lang.sPrevious;

                      if (page === 0) {
                        tabIndex = -1;
                        btnClass += ' ' + disabledClass;
                      }

                      break;

                    case 'next':
                      btnDisplay = lang.sNext;

                      if (pages === 0 || page === pages - 1) {
                        tabIndex = -1;
                        btnClass += ' ' + disabledClass;
                      }

                      break;

                    case 'last':
                      btnDisplay = lang.sLast;

                      if (pages === 0 || page === pages - 1) {
                        tabIndex = -1;
                        btnClass += ' ' + disabledClass;
                      }

                      break;

                    default:
                      btnDisplay = settings.fnFormatNumber(button + 1);
                      btnClass = page === button ? classes.sPageButtonActive : '';
                      break;
                  }

                  if (btnDisplay !== null) {
                    node = $('<a>', {
                      'class': classes.sPageButton + ' ' + btnClass,
                      'aria-controls': settings.sTableId,
                      'aria-label': aria[button],
                      'data-dt-idx': counter,
                      'tabindex': tabIndex,
                      'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
                    }).html(btnDisplay).appendTo(container);

                    _fnBindAction(node, {
                      action: button
                    }, clickHandler);

                    counter++;
                  }
                }
              }
            }; // IE9 throws an 'unknown error' if document.activeElement is used
            // inside an iframe or frame. Try / catch the error. Not good for
            // accessibility, but neither are frames.


            var activeEl;

            try {
              // Because this approach is destroying and recreating the paging
              // elements, focus is lost on the select button which is bad for
              // accessibility. So we want to restore focus once the draw has
              // completed
              activeEl = $(host).find(document.activeElement).data('dt-idx');
            } catch (e) {}

            attach($(host).empty(), buttons);

            if (activeEl !== undefined) {
              $(host).find('[data-dt-idx=' + activeEl + ']').trigger('focus');
            }
          }
        }
      }); // Built in type detection. See model.ext.aTypes for information about
      // what is required from this methods.

      $.extend(DataTable.ext.type.detect, [// Plain numbers - first since V8 detects some plain numbers as dates
      // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal) ? 'num' + decimal : null;
      }, // Dates (only those recognised by the browser's Date.parse)
      function (d, settings) {
        // V8 tries _very_ hard to make a string passed into `Date.parse()`
        // valid, so we need to use a regex to restrict date formats. Use a
        // plug-in for anything other than ISO8601 style strings
        if (d && !(d instanceof Date) && !_re_date.test(d)) {
          return null;
        }

        var parsed = Date.parse(d);
        return parsed !== null && !isNaN(parsed) || _empty(d) ? 'date' : null;
      }, // Formatted numbers
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
      }, // HTML numeric
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
      }, // HTML numeric, formatted
      function (d, settings) {
        var decimal = settings.oLanguage.sDecimal;
        return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
      }, // HTML (this is strict checking - there must be html)
      function (d, settings) {
        return _empty(d) || typeof d === 'string' && d.indexOf('<') !== -1 ? 'html' : null;
      }]); // Filter formatting functions. See model.ext.ofnSearch for information about
      // what is required from these methods.
      // 
      // Note that additional search methods are added for the html numbers and
      // html formatted numbers by `_addNumericSort()` when we know what the decimal
      // place is

      $.extend(DataTable.ext.type.search, {
        html: function html(data) {
          return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ").replace(_re_html, "") : '';
        },
        string: function string(data) {
          return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ") : data;
        }
      });

      var __numericReplace = function __numericReplace(d, decimalPlace, re1, re2) {
        if (d !== 0 && (!d || d === '-')) {
          return -Infinity;
        } // If a decimal place other than `.` is used, it needs to be given to the
        // function so we can detect it and replace with a `.` which is the only
        // decimal place Javascript recognises - it is not locale aware.


        if (decimalPlace) {
          d = _numToDecimal(d, decimalPlace);
        }

        if (d.replace) {
          if (re1) {
            d = d.replace(re1, '');
          }

          if (re2) {
            d = d.replace(re2, '');
          }
        }

        return d * 1;
      }; // Add the numeric 'deformatting' functions for sorting and search. This is done
      // in a function to provide an easy ability for the language options to add
      // additional methods if a non-period decimal place is used.


      function _addNumericSort(decimalPlace) {
        $.each({
          // Plain numbers
          "num": function num(d) {
            return __numericReplace(d, decimalPlace);
          },
          // Formatted numbers
          "num-fmt": function numFmt(d) {
            return __numericReplace(d, decimalPlace, _re_formatted_numeric);
          },
          // HTML numeric
          "html-num": function htmlNum(d) {
            return __numericReplace(d, decimalPlace, _re_html);
          },
          // HTML numeric, formatted
          "html-num-fmt": function htmlNumFmt(d) {
            return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
          }
        }, function (key, fn) {
          // Add the ordering method
          _ext.type.order[key + decimalPlace + '-pre'] = fn; // For HTML types add a search formatter that will strip the HTML

          if (key.match(/^html\-/)) {
            _ext.type.search[key + decimalPlace] = _ext.type.search.html;
          }
        });
      } // Default sort methods


      $.extend(_ext.type.order, {
        // Dates
        "date-pre": function datePre(d) {
          var ts = Date.parse(d);
          return isNaN(ts) ? -Infinity : ts;
        },
        // html
        "html-pre": function htmlPre(a) {
          return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + '';
        },
        // string
        "string-pre": function stringPre(a) {
          // This is a little complex, but faster than always calling toString,
          // http://jsperf.com/tostring-v-check
          return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString();
        },
        // string-asc and -desc are retained only for compatibility with the old
        // sort methods
        "string-asc": function stringAsc(x, y) {
          return x < y ? -1 : x > y ? 1 : 0;
        },
        "string-desc": function stringDesc(x, y) {
          return x < y ? 1 : x > y ? -1 : 0;
        }
      }); // Numeric sorting types - order doesn't matter here

      _addNumericSort('');

      $.extend(true, DataTable.ext.renderer, {
        header: {
          _: function _(settings, cell, column, classes) {
            // No additional mark-up required
            // Attach a sort listener to update on sort - note that using the
            // `DT` namespace will allow the event to be removed automatically
            // on destroy, while the `dt` namespaced event is the one we are
            // listening for
            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
              if (settings !== ctx) {
                // need to check this this is the host
                return; // table, not a nested one
              }

              var colIdx = column.idx;
              cell.removeClass(classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
            });
          },
          jqueryui: function jqueryui(settings, cell, column, classes) {
            $('<div/>').addClass(classes.sSortJUIWrapper).append(cell.contents()).append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)).appendTo(cell); // Attach a sort listener to update on sort

            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
              if (settings !== ctx) {
                return;
              }

              var colIdx = column.idx;
              cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
              cell.find('span.' + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == 'asc' ? classes.sSortJUIAsc : columns[colIdx] == 'desc' ? classes.sSortJUIDesc : column.sSortingClassJUI);
            });
          }
        }
      });
      /*
       * Public helper functions. These aren't used internally by DataTables, or
       * called by any of the options passed into DataTables, but they can be used
       * externally by developers working with DataTables. They are helper functions
       * to make working with DataTables a little bit easier.
       */

      var __htmlEscapeEntities = function __htmlEscapeEntities(d) {
        return typeof d === 'string' ? d.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') : d;
      };
      /**
       * Helpers for `columns.render`.
       *
       * The options defined here can be used with the `columns.render` initialisation
       * option to provide a display renderer. The following functions are defined:
       *
       * * `number` - Will format numeric data (defined by `columns.data`) for
       *   display, retaining the original unformatted data for sorting and filtering.
       *   It takes 5 parameters:
       *   * `string` - Thousands grouping separator
       *   * `string` - Decimal point indicator
       *   * `integer` - Number of decimal points to show
       *   * `string` (optional) - Prefix.
       *   * `string` (optional) - Postfix (/suffix).
       * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
       *   parameters.
       *
       * @example
       *   // Column definition using the number renderer
       *   {
       *     data: "salary",
       *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
       *   }
       *
       * @namespace
       */


      DataTable.render = {
        number: function number(thousands, decimal, precision, prefix, postfix) {
          return {
            display: function display(d) {
              if (typeof d !== 'number' && typeof d !== 'string') {
                return d;
              }

              var negative = d < 0 ? '-' : '';
              var flo = parseFloat(d); // If NaN then there isn't much formatting that we can do - just
              // return immediately, escaping any HTML (this was supposed to
              // be a number after all)

              if (isNaN(flo)) {
                return __htmlEscapeEntities(d);
              }

              flo = flo.toFixed(precision);
              d = Math.abs(flo);
              var intPart = parseInt(d, 10);
              var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : '';
              return negative + (prefix || '') + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart + (postfix || '');
            }
          };
        },
        text: function text() {
          return {
            display: __htmlEscapeEntities,
            filter: __htmlEscapeEntities
          };
        }
      };
      /*
       * This is really a good bit rubbish this method of exposing the internal methods
       * publicly... - To be fixed in 2.0 using methods on the prototype
       */

      /**
       * Create a wrapper function for exporting an internal functions to an external API.
       *  @param {string} fn API function name
       *  @returns {function} wrapped function
       *  @memberof DataTable#internal
       */

      function _fnExternApiFunc(fn) {
        return function () {
          var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
          return DataTable.ext.internal[fn].apply(this, args);
        };
      }
      /**
       * Reference to internal functions for use by plug-in developers. Note that
       * these methods are references to internal functions and are considered to be
       * private. If you use these methods, be aware that they are liable to change
       * between versions.
       *  @namespace
       */


      $.extend(DataTable.ext.internal, {
        _fnExternApiFunc: _fnExternApiFunc,
        _fnBuildAjax: _fnBuildAjax,
        _fnAjaxUpdate: _fnAjaxUpdate,
        _fnAjaxParameters: _fnAjaxParameters,
        _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
        _fnAjaxDataSrc: _fnAjaxDataSrc,
        _fnAddColumn: _fnAddColumn,
        _fnColumnOptions: _fnColumnOptions,
        _fnAdjustColumnSizing: _fnAdjustColumnSizing,
        _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
        _fnColumnIndexToVisible: _fnColumnIndexToVisible,
        _fnVisbleColumns: _fnVisbleColumns,
        _fnGetColumns: _fnGetColumns,
        _fnColumnTypes: _fnColumnTypes,
        _fnApplyColumnDefs: _fnApplyColumnDefs,
        _fnHungarianMap: _fnHungarianMap,
        _fnCamelToHungarian: _fnCamelToHungarian,
        _fnLanguageCompat: _fnLanguageCompat,
        _fnBrowserDetect: _fnBrowserDetect,
        _fnAddData: _fnAddData,
        _fnAddTr: _fnAddTr,
        _fnNodeToDataIndex: _fnNodeToDataIndex,
        _fnNodeToColumnIndex: _fnNodeToColumnIndex,
        _fnGetCellData: _fnGetCellData,
        _fnSetCellData: _fnSetCellData,
        _fnSplitObjNotation: _fnSplitObjNotation,
        _fnGetObjectDataFn: _fnGetObjectDataFn,
        _fnSetObjectDataFn: _fnSetObjectDataFn,
        _fnGetDataMaster: _fnGetDataMaster,
        _fnClearTable: _fnClearTable,
        _fnDeleteIndex: _fnDeleteIndex,
        _fnInvalidate: _fnInvalidate,
        _fnGetRowElements: _fnGetRowElements,
        _fnCreateTr: _fnCreateTr,
        _fnBuildHead: _fnBuildHead,
        _fnDrawHead: _fnDrawHead,
        _fnDraw: _fnDraw,
        _fnReDraw: _fnReDraw,
        _fnAddOptionsHtml: _fnAddOptionsHtml,
        _fnDetectHeader: _fnDetectHeader,
        _fnGetUniqueThs: _fnGetUniqueThs,
        _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
        _fnFilterComplete: _fnFilterComplete,
        _fnFilterCustom: _fnFilterCustom,
        _fnFilterColumn: _fnFilterColumn,
        _fnFilter: _fnFilter,
        _fnFilterCreateSearch: _fnFilterCreateSearch,
        _fnEscapeRegex: _fnEscapeRegex,
        _fnFilterData: _fnFilterData,
        _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
        _fnUpdateInfo: _fnUpdateInfo,
        _fnInfoMacros: _fnInfoMacros,
        _fnInitialise: _fnInitialise,
        _fnInitComplete: _fnInitComplete,
        _fnLengthChange: _fnLengthChange,
        _fnFeatureHtmlLength: _fnFeatureHtmlLength,
        _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
        _fnPageChange: _fnPageChange,
        _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
        _fnProcessingDisplay: _fnProcessingDisplay,
        _fnFeatureHtmlTable: _fnFeatureHtmlTable,
        _fnScrollDraw: _fnScrollDraw,
        _fnApplyToChildren: _fnApplyToChildren,
        _fnCalculateColumnWidths: _fnCalculateColumnWidths,
        _fnThrottle: _fnThrottle,
        _fnConvertToWidth: _fnConvertToWidth,
        _fnGetWidestNode: _fnGetWidestNode,
        _fnGetMaxLenString: _fnGetMaxLenString,
        _fnStringToCss: _fnStringToCss,
        _fnSortFlatten: _fnSortFlatten,
        _fnSort: _fnSort,
        _fnSortAria: _fnSortAria,
        _fnSortListener: _fnSortListener,
        _fnSortAttachListener: _fnSortAttachListener,
        _fnSortingClasses: _fnSortingClasses,
        _fnSortData: _fnSortData,
        _fnSaveState: _fnSaveState,
        _fnLoadState: _fnLoadState,
        _fnSettingsFromNode: _fnSettingsFromNode,
        _fnLog: _fnLog,
        _fnMap: _fnMap,
        _fnBindAction: _fnBindAction,
        _fnCallbackReg: _fnCallbackReg,
        _fnCallbackFire: _fnCallbackFire,
        _fnLengthOverflow: _fnLengthOverflow,
        _fnRenderer: _fnRenderer,
        _fnDataSource: _fnDataSource,
        _fnRowAttributes: _fnRowAttributes,
        _fnExtend: _fnExtend,
        _fnCalculateEnd: function _fnCalculateEnd() {} // Used by a lot of plug-ins, but redundant
        // in 1.10, so this dead-end function is
        // added to prevent errors

      }); // jQuery access

      $.fn.dataTable = DataTable; // Provide access to the host jQuery object (circular reference)

      DataTable.$ = $; // Legacy aliases

      $.fn.dataTableSettings = DataTable.settings;
      $.fn.dataTableExt = DataTable.ext; // With a capital `D` we return a DataTables API instance rather than a
      // jQuery object

      $.fn.DataTable = function (opts) {
        return $(this).dataTable(opts).api();
      }; // All properties that are available to $.fn.dataTable should also be
      // available on $.fn.DataTable


      $.each(DataTable, function (prop, val) {
        $.fn.DataTable[prop] = val;
      }); // Information about events fired by DataTables - for documentation.

      /**
       * Draw event, fired whenever the table is redrawn on the page, at the same
       * point as fnDrawCallback. This may be useful for binding events or
       * performing calculations when the table is altered at all.
       *  @name DataTable#draw.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       */

      /**
       * Search event, fired when the searching applied to the table (using the
       * built-in global search, or column filters) is altered.
       *  @name DataTable#search.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       */

      /**
       * Page change event, fired when the paging of the table is altered.
       *  @name DataTable#page.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       */

      /**
       * Order event, fired when the ordering applied to the table is altered.
       *  @name DataTable#order.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       */

      /**
       * DataTables initialisation complete event, fired when the table is fully
       * drawn, including Ajax data loaded, if Ajax data is required.
       *  @name DataTable#init.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} oSettings DataTables settings object
       *  @param {object} json The JSON object request from the server - only
       *    present if client-side Ajax sourced data is used</li></ol>
       */

      /**
       * State save event, fired when the table has changed state a new state save
       * is required. This event allows modification of the state saving object
       * prior to actually doing the save, including addition or other state
       * properties (for plug-ins) or modification of a DataTables core property.
       *  @name DataTable#stateSaveParams.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} oSettings DataTables settings object
       *  @param {object} json The state information to be saved
       */

      /**
       * State load event, fired when the table is loading state from the stored
       * data, but prior to the settings object being modified by the saved state
       * - allowing modification of the saved state is required or loading of
       * state for a plug-in.
       *  @name DataTable#stateLoadParams.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} oSettings DataTables settings object
       *  @param {object} json The saved state information
       */

      /**
       * State loaded event, fired when state has been loaded from stored data and
       * the settings object has been modified by the loaded data.
       *  @name DataTable#stateLoaded.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} oSettings DataTables settings object
       *  @param {object} json The saved state information
       */

      /**
       * Processing event, fired when DataTables is doing some kind of processing
       * (be it, order, search or anything else). It can be used to indicate to
       * the end user that there is something happening, or that something has
       * finished.
       *  @name DataTable#processing.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} oSettings DataTables settings object
       *  @param {boolean} bShow Flag for if DataTables is doing processing or not
       */

      /**
       * Ajax (XHR) event, fired whenever an Ajax request is completed from a
       * request to made to the server for new data. This event is called before
       * DataTables processed the returned data, so it can also be used to pre-
       * process the data returned from the server, if needed.
       *
       * Note that this trigger is called in `fnServerData`, if you override
       * `fnServerData` and which to use this event, you need to trigger it in you
       * success function.
       *  @name DataTable#xhr.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       *  @param {object} json JSON returned from the server
       *
       *  @example
       *     // Use a custom property returned from the server in another DOM element
       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
       *       $('#status').html( json.status );
       *     } );
       *
       *  @example
       *     // Pre-process the data returned from the server
       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
       *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
       *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
       *       }
       *       // Note no return - manipulate the data directly in the JSON object.
       *     } );
       */

      /**
       * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
       * or passing the bDestroy:true parameter in the initialisation object. This
       * can be used to remove bound events, added DOM nodes, etc.
       *  @name DataTable#destroy.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       */

      /**
       * Page length change event, fired when number of records to show on each
       * page (the length) is changed.
       *  @name DataTable#length.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       *  @param {integer} len New length
       */

      /**
       * Column sizing has changed.
       *  @name DataTable#column-sizing.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       */

      /**
       * Column visibility has changed.
       *  @name DataTable#column-visibility.dt
       *  @event
       *  @param {event} e jQuery event object
       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
       *  @param {int} column Column index
       *  @param {bool} vis `false` if column now hidden, or `true` if visible
       */

      return $.fn.dataTable;
    });
    /***/

  },

  /***/
  "./resources/assets/vendor/libs/datatables/datatables.js":
  /*!***************************************************************!*\
    !*** ./resources/assets/vendor/libs/datatables/datatables.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function resourcesAssetsVendorLibsDatatablesDatatablesJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! datatables.net/js/jquery.dataTables.js */
    "./node_modules/datatables.net/js/jquery.dataTables.js");

    __webpack_require__(
    /*! datatables.net-bs4/js/dataTables.bootstrap4.js */
    "./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js");
    /***/

  },

  /***/
  65:
  /*!*********************************************************************!*\
    !*** multi ./resources/assets/vendor/libs/datatables/datatables.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\xampp\htdocs\globalplanthire\resources\assets\vendor\libs\datatables\datatables.js */
    "./resources/assets/vendor/libs/datatables/datatables.js");
    /***/
  },

  /***/
  "datatables.net":
  /*!*********************************!*\
    !*** external "$.fn.dataTable" ***!
    \*********************************/

  /*! no static exports found */

  /***/
  function datatablesNet(module, exports) {
    (function () {
      module.exports = window["$.fn.dataTable"];
    })();
    /***/

  },

  /***/
  "jquery":
  /*!*************************!*\
    !*** external "jQuery" ***!
    \*************************/

  /*! no static exports found */

  /***/
  function jquery(module, exports) {
    (function () {
      module.exports = window["jQuery"];
    })();
    /***/

  }
  /******/

}));

/***/ }),

/***/ "./resources/assets/libs/growl/growl.js":
/*!**********************************************!*\
  !*** ./resources/assets/libs/growl/growl.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(window,
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "/";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 76);
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "./node_modules/jquery.growl/javascripts/jquery.growl.js":
  /*!***************************************************************!*\
    !*** ./node_modules/jquery.growl/javascripts/jquery.growl.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesJqueryGrowlJavascriptsJqueryGrowlJs(module, exports) {
    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    } // Generated by CoffeeScript 2.1.0


    (function () {
      /*
      jQuery Growl
      Copyright 2015 Kevin Sylvestre
      1.3.5
      */
      "use strict";

      var $, Animation, Growl;
      $ = jQuery;

      Animation = function () {
        var Animation = function () {
          function Animation() {
            _classCallCheck(this, Animation);
          }

          _createClass(Animation, null, [{
            key: "transition",
            value: function transition($el) {
              var el, ref, result, type;
              el = $el[0];
              ref = this.transitions;

              for (type in ref) {
                result = ref[type];

                if (el.style[type] != null) {
                  return result;
                }
              }
            }
          }]);

          return Animation;
        }();

        ;
        Animation.transitions = {
          "webkitTransition": "webkitTransitionEnd",
          "mozTransition": "mozTransitionEnd",
          "oTransition": "oTransitionEnd",
          "transition": "transitionend"
        };
        return Animation;
      }();

      Growl = function () {
        var Growl = function () {
          _createClass(Growl, null, [{
            key: "growl",
            value: function growl() {
              var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return new Growl(settings);
            }
          }]);

          function Growl() {
            var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _classCallCheck(this, Growl);

            this.render = this.render.bind(this);
            this.bind = this.bind.bind(this);
            this.unbind = this.unbind.bind(this);
            this.mouseEnter = this.mouseEnter.bind(this);
            this.mouseLeave = this.mouseLeave.bind(this);
            this.click = this.click.bind(this);
            this.close = this.close.bind(this);
            this.cycle = this.cycle.bind(this);
            this.waitAndDismiss = this.waitAndDismiss.bind(this);
            this.present = this.present.bind(this);
            this.dismiss = this.dismiss.bind(this);
            this.remove = this.remove.bind(this);
            this.animate = this.animate.bind(this);
            this.$growls = this.$growls.bind(this);
            this.$growl = this.$growl.bind(this);
            this.html = this.html.bind(this);
            this.content = this.content.bind(this);
            this.container = this.container.bind(this);
            this.settings = $.extend({}, Growl.settings, settings);
            this.initialize(this.settings.location);
            this.render();
          }

          _createClass(Growl, [{
            key: "initialize",
            value: function initialize(location) {
              var id;
              id = 'growls-' + location;
              return $('body:not(:has(#' + id + '))').append('<div id="' + id + '" />');
            }
          }, {
            key: "render",
            value: function render() {
              var $growl;
              $growl = this.$growl();
              this.$growls(this.settings.location).append($growl);

              if (this.settings.fixed) {
                this.present();
              } else {
                this.cycle();
              }
            }
          }, {
            key: "bind",
            value: function bind() {
              var $growl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.$growl();
              $growl.on("click", this.click);

              if (this.settings.delayOnHover) {
                $growl.on("mouseenter", this.mouseEnter);
                $growl.on("mouseleave", this.mouseLeave);
              }

              return $growl.on("contextmenu", this.close).find("." + this.settings.namespace + "-close").on("click", this.close);
            }
          }, {
            key: "unbind",
            value: function unbind() {
              var $growl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.$growl();
              $growl.off("click", this.click);

              if (this.settings.delayOnHover) {
                $growl.off("mouseenter", this.mouseEnter);
                $growl.off("mouseleave", this.mouseLeave);
              }

              return $growl.off("contextmenu", this.close).find("." + this.settings.namespace + "-close").off("click", this.close);
            }
          }, {
            key: "mouseEnter",
            value: function mouseEnter(event) {
              var $growl;
              $growl = this.$growl();
              return $growl.stop(true, true);
            }
          }, {
            key: "mouseLeave",
            value: function mouseLeave(event) {
              return this.waitAndDismiss();
            }
          }, {
            key: "click",
            value: function click(event) {
              if (this.settings.url != null) {
                event.preventDefault();
                event.stopPropagation();
                return window.open(this.settings.url);
              }
            }
          }, {
            key: "close",
            value: function close(event) {
              var $growl;
              event.preventDefault();
              event.stopPropagation();
              $growl = this.$growl();
              return $growl.stop().queue(this.dismiss).queue(this.remove);
            }
          }, {
            key: "cycle",
            value: function cycle() {
              var $growl;
              $growl = this.$growl();
              return $growl.queue(this.present).queue(this.waitAndDismiss());
            }
          }, {
            key: "waitAndDismiss",
            value: function waitAndDismiss() {
              var $growl;
              $growl = this.$growl();
              return $growl.delay(this.settings.duration).queue(this.dismiss).queue(this.remove);
            }
          }, {
            key: "present",
            value: function present(callback) {
              var $growl;
              $growl = this.$growl();
              this.bind($growl);
              return this.animate($growl, this.settings.namespace + "-incoming", 'out', callback);
            }
          }, {
            key: "dismiss",
            value: function dismiss(callback) {
              var $growl;
              $growl = this.$growl();
              this.unbind($growl);
              return this.animate($growl, this.settings.namespace + "-outgoing", 'in', callback);
            }
          }, {
            key: "remove",
            value: function remove(callback) {
              this.$growl().remove();
              return typeof callback === "function" ? callback() : void 0;
            }
          }, {
            key: "animate",
            value: function animate($element, name) {
              var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'in';
              var callback = arguments[3];
              var transition;
              transition = Animation.transition($element);
              $element[direction === 'in' ? 'removeClass' : 'addClass'](name);
              $element.offset().position;
              $element[direction === 'in' ? 'addClass' : 'removeClass'](name);

              if (callback == null) {
                return;
              }

              if (transition != null) {
                $element.one(transition, callback);
              } else {
                callback();
              }
            }
          }, {
            key: "$growls",
            value: function $growls(location) {
              var base;

              if (this.$_growls == null) {
                this.$_growls = [];
              }

              return (base = this.$_growls)[location] != null ? base[location] : base[location] = $('#growls-' + location);
            }
          }, {
            key: "$growl",
            value: function $growl() {
              return this.$_growl != null ? this.$_growl : this.$_growl = $(this.html());
            }
          }, {
            key: "html",
            value: function html() {
              return this.container(this.content());
            }
          }, {
            key: "content",
            value: function content() {
              return "<div class='" + this.settings.namespace + "-close'>" + this.settings.close + "</div>\n<div class='" + this.settings.namespace + "-title'>" + this.settings.title + "</div>\n<div class='" + this.settings.namespace + "-message'>" + this.settings.message + "</div>";
            }
          }, {
            key: "container",
            value: function container(content) {
              return "<div class='" + this.settings.namespace + " " + this.settings.namespace + "-" + this.settings.style + " " + this.settings.namespace + "-" + this.settings.size + "'>\n  " + content + "\n</div>";
            }
          }]);

          return Growl;
        }();

        ;
        Growl.settings = {
          namespace: 'growl',
          duration: 3200,
          close: "&#215;",
          location: "default",
          style: "default",
          size: "medium",
          delayOnHover: true
        };
        return Growl;
      }();

      this.Growl = Growl;

      $.growl = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return Growl.growl(options);
      };

      $.growl.error = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var settings;
        settings = {
          title: "Error!",
          style: "error"
        };
        return $.growl($.extend(settings, options));
      };

      $.growl.notice = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var settings;
        settings = {
          title: "Notice!",
          style: "notice"
        };
        return $.growl($.extend(settings, options));
      };

      $.growl.warning = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var settings;
        settings = {
          title: "Warning!",
          style: "warning"
        };
        return $.growl($.extend(settings, options));
      };
    }).call(this);
    /***/
  },

  /***/
  "./resources/assets/vendor/libs/growl/growl.js":
  /*!*****************************************************!*\
    !*** ./resources/assets/vendor/libs/growl/growl.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function resourcesAssetsVendorLibsGrowlGrowlJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! jquery.growl/javascripts/jquery.growl.js */
    "./node_modules/jquery.growl/javascripts/jquery.growl.js");
    /***/

  },

  /***/
  76:
  /*!***********************************************************!*\
    !*** multi ./resources/assets/vendor/libs/growl/growl.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\xampp\htdocs\globalplanthire\resources\assets\vendor\libs\growl\growl.js */
    "./resources/assets/vendor/libs/growl/growl.js");
    /***/
  }
  /******/

}));

/***/ }),

/***/ "./resources/assets/libs/select2/select2.js":
/*!**************************************************!*\
  !*** ./resources/assets/libs/select2/select2.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(window,
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "/";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 102);
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "./node_modules/select2/dist/js/select2.full.js":
  /*!******************************************************!*\
    !*** ./node_modules/select2/dist/js/select2.full.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesSelect2DistJsSelect2FullJs(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

    var require;

    var require;
    /*!
    * Select2 4.0.13
    * https://select2.github.io
    *
    * Released under the MIT license
    * https://github.com/select2/select2/blob/master/LICENSE.md
    */


    ;

    (function (factory) {
      if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(
        /*! jquery */
        "jquery")], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      } else {}
    })(function (jQuery) {
      // This is needed so we can catch the AMD loader configuration and use it
      // The inner file should be wrapped (by `banner.start.js`) in a function that
      // returns the AMD loader references.
      var S2 = function () {
        // Restore the Select2 AMD loader so it can be used
        // Needed mostly in the language files, where the loader is not inserted
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
          var S2 = jQuery.fn.select2.amd;
        }

        var S2;

        (function () {
          if (!S2 || !S2.requirejs) {
            if (!S2) {
              S2 = {};
            } else {
              require = S2;
            }
            /**
             * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
             * Released under MIT license, http://github.com/requirejs/almond/LICENSE
             */
            //Going sloppy to avoid 'use strict' string cost, but strict practices should
            //be followed.

            /*global setTimeout: false */


            var requirejs, require, define;

            (function (undef) {
              var main,
                  _req,
                  makeMap,
                  handlers,
                  defined = {},
                  waiting = {},
                  config = {},
                  defining = {},
                  hasOwn = Object.prototype.hasOwnProperty,
                  aps = [].slice,
                  jsSuffixRegExp = /\.js$/;

              function hasProp(obj, prop) {
                return hasOwn.call(obj, prop);
              }
              /**
               * Given a relative module name, like ./something, normalize it to
               * a real name that can be mapped to a path.
               * @param {String} name the relative name
               * @param {String} baseName a real name that the name arg is relative
               * to.
               * @returns {String} normalized name
               */


              function normalize(name, baseName) {
                var nameParts,
                    nameSegment,
                    mapValue,
                    foundMap,
                    lastIndex,
                    foundI,
                    foundStarMap,
                    starI,
                    i,
                    j,
                    part,
                    normalizedBaseParts,
                    baseParts = baseName && baseName.split("/"),
                    map = config.map,
                    starMap = map && map['*'] || {}; //Adjust any relative paths.

                if (name) {
                  name = name.split('/');
                  lastIndex = name.length - 1; // If wanting node ID compatibility, strip .js from end
                  // of IDs. Have to do this here, and not in nameToUrl
                  // because node allows either .js or non .js to map
                  // to same file.

                  if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                  } // Starts with a '.' so need the baseName


                  if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                  } //start trimDots


                  for (i = 0; i < name.length; i++) {
                    part = name[i];

                    if (part === '.') {
                      name.splice(i, 1);
                      i -= 1;
                    } else if (part === '..') {
                      // If at the start, or previous value is still ..,
                      // keep them so that when converted to a path it may
                      // still work when converted to a path, even though
                      // as an ID it is less than ideal. In larger point
                      // releases, may be better to just kick out an error.
                      if (i === 0 || i === 1 && name[2] === '..' || name[i - 1] === '..') {
                        continue;
                      } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                      }
                    }
                  } //end trimDots


                  name = name.join('/');
                } //Apply map config if available.


                if ((baseParts || starMap) && map) {
                  nameParts = name.split('/');

                  for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join("/");

                    if (baseParts) {
                      //Find the longest baseName segment match in the config.
                      //So, do joins on the biggest to smallest lengths of baseParts.
                      for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')]; //baseName segment has  config, find if it has one for
                        //this name.

                        if (mapValue) {
                          mapValue = mapValue[nameSegment];

                          if (mapValue) {
                            //Match, update name to the new value.
                            foundMap = mapValue;
                            foundI = i;
                            break;
                          }
                        }
                      }
                    }

                    if (foundMap) {
                      break;
                    } //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.


                    if (!foundStarMap && starMap && starMap[nameSegment]) {
                      foundStarMap = starMap[nameSegment];
                      starI = i;
                    }
                  }

                  if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                  }

                  if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                  }
                }

                return name;
              }

              function makeRequire(relName, forceSync) {
                return function () {
                  //A version of a require function that passes a moduleName
                  //value for items that may need to
                  //look up paths relative to the moduleName
                  var args = aps.call(arguments, 0); //If first arg is not require('string'), and there is only
                  //one arg, it is the array form without a callback. Insert
                  //a null so that the following concat is correct.

                  if (typeof args[0] !== 'string' && args.length === 1) {
                    args.push(null);
                  }

                  return _req.apply(undef, args.concat([relName, forceSync]));
                };
              }

              function makeNormalize(relName) {
                return function (name) {
                  return normalize(name, relName);
                };
              }

              function makeLoad(depName) {
                return function (value) {
                  defined[depName] = value;
                };
              }

              function callDep(name) {
                if (hasProp(waiting, name)) {
                  var args = waiting[name];
                  delete waiting[name];
                  defining[name] = true;
                  main.apply(undef, args);
                }

                if (!hasProp(defined, name) && !hasProp(defining, name)) {
                  throw new Error('No ' + name);
                }

                return defined[name];
              } //Turns a plugin!resource to [plugin, resource]
              //with the plugin being undefined if the name
              //did not have a plugin prefix.


              function splitPrefix(name) {
                var prefix,
                    index = name ? name.indexOf('!') : -1;

                if (index > -1) {
                  prefix = name.substring(0, index);
                  name = name.substring(index + 1, name.length);
                }

                return [prefix, name];
              } //Creates a parts array for a relName where first part is plugin ID,
              //second part is resource ID. Assumes relName has already been normalized.


              function makeRelParts(relName) {
                return relName ? splitPrefix(relName) : [];
              }
              /**
               * Makes a name map, normalizing the name, and using a plugin
               * for normalization if necessary. Grabs a ref to plugin
               * too, as an optimization.
               */


              makeMap = function makeMap(name, relParts) {
                var plugin,
                    parts = splitPrefix(name),
                    prefix = parts[0],
                    relResourceName = relParts[1];
                name = parts[1];

                if (prefix) {
                  prefix = normalize(prefix, relResourceName);
                  plugin = callDep(prefix);
                } //Normalize according


                if (prefix) {
                  if (plugin && plugin.normalize) {
                    name = plugin.normalize(name, makeNormalize(relResourceName));
                  } else {
                    name = normalize(name, relResourceName);
                  }
                } else {
                  name = normalize(name, relResourceName);
                  parts = splitPrefix(name);
                  prefix = parts[0];
                  name = parts[1];

                  if (prefix) {
                    plugin = callDep(prefix);
                  }
                } //Using ridiculous property names for space reasons


                return {
                  f: prefix ? prefix + '!' + name : name,
                  //fullName
                  n: name,
                  pr: prefix,
                  p: plugin
                };
              };

              function makeConfig(name) {
                return function () {
                  return config && config.config && config.config[name] || {};
                };
              }

              handlers = {
                require: function require(name) {
                  return makeRequire(name);
                },
                exports: function exports(name) {
                  var e = defined[name];

                  if (typeof e !== 'undefined') {
                    return e;
                  } else {
                    return defined[name] = {};
                  }
                },
                module: function module(name) {
                  return {
                    id: name,
                    uri: '',
                    exports: defined[name],
                    config: makeConfig(name)
                  };
                }
              };

              main = function main(name, deps, callback, relName) {
                var cjsModule,
                    depName,
                    ret,
                    map,
                    i,
                    relParts,
                    args = [],
                    callbackType = _typeof(callback),
                    usingExports; //Use name if no relName


                relName = relName || name;
                relParts = makeRelParts(relName); //Call the callback to define the module, if necessary.

                if (callbackType === 'undefined' || callbackType === 'function') {
                  //Pull out the defined dependencies and pass the ordered
                  //values to the callback.
                  //Default to [require, exports, module] if no deps
                  deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;

                  for (i = 0; i < deps.length; i += 1) {
                    map = makeMap(deps[i], relParts);
                    depName = map.f; //Fast path CommonJS standard dependencies.

                    if (depName === "require") {
                      args[i] = handlers.require(name);
                    } else if (depName === "exports") {
                      //CommonJS module spec 1.1
                      args[i] = handlers.exports(name);
                      usingExports = true;
                    } else if (depName === "module") {
                      //CommonJS module spec 1.1
                      cjsModule = args[i] = handlers.module(name);
                    } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                      args[i] = callDep(depName);
                    } else if (map.p) {
                      map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                      args[i] = defined[depName];
                    } else {
                      throw new Error(name + ' missing ' + depName);
                    }
                  }

                  ret = callback ? callback.apply(defined[name], args) : undefined;

                  if (name) {
                    //If setting exports via "module" is in play,
                    //favor that over return value and exports. After that,
                    //favor a non-undefined return value over exports use.
                    if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                      defined[name] = cjsModule.exports;
                    } else if (ret !== undef || !usingExports) {
                      //Use the return value from the function.
                      defined[name] = ret;
                    }
                  }
                } else if (name) {
                  //May just be an object definition for the module. Only
                  //worry about defining if have a module name.
                  defined[name] = callback;
                }
              };

              requirejs = require = _req = function req(deps, callback, relName, forceSync, alt) {
                if (typeof deps === "string") {
                  if (handlers[deps]) {
                    //callback in this case is really relName
                    return handlers[deps](callback);
                  } //Just return the module wanted. In this scenario, the
                  //deps arg is the module name, and second arg (if passed)
                  //is just the relName.
                  //Normalize module name, if it contains . or ..


                  return callDep(makeMap(deps, makeRelParts(callback)).f);
                } else if (!deps.splice) {
                  //deps is a config object, not an array.
                  config = deps;

                  if (config.deps) {
                    _req(config.deps, config.callback);
                  }

                  if (!callback) {
                    return;
                  }

                  if (callback.splice) {
                    //callback is an array, which means it is a dependency list.
                    //Adjust args if there are dependencies
                    deps = callback;
                    callback = relName;
                    relName = null;
                  } else {
                    deps = undef;
                  }
                } //Support require(['a'])


                callback = callback || function () {}; //If relName is a function, it is an errback handler,
                //so remove it.


                if (typeof relName === 'function') {
                  relName = forceSync;
                  forceSync = alt;
                } //Simulate async callback;


                if (forceSync) {
                  main(undef, deps, callback, relName);
                } else {
                  //Using a non-zero value because of concern for what old browsers
                  //do, and latest browsers "upgrade" to 4 if lower value is used:
                  //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                  //If want a value immediately, use require('id') instead -- something
                  //that works in almond on the global level, but not guaranteed and
                  //unlikely to work in other AMD implementations.
                  setTimeout(function () {
                    main(undef, deps, callback, relName);
                  }, 4);
                }

                return _req;
              };
              /**
               * Just drops the config on the floor, but returns req in case
               * the config return value is used.
               */


              _req.config = function (cfg) {
                return _req(cfg);
              };
              /**
               * Expose module registry for debugging and tooling
               */


              requirejs._defined = defined;

              define = function define(name, deps, callback) {
                if (typeof name !== 'string') {
                  throw new Error('See almond README: incorrect module build, no module name');
                } //This module may not have dependencies


                if (!deps.splice) {
                  //deps is not an array, so probably means
                  //an object literal or factory function for
                  //the value. Adjust args.
                  callback = deps;
                  deps = [];
                }

                if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                  waiting[name] = [name, deps, callback];
                }
              };

              define.amd = {
                jQuery: true
              };
            })();

            S2.requirejs = requirejs;
            S2.require = require;
            S2.define = define;
          }
        })();

        S2.define("almond", function () {});
        /* global jQuery:false, $:false */

        S2.define('jquery', [], function () {
          var _$ = jQuery || $;

          if (_$ == null && console && console.error) {
            console.error('Select2: An instance of jQuery or a jQuery-compatible library was not ' + 'found. Make sure that you are including jQuery before Select2 on your ' + 'web page.');
          }

          return _$;
        });
        S2.define('select2/utils', ['jquery'], function ($) {
          var Utils = {};

          Utils.Extend = function (ChildClass, SuperClass) {
            var __hasProp = {}.hasOwnProperty;

            function BaseConstructor() {
              this.constructor = ChildClass;
            }

            for (var key in SuperClass) {
              if (__hasProp.call(SuperClass, key)) {
                ChildClass[key] = SuperClass[key];
              }
            }

            BaseConstructor.prototype = SuperClass.prototype;
            ChildClass.prototype = new BaseConstructor();
            ChildClass.__super__ = SuperClass.prototype;
            return ChildClass;
          };

          function getMethods(theClass) {
            var proto = theClass.prototype;
            var methods = [];

            for (var methodName in proto) {
              var m = proto[methodName];

              if (typeof m !== 'function') {
                continue;
              }

              if (methodName === 'constructor') {
                continue;
              }

              methods.push(methodName);
            }

            return methods;
          }

          Utils.Decorate = function (SuperClass, DecoratorClass) {
            var decoratedMethods = getMethods(DecoratorClass);
            var superMethods = getMethods(SuperClass);

            function DecoratedClass() {
              var unshift = Array.prototype.unshift;
              var argCount = DecoratorClass.prototype.constructor.length;
              var calledConstructor = SuperClass.prototype.constructor;

              if (argCount > 0) {
                unshift.call(arguments, SuperClass.prototype.constructor);
                calledConstructor = DecoratorClass.prototype.constructor;
              }

              calledConstructor.apply(this, arguments);
            }

            DecoratorClass.displayName = SuperClass.displayName;

            function ctr() {
              this.constructor = DecoratedClass;
            }

            DecoratedClass.prototype = new ctr();

            for (var m = 0; m < superMethods.length; m++) {
              var superMethod = superMethods[m];
              DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
            }

            var calledMethod = function calledMethod(methodName) {
              // Stub out the original method if it's not decorating an actual method
              var originalMethod = function originalMethod() {};

              if (methodName in DecoratedClass.prototype) {
                originalMethod = DecoratedClass.prototype[methodName];
              }

              var decoratedMethod = DecoratorClass.prototype[methodName];
              return function () {
                var unshift = Array.prototype.unshift;
                unshift.call(arguments, originalMethod);
                return decoratedMethod.apply(this, arguments);
              };
            };

            for (var d = 0; d < decoratedMethods.length; d++) {
              var decoratedMethod = decoratedMethods[d];
              DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
            }

            return DecoratedClass;
          };

          var Observable = function Observable() {
            this.listeners = {};
          };

          Observable.prototype.on = function (event, callback) {
            this.listeners = this.listeners || {};

            if (event in this.listeners) {
              this.listeners[event].push(callback);
            } else {
              this.listeners[event] = [callback];
            }
          };

          Observable.prototype.trigger = function (event) {
            var slice = Array.prototype.slice;
            var params = slice.call(arguments, 1);
            this.listeners = this.listeners || {}; // Params should always come in as an array

            if (params == null) {
              params = [];
            } // If there are no arguments to the event, use a temporary object


            if (params.length === 0) {
              params.push({});
            } // Set the `_type` of the first object to the event


            params[0]._type = event;

            if (event in this.listeners) {
              this.invoke(this.listeners[event], slice.call(arguments, 1));
            }

            if ('*' in this.listeners) {
              this.invoke(this.listeners['*'], arguments);
            }
          };

          Observable.prototype.invoke = function (listeners, params) {
            for (var i = 0, len = listeners.length; i < len; i++) {
              listeners[i].apply(this, params);
            }
          };

          Utils.Observable = Observable;

          Utils.generateChars = function (length) {
            var chars = '';

            for (var i = 0; i < length; i++) {
              var randomChar = Math.floor(Math.random() * 36);
              chars += randomChar.toString(36);
            }

            return chars;
          };

          Utils.bind = function (func, context) {
            return function () {
              func.apply(context, arguments);
            };
          };

          Utils._convertData = function (data) {
            for (var originalKey in data) {
              var keys = originalKey.split('-');
              var dataLevel = data;

              if (keys.length === 1) {
                continue;
              }

              for (var k = 0; k < keys.length; k++) {
                var key = keys[k]; // Lowercase the first letter
                // By default, dash-separated becomes camelCase

                key = key.substring(0, 1).toLowerCase() + key.substring(1);

                if (!(key in dataLevel)) {
                  dataLevel[key] = {};
                }

                if (k == keys.length - 1) {
                  dataLevel[key] = data[originalKey];
                }

                dataLevel = dataLevel[key];
              }

              delete data[originalKey];
            }

            return data;
          };

          Utils.hasScroll = function (index, el) {
            // Adapted from the function created by @ShadowScripter
            // and adapted by @BillBarry on the Stack Exchange Code Review website.
            // The original code can be found at
            // http://codereview.stackexchange.com/q/13338
            // and was designed to be used with the Sizzle selector engine.
            var $el = $(el);
            var overflowX = el.style.overflowX;
            var overflowY = el.style.overflowY; //Check both x and y declarations

            if (overflowX === overflowY && (overflowY === 'hidden' || overflowY === 'visible')) {
              return false;
            }

            if (overflowX === 'scroll' || overflowY === 'scroll') {
              return true;
            }

            return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
          };

          Utils.escapeMarkup = function (markup) {
            var replaceMap = {
              '\\': '&#92;',
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              '\'': '&#39;',
              '/': '&#47;'
            }; // Do not try to escape the markup if it's not a string

            if (typeof markup !== 'string') {
              return markup;
            }

            return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
              return replaceMap[match];
            });
          }; // Append an array of jQuery nodes to a given element.


          Utils.appendMany = function ($element, $nodes) {
            // jQuery 1.7.x does not support $.fn.append() with an array
            // Fall back to a jQuery object collection using $.fn.add()
            if ($.fn.jquery.substr(0, 3) === '1.7') {
              var $jqNodes = $();
              $.map($nodes, function (node) {
                $jqNodes = $jqNodes.add(node);
              });
              $nodes = $jqNodes;
            }

            $element.append($nodes);
          }; // Cache objects in Utils.__cache instead of $.data (see #4346)


          Utils.__cache = {};
          var id = 0;

          Utils.GetUniqueElementId = function (element) {
            // Get a unique element Id. If element has no id,
            // creates a new unique number, stores it in the id
            // attribute and returns the new id.
            // If an id already exists, it simply returns it.
            var select2Id = element.getAttribute('data-select2-id');

            if (select2Id == null) {
              // If element has id, use it.
              if (element.id) {
                select2Id = element.id;
                element.setAttribute('data-select2-id', select2Id);
              } else {
                element.setAttribute('data-select2-id', ++id);
                select2Id = id.toString();
              }
            }

            return select2Id;
          };

          Utils.StoreData = function (element, name, value) {
            // Stores an item in the cache for a specified element.
            // name is the cache key.
            var id = Utils.GetUniqueElementId(element);

            if (!Utils.__cache[id]) {
              Utils.__cache[id] = {};
            }

            Utils.__cache[id][name] = value;
          };

          Utils.GetData = function (element, name) {
            // Retrieves a value from the cache by its key (name)
            // name is optional. If no name specified, return
            // all cache items for the specified element.
            // and for a specified element.
            var id = Utils.GetUniqueElementId(element);

            if (name) {
              if (Utils.__cache[id]) {
                if (Utils.__cache[id][name] != null) {
                  return Utils.__cache[id][name];
                }

                return $(element).data(name); // Fallback to HTML5 data attribs.
              }

              return $(element).data(name); // Fallback to HTML5 data attribs.
            } else {
              return Utils.__cache[id];
            }
          };

          Utils.RemoveData = function (element) {
            // Removes all cached items for a specified element.
            var id = Utils.GetUniqueElementId(element);

            if (Utils.__cache[id] != null) {
              delete Utils.__cache[id];
            }

            element.removeAttribute('data-select2-id');
          };

          return Utils;
        });
        S2.define('select2/results', ['jquery', './utils'], function ($, Utils) {
          function Results($element, options, dataAdapter) {
            this.$element = $element;
            this.data = dataAdapter;
            this.options = options;

            Results.__super__.constructor.call(this);
          }

          Utils.Extend(Results, Utils.Observable);

          Results.prototype.render = function () {
            var $results = $('<ul class="select2-results__options" role="listbox"></ul>');

            if (this.options.get('multiple')) {
              $results.attr('aria-multiselectable', 'true');
            }

            this.$results = $results;
            return $results;
          };

          Results.prototype.clear = function () {
            this.$results.empty();
          };

          Results.prototype.displayMessage = function (params) {
            var escapeMarkup = this.options.get('escapeMarkup');
            this.clear();
            this.hideLoading();
            var $message = $('<li role="alert" aria-live="assertive"' + ' class="select2-results__option"></li>');
            var message = this.options.get('translations').get(params.message);
            $message.append(escapeMarkup(message(params.args)));
            $message[0].className += ' select2-results__message';
            this.$results.append($message);
          };

          Results.prototype.hideMessages = function () {
            this.$results.find('.select2-results__message').remove();
          };

          Results.prototype.append = function (data) {
            this.hideLoading();
            var $options = [];

            if (data.results == null || data.results.length === 0) {
              if (this.$results.children().length === 0) {
                this.trigger('results:message', {
                  message: 'noResults'
                });
              }

              return;
            }

            data.results = this.sort(data.results);

            for (var d = 0; d < data.results.length; d++) {
              var item = data.results[d];
              var $option = this.option(item);
              $options.push($option);
            }

            this.$results.append($options);
          };

          Results.prototype.position = function ($results, $dropdown) {
            var $resultsContainer = $dropdown.find('.select2-results');
            $resultsContainer.append($results);
          };

          Results.prototype.sort = function (data) {
            var sorter = this.options.get('sorter');
            return sorter(data);
          };

          Results.prototype.highlightFirstItem = function () {
            var $options = this.$results.find('.select2-results__option[aria-selected]');
            var $selected = $options.filter('[aria-selected=true]'); // Check if there are any selected options

            if ($selected.length > 0) {
              // If there are selected options, highlight the first
              $selected.first().trigger('mouseenter');
            } else {
              // If there are no selected options, highlight the first option
              // in the dropdown
              $options.first().trigger('mouseenter');
            }

            this.ensureHighlightVisible();
          };

          Results.prototype.setClasses = function () {
            var self = this;
            this.data.current(function (selected) {
              var selectedIds = $.map(selected, function (s) {
                return s.id.toString();
              });
              var $options = self.$results.find('.select2-results__option[aria-selected]');
              $options.each(function () {
                var $option = $(this);
                var item = Utils.GetData(this, 'data'); // id needs to be converted to a string when comparing

                var id = '' + item.id;

                if (item.element != null && item.element.selected || item.element == null && $.inArray(id, selectedIds) > -1) {
                  $option.attr('aria-selected', 'true');
                } else {
                  $option.attr('aria-selected', 'false');
                }
              });
            });
          };

          Results.prototype.showLoading = function (params) {
            this.hideLoading();
            var loadingMore = this.options.get('translations').get('searching');
            var loading = {
              disabled: true,
              loading: true,
              text: loadingMore(params)
            };
            var $loading = this.option(loading);
            $loading.className += ' loading-results';
            this.$results.prepend($loading);
          };

          Results.prototype.hideLoading = function () {
            this.$results.find('.loading-results').remove();
          };

          Results.prototype.option = function (data) {
            var option = document.createElement('li');
            option.className = 'select2-results__option';
            var attrs = {
              'role': 'option',
              'aria-selected': 'false'
            };
            var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;

            if (data.element != null && matches.call(data.element, ':disabled') || data.element == null && data.disabled) {
              delete attrs['aria-selected'];
              attrs['aria-disabled'] = 'true';
            }

            if (data.id == null) {
              delete attrs['aria-selected'];
            }

            if (data._resultId != null) {
              option.id = data._resultId;
            }

            if (data.title) {
              option.title = data.title;
            }

            if (data.children) {
              attrs.role = 'group';
              attrs['aria-label'] = data.text;
              delete attrs['aria-selected'];
            }

            for (var attr in attrs) {
              var val = attrs[attr];
              option.setAttribute(attr, val);
            }

            if (data.children) {
              var $option = $(option);
              var label = document.createElement('strong');
              label.className = 'select2-results__group';
              var $label = $(label);
              this.template(data, label);
              var $children = [];

              for (var c = 0; c < data.children.length; c++) {
                var child = data.children[c];
                var $child = this.option(child);
                $children.push($child);
              }

              var $childrenContainer = $('<ul></ul>', {
                'class': 'select2-results__options select2-results__options--nested'
              });
              $childrenContainer.append($children);
              $option.append(label);
              $option.append($childrenContainer);
            } else {
              this.template(data, option);
            }

            Utils.StoreData(option, 'data', data);
            return option;
          };

          Results.prototype.bind = function (container, $container) {
            var self = this;
            var id = container.id + '-results';
            this.$results.attr('id', id);
            container.on('results:all', function (params) {
              self.clear();
              self.append(params.data);

              if (container.isOpen()) {
                self.setClasses();
                self.highlightFirstItem();
              }
            });
            container.on('results:append', function (params) {
              self.append(params.data);

              if (container.isOpen()) {
                self.setClasses();
              }
            });
            container.on('query', function (params) {
              self.hideMessages();
              self.showLoading(params);
            });
            container.on('select', function () {
              if (!container.isOpen()) {
                return;
              }

              self.setClasses();

              if (self.options.get('scrollAfterSelect')) {
                self.highlightFirstItem();
              }
            });
            container.on('unselect', function () {
              if (!container.isOpen()) {
                return;
              }

              self.setClasses();

              if (self.options.get('scrollAfterSelect')) {
                self.highlightFirstItem();
              }
            });
            container.on('open', function () {
              // When the dropdown is open, aria-expended="true"
              self.$results.attr('aria-expanded', 'true');
              self.$results.attr('aria-hidden', 'false');
              self.setClasses();
              self.ensureHighlightVisible();
            });
            container.on('close', function () {
              // When the dropdown is closed, aria-expended="false"
              self.$results.attr('aria-expanded', 'false');
              self.$results.attr('aria-hidden', 'true');
              self.$results.removeAttr('aria-activedescendant');
            });
            container.on('results:toggle', function () {
              var $highlighted = self.getHighlightedResults();

              if ($highlighted.length === 0) {
                return;
              }

              $highlighted.trigger('mouseup');
            });
            container.on('results:select', function () {
              var $highlighted = self.getHighlightedResults();

              if ($highlighted.length === 0) {
                return;
              }

              var data = Utils.GetData($highlighted[0], 'data');

              if ($highlighted.attr('aria-selected') == 'true') {
                self.trigger('close', {});
              } else {
                self.trigger('select', {
                  data: data
                });
              }
            });
            container.on('results:previous', function () {
              var $highlighted = self.getHighlightedResults();
              var $options = self.$results.find('[aria-selected]');
              var currentIndex = $options.index($highlighted); // If we are already at the top, don't move further
              // If no options, currentIndex will be -1

              if (currentIndex <= 0) {
                return;
              }

              var nextIndex = currentIndex - 1; // If none are highlighted, highlight the first

              if ($highlighted.length === 0) {
                nextIndex = 0;
              }

              var $next = $options.eq(nextIndex);
              $next.trigger('mouseenter');
              var currentOffset = self.$results.offset().top;
              var nextTop = $next.offset().top;
              var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

              if (nextIndex === 0) {
                self.$results.scrollTop(0);
              } else if (nextTop - currentOffset < 0) {
                self.$results.scrollTop(nextOffset);
              }
            });
            container.on('results:next', function () {
              var $highlighted = self.getHighlightedResults();
              var $options = self.$results.find('[aria-selected]');
              var currentIndex = $options.index($highlighted);
              var nextIndex = currentIndex + 1; // If we are at the last option, stay there

              if (nextIndex >= $options.length) {
                return;
              }

              var $next = $options.eq(nextIndex);
              $next.trigger('mouseenter');
              var currentOffset = self.$results.offset().top + self.$results.outerHeight(false);
              var nextBottom = $next.offset().top + $next.outerHeight(false);
              var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

              if (nextIndex === 0) {
                self.$results.scrollTop(0);
              } else if (nextBottom > currentOffset) {
                self.$results.scrollTop(nextOffset);
              }
            });
            container.on('results:focus', function (params) {
              params.element.addClass('select2-results__option--highlighted');
            });
            container.on('results:message', function (params) {
              self.displayMessage(params);
            });

            if ($.fn.mousewheel) {
              this.$results.on('mousewheel', function (e) {
                var top = self.$results.scrollTop();
                var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
                var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
                var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

                if (isAtTop) {
                  self.$results.scrollTop(0);
                  e.preventDefault();
                  e.stopPropagation();
                } else if (isAtBottom) {
                  self.$results.scrollTop(self.$results.get(0).scrollHeight - self.$results.height());
                  e.preventDefault();
                  e.stopPropagation();
                }
              });
            }

            this.$results.on('mouseup', '.select2-results__option[aria-selected]', function (evt) {
              var $this = $(this);
              var data = Utils.GetData(this, 'data');

              if ($this.attr('aria-selected') === 'true') {
                if (self.options.get('multiple')) {
                  self.trigger('unselect', {
                    originalEvent: evt,
                    data: data
                  });
                } else {
                  self.trigger('close', {});
                }

                return;
              }

              self.trigger('select', {
                originalEvent: evt,
                data: data
              });
            });
            this.$results.on('mouseenter', '.select2-results__option[aria-selected]', function (evt) {
              var data = Utils.GetData(this, 'data');
              self.getHighlightedResults().removeClass('select2-results__option--highlighted');
              self.trigger('results:focus', {
                data: data,
                element: $(this)
              });
            });
          };

          Results.prototype.getHighlightedResults = function () {
            var $highlighted = this.$results.find('.select2-results__option--highlighted');
            return $highlighted;
          };

          Results.prototype.destroy = function () {
            this.$results.remove();
          };

          Results.prototype.ensureHighlightVisible = function () {
            var $highlighted = this.getHighlightedResults();

            if ($highlighted.length === 0) {
              return;
            }

            var $options = this.$results.find('[aria-selected]');
            var currentIndex = $options.index($highlighted);
            var currentOffset = this.$results.offset().top;
            var nextTop = $highlighted.offset().top;
            var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
            var offsetDelta = nextTop - currentOffset;
            nextOffset -= $highlighted.outerHeight(false) * 2;

            if (currentIndex <= 2) {
              this.$results.scrollTop(0);
            } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
              this.$results.scrollTop(nextOffset);
            }
          };

          Results.prototype.template = function (result, container) {
            var template = this.options.get('templateResult');
            var escapeMarkup = this.options.get('escapeMarkup');
            var content = template(result, container);

            if (content == null) {
              container.style.display = 'none';
            } else if (typeof content === 'string') {
              container.innerHTML = escapeMarkup(content);
            } else {
              $(container).append(content);
            }
          };

          return Results;
        });
        S2.define('select2/keys', [], function () {
          var KEYS = {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            ESC: 27,
            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            DELETE: 46
          };
          return KEYS;
        });
        S2.define('select2/selection/base', ['jquery', '../utils', '../keys'], function ($, Utils, KEYS) {
          function BaseSelection($element, options) {
            this.$element = $element;
            this.options = options;

            BaseSelection.__super__.constructor.call(this);
          }

          Utils.Extend(BaseSelection, Utils.Observable);

          BaseSelection.prototype.render = function () {
            var $selection = $('<span class="select2-selection" role="combobox" ' + ' aria-haspopup="true" aria-expanded="false">' + '</span>');
            this._tabindex = 0;

            if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {
              this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');
            } else if (this.$element.attr('tabindex') != null) {
              this._tabindex = this.$element.attr('tabindex');
            }

            $selection.attr('title', this.$element.attr('title'));
            $selection.attr('tabindex', this._tabindex);
            $selection.attr('aria-disabled', 'false');
            this.$selection = $selection;
            return $selection;
          };

          BaseSelection.prototype.bind = function (container, $container) {
            var self = this;
            var resultsId = container.id + '-results';
            this.container = container;
            this.$selection.on('focus', function (evt) {
              self.trigger('focus', evt);
            });
            this.$selection.on('blur', function (evt) {
              self._handleBlur(evt);
            });
            this.$selection.on('keydown', function (evt) {
              self.trigger('keypress', evt);

              if (evt.which === KEYS.SPACE) {
                evt.preventDefault();
              }
            });
            container.on('results:focus', function (params) {
              self.$selection.attr('aria-activedescendant', params.data._resultId);
            });
            container.on('selection:update', function (params) {
              self.update(params.data);
            });
            container.on('open', function () {
              // When the dropdown is open, aria-expanded="true"
              self.$selection.attr('aria-expanded', 'true');
              self.$selection.attr('aria-owns', resultsId);

              self._attachCloseHandler(container);
            });
            container.on('close', function () {
              // When the dropdown is closed, aria-expanded="false"
              self.$selection.attr('aria-expanded', 'false');
              self.$selection.removeAttr('aria-activedescendant');
              self.$selection.removeAttr('aria-owns');
              self.$selection.trigger('focus');

              self._detachCloseHandler(container);
            });
            container.on('enable', function () {
              self.$selection.attr('tabindex', self._tabindex);
              self.$selection.attr('aria-disabled', 'false');
            });
            container.on('disable', function () {
              self.$selection.attr('tabindex', '-1');
              self.$selection.attr('aria-disabled', 'true');
            });
          };

          BaseSelection.prototype._handleBlur = function (evt) {
            var self = this; // This needs to be delayed as the active element is the body when the tab
            // key is pressed, possibly along with others.

            window.setTimeout(function () {
              // Don't trigger `blur` if the focus is still in the selection
              if (document.activeElement == self.$selection[0] || $.contains(self.$selection[0], document.activeElement)) {
                return;
              }

              self.trigger('blur', evt);
            }, 1);
          };

          BaseSelection.prototype._attachCloseHandler = function (container) {
            $(document.body).on('mousedown.select2.' + container.id, function (e) {
              var $target = $(e.target);
              var $select = $target.closest('.select2');
              var $all = $('.select2.select2-container--open');
              $all.each(function () {
                if (this == $select[0]) {
                  return;
                }

                var $element = Utils.GetData(this, 'element');
                $element.select2('close');
              });
            });
          };

          BaseSelection.prototype._detachCloseHandler = function (container) {
            $(document.body).off('mousedown.select2.' + container.id);
          };

          BaseSelection.prototype.position = function ($selection, $container) {
            var $selectionContainer = $container.find('.selection');
            $selectionContainer.append($selection);
          };

          BaseSelection.prototype.destroy = function () {
            this._detachCloseHandler(this.container);
          };

          BaseSelection.prototype.update = function (data) {
            throw new Error('The `update` method must be defined in child classes.');
          };
          /**
           * Helper method to abstract the "enabled" (not "disabled") state of this
           * object.
           *
           * @return {true} if the instance is not disabled.
           * @return {false} if the instance is disabled.
           */


          BaseSelection.prototype.isEnabled = function () {
            return !this.isDisabled();
          };
          /**
           * Helper method to abstract the "disabled" state of this object.
           *
           * @return {true} if the disabled option is true.
           * @return {false} if the disabled option is false.
           */


          BaseSelection.prototype.isDisabled = function () {
            return this.options.get('disabled');
          };

          return BaseSelection;
        });
        S2.define('select2/selection/single', ['jquery', './base', '../utils', '../keys'], function ($, BaseSelection, Utils, KEYS) {
          function SingleSelection() {
            SingleSelection.__super__.constructor.apply(this, arguments);
          }

          Utils.Extend(SingleSelection, BaseSelection);

          SingleSelection.prototype.render = function () {
            var $selection = SingleSelection.__super__.render.call(this);

            $selection.addClass('select2-selection--single');
            $selection.html('<span class="select2-selection__rendered"></span>' + '<span class="select2-selection__arrow" role="presentation">' + '<b role="presentation"></b>' + '</span>');
            return $selection;
          };

          SingleSelection.prototype.bind = function (container, $container) {
            var self = this;

            SingleSelection.__super__.bind.apply(this, arguments);

            var id = container.id + '-container';
            this.$selection.find('.select2-selection__rendered').attr('id', id).attr('role', 'textbox').attr('aria-readonly', 'true');
            this.$selection.attr('aria-labelledby', id);
            this.$selection.on('mousedown', function (evt) {
              // Only respond to left clicks
              if (evt.which !== 1) {
                return;
              }

              self.trigger('toggle', {
                originalEvent: evt
              });
            });
            this.$selection.on('focus', function (evt) {// User focuses on the container
            });
            this.$selection.on('blur', function (evt) {// User exits the container
            });
            container.on('focus', function (evt) {
              if (!container.isOpen()) {
                self.$selection.trigger('focus');
              }
            });
          };

          SingleSelection.prototype.clear = function () {
            var $rendered = this.$selection.find('.select2-selection__rendered');
            $rendered.empty();
            $rendered.removeAttr('title'); // clear tooltip on empty
          };

          SingleSelection.prototype.display = function (data, container) {
            var template = this.options.get('templateSelection');
            var escapeMarkup = this.options.get('escapeMarkup');
            return escapeMarkup(template(data, container));
          };

          SingleSelection.prototype.selectionContainer = function () {
            return $('<span></span>');
          };

          SingleSelection.prototype.update = function (data) {
            if (data.length === 0) {
              this.clear();
              return;
            }

            var selection = data[0];
            var $rendered = this.$selection.find('.select2-selection__rendered');
            var formatted = this.display(selection, $rendered);
            $rendered.empty().append(formatted);
            var title = selection.title || selection.text;

            if (title) {
              $rendered.attr('title', title);
            } else {
              $rendered.removeAttr('title');
            }
          };

          return SingleSelection;
        });
        S2.define('select2/selection/multiple', ['jquery', './base', '../utils'], function ($, BaseSelection, Utils) {
          function MultipleSelection($element, options) {
            MultipleSelection.__super__.constructor.apply(this, arguments);
          }

          Utils.Extend(MultipleSelection, BaseSelection);

          MultipleSelection.prototype.render = function () {
            var $selection = MultipleSelection.__super__.render.call(this);

            $selection.addClass('select2-selection--multiple');
            $selection.html('<ul class="select2-selection__rendered"></ul>');
            return $selection;
          };

          MultipleSelection.prototype.bind = function (container, $container) {
            var self = this;

            MultipleSelection.__super__.bind.apply(this, arguments);

            this.$selection.on('click', function (evt) {
              self.trigger('toggle', {
                originalEvent: evt
              });
            });
            this.$selection.on('click', '.select2-selection__choice__remove', function (evt) {
              // Ignore the event if it is disabled
              if (self.isDisabled()) {
                return;
              }

              var $remove = $(this);
              var $selection = $remove.parent();
              var data = Utils.GetData($selection[0], 'data');
              self.trigger('unselect', {
                originalEvent: evt,
                data: data
              });
            });
          };

          MultipleSelection.prototype.clear = function () {
            var $rendered = this.$selection.find('.select2-selection__rendered');
            $rendered.empty();
            $rendered.removeAttr('title');
          };

          MultipleSelection.prototype.display = function (data, container) {
            var template = this.options.get('templateSelection');
            var escapeMarkup = this.options.get('escapeMarkup');
            return escapeMarkup(template(data, container));
          };

          MultipleSelection.prototype.selectionContainer = function () {
            var $container = $('<li class="select2-selection__choice">' + '<span class="select2-selection__choice__remove" role="presentation">' + '&times;' + '</span>' + '</li>');
            return $container;
          };

          MultipleSelection.prototype.update = function (data) {
            this.clear();

            if (data.length === 0) {
              return;
            }

            var $selections = [];

            for (var d = 0; d < data.length; d++) {
              var selection = data[d];
              var $selection = this.selectionContainer();
              var formatted = this.display(selection, $selection);
              $selection.append(formatted);
              var title = selection.title || selection.text;

              if (title) {
                $selection.attr('title', title);
              }

              Utils.StoreData($selection[0], 'data', selection);
              $selections.push($selection);
            }

            var $rendered = this.$selection.find('.select2-selection__rendered');
            Utils.appendMany($rendered, $selections);
          };

          return MultipleSelection;
        });
        S2.define('select2/selection/placeholder', ['../utils'], function (Utils) {
          function Placeholder(decorated, $element, options) {
            this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
            decorated.call(this, $element, options);
          }

          Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
            if (typeof placeholder === 'string') {
              placeholder = {
                id: '',
                text: placeholder
              };
            }

            return placeholder;
          };

          Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
            var $placeholder = this.selectionContainer();
            $placeholder.html(this.display(placeholder));
            $placeholder.addClass('select2-selection__placeholder').removeClass('select2-selection__choice');
            return $placeholder;
          };

          Placeholder.prototype.update = function (decorated, data) {
            var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
            var multipleSelections = data.length > 1;

            if (multipleSelections || singlePlaceholder) {
              return decorated.call(this, data);
            }

            this.clear();
            var $placeholder = this.createPlaceholder(this.placeholder);
            this.$selection.find('.select2-selection__rendered').append($placeholder);
          };

          return Placeholder;
        });
        S2.define('select2/selection/allowClear', ['jquery', '../keys', '../utils'], function ($, KEYS, Utils) {
          function AllowClear() {}

          AllowClear.prototype.bind = function (decorated, container, $container) {
            var self = this;
            decorated.call(this, container, $container);

            if (this.placeholder == null) {
              if (this.options.get('debug') && window.console && console.error) {
                console.error('Select2: The `allowClear` option should be used in combination ' + 'with the `placeholder` option.');
              }
            }

            this.$selection.on('mousedown', '.select2-selection__clear', function (evt) {
              self._handleClear(evt);
            });
            container.on('keypress', function (evt) {
              self._handleKeyboardClear(evt, container);
            });
          };

          AllowClear.prototype._handleClear = function (_, evt) {
            // Ignore the event if it is disabled
            if (this.isDisabled()) {
              return;
            }

            var $clear = this.$selection.find('.select2-selection__clear'); // Ignore the event if nothing has been selected

            if ($clear.length === 0) {
              return;
            }

            evt.stopPropagation();
            var data = Utils.GetData($clear[0], 'data');
            var previousVal = this.$element.val();
            this.$element.val(this.placeholder.id);
            var unselectData = {
              data: data
            };
            this.trigger('clear', unselectData);

            if (unselectData.prevented) {
              this.$element.val(previousVal);
              return;
            }

            for (var d = 0; d < data.length; d++) {
              unselectData = {
                data: data[d]
              }; // Trigger the `unselect` event, so people can prevent it from being
              // cleared.

              this.trigger('unselect', unselectData); // If the event was prevented, don't clear it out.

              if (unselectData.prevented) {
                this.$element.val(previousVal);
                return;
              }
            }

            this.$element.trigger('input').trigger('change');
            this.trigger('toggle', {});
          };

          AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
            if (container.isOpen()) {
              return;
            }

            if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
              this._handleClear(evt);
            }
          };

          AllowClear.prototype.update = function (decorated, data) {
            decorated.call(this, data);

            if (this.$selection.find('.select2-selection__placeholder').length > 0 || data.length === 0) {
              return;
            }

            var removeAll = this.options.get('translations').get('removeAllItems');
            var $remove = $('<span class="select2-selection__clear" title="' + removeAll() + '">' + '&times;' + '</span>');
            Utils.StoreData($remove[0], 'data', data);
            this.$selection.find('.select2-selection__rendered').prepend($remove);
          };

          return AllowClear;
        });
        S2.define('select2/selection/search', ['jquery', '../utils', '../keys'], function ($, Utils, KEYS) {
          function Search(decorated, $element, options) {
            decorated.call(this, $element, options);
          }

          Search.prototype.render = function (decorated) {
            var $search = $('<li class="select2-search select2-search--inline">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocomplete="off" autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' + '</li>');
            this.$searchContainer = $search;
            this.$search = $search.find('input');
            var $rendered = decorated.call(this);

            this._transferTabIndex();

            return $rendered;
          };

          Search.prototype.bind = function (decorated, container, $container) {
            var self = this;
            var resultsId = container.id + '-results';
            decorated.call(this, container, $container);
            container.on('open', function () {
              self.$search.attr('aria-controls', resultsId);
              self.$search.trigger('focus');
            });
            container.on('close', function () {
              self.$search.val('');
              self.$search.removeAttr('aria-controls');
              self.$search.removeAttr('aria-activedescendant');
              self.$search.trigger('focus');
            });
            container.on('enable', function () {
              self.$search.prop('disabled', false);

              self._transferTabIndex();
            });
            container.on('disable', function () {
              self.$search.prop('disabled', true);
            });
            container.on('focus', function (evt) {
              self.$search.trigger('focus');
            });
            container.on('results:focus', function (params) {
              if (params.data._resultId) {
                self.$search.attr('aria-activedescendant', params.data._resultId);
              } else {
                self.$search.removeAttr('aria-activedescendant');
              }
            });
            this.$selection.on('focusin', '.select2-search--inline', function (evt) {
              self.trigger('focus', evt);
            });
            this.$selection.on('focusout', '.select2-search--inline', function (evt) {
              self._handleBlur(evt);
            });
            this.$selection.on('keydown', '.select2-search--inline', function (evt) {
              evt.stopPropagation();
              self.trigger('keypress', evt);
              self._keyUpPrevented = evt.isDefaultPrevented();
              var key = evt.which;

              if (key === KEYS.BACKSPACE && self.$search.val() === '') {
                var $previousChoice = self.$searchContainer.prev('.select2-selection__choice');

                if ($previousChoice.length > 0) {
                  var item = Utils.GetData($previousChoice[0], 'data');
                  self.searchRemoveChoice(item);
                  evt.preventDefault();
                }
              }
            });
            this.$selection.on('click', '.select2-search--inline', function (evt) {
              if (self.$search.val()) {
                evt.stopPropagation();
              }
            }); // Try to detect the IE version should the `documentMode` property that
            // is stored on the document. This is only implemented in IE and is
            // slightly cleaner than doing a user agent check.
            // This property is not available in Edge, but Edge also doesn't have
            // this bug.

            var msie = document.documentMode;
            var disableInputEvents = msie && msie <= 11; // Workaround for browsers which do not support the `input` event
            // This will prevent double-triggering of events for browsers which support
            // both the `keyup` and `input` events.

            this.$selection.on('input.searchcheck', '.select2-search--inline', function (evt) {
              // IE will trigger the `input` event when a placeholder is used on a
              // search box. To get around this issue, we are forced to ignore all
              // `input` events in IE and keep using `keyup`.
              if (disableInputEvents) {
                self.$selection.off('input.search input.searchcheck');
                return;
              } // Unbind the duplicated `keyup` event


              self.$selection.off('keyup.search');
            });
            this.$selection.on('keyup.search input.search', '.select2-search--inline', function (evt) {
              // IE will trigger the `input` event when a placeholder is used on a
              // search box. To get around this issue, we are forced to ignore all
              // `input` events in IE and keep using `keyup`.
              if (disableInputEvents && evt.type === 'input') {
                self.$selection.off('input.search input.searchcheck');
                return;
              }

              var key = evt.which; // We can freely ignore events from modifier keys

              if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                return;
              } // Tabbing will be handled during the `keydown` phase


              if (key == KEYS.TAB) {
                return;
              }

              self.handleSearch(evt);
            });
          };
          /**
           * This method will transfer the tabindex attribute from the rendered
           * selection to the search box. This allows for the search box to be used as
           * the primary focus instead of the selection container.
           *
           * @private
           */


          Search.prototype._transferTabIndex = function (decorated) {
            this.$search.attr('tabindex', this.$selection.attr('tabindex'));
            this.$selection.attr('tabindex', '-1');
          };

          Search.prototype.createPlaceholder = function (decorated, placeholder) {
            this.$search.attr('placeholder', placeholder.text);
          };

          Search.prototype.update = function (decorated, data) {
            var searchHadFocus = this.$search[0] == document.activeElement;
            this.$search.attr('placeholder', '');
            decorated.call(this, data);
            this.$selection.find('.select2-selection__rendered').append(this.$searchContainer);
            this.resizeSearch();

            if (searchHadFocus) {
              this.$search.trigger('focus');
            }
          };

          Search.prototype.handleSearch = function () {
            this.resizeSearch();

            if (!this._keyUpPrevented) {
              var input = this.$search.val();
              this.trigger('query', {
                term: input
              });
            }

            this._keyUpPrevented = false;
          };

          Search.prototype.searchRemoveChoice = function (decorated, item) {
            this.trigger('unselect', {
              data: item
            });
            this.$search.val(item.text);
            this.handleSearch();
          };

          Search.prototype.resizeSearch = function () {
            this.$search.css('width', '25px');
            var width = '';

            if (this.$search.attr('placeholder') !== '') {
              width = this.$selection.find('.select2-selection__rendered').width();
            } else {
              var minimumWidth = this.$search.val().length + 1;
              width = minimumWidth * 0.75 + 'em';
            }

            this.$search.css('width', width);
          };

          return Search;
        });
        S2.define('select2/selection/eventRelay', ['jquery'], function ($) {
          function EventRelay() {}

          EventRelay.prototype.bind = function (decorated, container, $container) {
            var self = this;
            var relayEvents = ['open', 'opening', 'close', 'closing', 'select', 'selecting', 'unselect', 'unselecting', 'clear', 'clearing'];
            var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting', 'clearing'];
            decorated.call(this, container, $container);
            container.on('*', function (name, params) {
              // Ignore events that should not be relayed
              if ($.inArray(name, relayEvents) === -1) {
                return;
              } // The parameters should always be an object


              params = params || {}; // Generate the jQuery event for the Select2 event

              var evt = $.Event('select2:' + name, {
                params: params
              });
              self.$element.trigger(evt); // Only handle preventable events if it was one

              if ($.inArray(name, preventableEvents) === -1) {
                return;
              }

              params.prevented = evt.isDefaultPrevented();
            });
          };

          return EventRelay;
        });
        S2.define('select2/translation', ['jquery', 'require'], function ($, require) {
          function Translation(dict) {
            this.dict = dict || {};
          }

          Translation.prototype.all = function () {
            return this.dict;
          };

          Translation.prototype.get = function (key) {
            return this.dict[key];
          };

          Translation.prototype.extend = function (translation) {
            this.dict = $.extend({}, translation.all(), this.dict);
          }; // Static functions


          Translation._cache = {};

          Translation.loadPath = function (path) {
            if (!(path in Translation._cache)) {
              var translations = require(path);

              Translation._cache[path] = translations;
            }

            return new Translation(Translation._cache[path]);
          };

          return Translation;
        });
        S2.define('select2/diacritics', [], function () {
          var diacritics = {
            "\u24B6": 'A',
            "\uFF21": 'A',
            "\xC0": 'A',
            "\xC1": 'A',
            "\xC2": 'A',
            "\u1EA6": 'A',
            "\u1EA4": 'A',
            "\u1EAA": 'A',
            "\u1EA8": 'A',
            "\xC3": 'A',
            "\u0100": 'A',
            "\u0102": 'A',
            "\u1EB0": 'A',
            "\u1EAE": 'A',
            "\u1EB4": 'A',
            "\u1EB2": 'A',
            "\u0226": 'A',
            "\u01E0": 'A',
            "\xC4": 'A',
            "\u01DE": 'A',
            "\u1EA2": 'A',
            "\xC5": 'A',
            "\u01FA": 'A',
            "\u01CD": 'A',
            "\u0200": 'A',
            "\u0202": 'A',
            "\u1EA0": 'A',
            "\u1EAC": 'A',
            "\u1EB6": 'A',
            "\u1E00": 'A',
            "\u0104": 'A',
            "\u023A": 'A',
            "\u2C6F": 'A',
            "\uA732": 'AA',
            "\xC6": 'AE',
            "\u01FC": 'AE',
            "\u01E2": 'AE',
            "\uA734": 'AO',
            "\uA736": 'AU',
            "\uA738": 'AV',
            "\uA73A": 'AV',
            "\uA73C": 'AY',
            "\u24B7": 'B',
            "\uFF22": 'B',
            "\u1E02": 'B',
            "\u1E04": 'B',
            "\u1E06": 'B',
            "\u0243": 'B',
            "\u0182": 'B',
            "\u0181": 'B',
            "\u24B8": 'C',
            "\uFF23": 'C',
            "\u0106": 'C',
            "\u0108": 'C',
            "\u010A": 'C',
            "\u010C": 'C',
            "\xC7": 'C',
            "\u1E08": 'C',
            "\u0187": 'C',
            "\u023B": 'C',
            "\uA73E": 'C',
            "\u24B9": 'D',
            "\uFF24": 'D',
            "\u1E0A": 'D',
            "\u010E": 'D',
            "\u1E0C": 'D',
            "\u1E10": 'D',
            "\u1E12": 'D',
            "\u1E0E": 'D',
            "\u0110": 'D',
            "\u018B": 'D',
            "\u018A": 'D',
            "\u0189": 'D',
            "\uA779": 'D',
            "\u01F1": 'DZ',
            "\u01C4": 'DZ',
            "\u01F2": 'Dz',
            "\u01C5": 'Dz',
            "\u24BA": 'E',
            "\uFF25": 'E',
            "\xC8": 'E',
            "\xC9": 'E',
            "\xCA": 'E',
            "\u1EC0": 'E',
            "\u1EBE": 'E',
            "\u1EC4": 'E',
            "\u1EC2": 'E',
            "\u1EBC": 'E',
            "\u0112": 'E',
            "\u1E14": 'E',
            "\u1E16": 'E',
            "\u0114": 'E',
            "\u0116": 'E',
            "\xCB": 'E',
            "\u1EBA": 'E',
            "\u011A": 'E',
            "\u0204": 'E',
            "\u0206": 'E',
            "\u1EB8": 'E',
            "\u1EC6": 'E',
            "\u0228": 'E',
            "\u1E1C": 'E',
            "\u0118": 'E',
            "\u1E18": 'E',
            "\u1E1A": 'E',
            "\u0190": 'E',
            "\u018E": 'E',
            "\u24BB": 'F',
            "\uFF26": 'F',
            "\u1E1E": 'F',
            "\u0191": 'F',
            "\uA77B": 'F',
            "\u24BC": 'G',
            "\uFF27": 'G',
            "\u01F4": 'G',
            "\u011C": 'G',
            "\u1E20": 'G',
            "\u011E": 'G',
            "\u0120": 'G',
            "\u01E6": 'G',
            "\u0122": 'G',
            "\u01E4": 'G',
            "\u0193": 'G',
            "\uA7A0": 'G',
            "\uA77D": 'G',
            "\uA77E": 'G',
            "\u24BD": 'H',
            "\uFF28": 'H',
            "\u0124": 'H',
            "\u1E22": 'H',
            "\u1E26": 'H',
            "\u021E": 'H',
            "\u1E24": 'H',
            "\u1E28": 'H',
            "\u1E2A": 'H',
            "\u0126": 'H',
            "\u2C67": 'H',
            "\u2C75": 'H',
            "\uA78D": 'H',
            "\u24BE": 'I',
            "\uFF29": 'I',
            "\xCC": 'I',
            "\xCD": 'I',
            "\xCE": 'I',
            "\u0128": 'I',
            "\u012A": 'I',
            "\u012C": 'I',
            "\u0130": 'I',
            "\xCF": 'I',
            "\u1E2E": 'I',
            "\u1EC8": 'I',
            "\u01CF": 'I',
            "\u0208": 'I',
            "\u020A": 'I',
            "\u1ECA": 'I',
            "\u012E": 'I',
            "\u1E2C": 'I',
            "\u0197": 'I',
            "\u24BF": 'J',
            "\uFF2A": 'J',
            "\u0134": 'J',
            "\u0248": 'J',
            "\u24C0": 'K',
            "\uFF2B": 'K',
            "\u1E30": 'K',
            "\u01E8": 'K',
            "\u1E32": 'K',
            "\u0136": 'K',
            "\u1E34": 'K',
            "\u0198": 'K',
            "\u2C69": 'K',
            "\uA740": 'K',
            "\uA742": 'K',
            "\uA744": 'K',
            "\uA7A2": 'K',
            "\u24C1": 'L',
            "\uFF2C": 'L',
            "\u013F": 'L',
            "\u0139": 'L',
            "\u013D": 'L',
            "\u1E36": 'L',
            "\u1E38": 'L',
            "\u013B": 'L',
            "\u1E3C": 'L',
            "\u1E3A": 'L',
            "\u0141": 'L',
            "\u023D": 'L',
            "\u2C62": 'L',
            "\u2C60": 'L',
            "\uA748": 'L',
            "\uA746": 'L',
            "\uA780": 'L',
            "\u01C7": 'LJ',
            "\u01C8": 'Lj',
            "\u24C2": 'M',
            "\uFF2D": 'M',
            "\u1E3E": 'M',
            "\u1E40": 'M',
            "\u1E42": 'M',
            "\u2C6E": 'M',
            "\u019C": 'M',
            "\u24C3": 'N',
            "\uFF2E": 'N',
            "\u01F8": 'N',
            "\u0143": 'N',
            "\xD1": 'N',
            "\u1E44": 'N',
            "\u0147": 'N',
            "\u1E46": 'N',
            "\u0145": 'N',
            "\u1E4A": 'N',
            "\u1E48": 'N',
            "\u0220": 'N',
            "\u019D": 'N',
            "\uA790": 'N',
            "\uA7A4": 'N',
            "\u01CA": 'NJ',
            "\u01CB": 'Nj',
            "\u24C4": 'O',
            "\uFF2F": 'O',
            "\xD2": 'O',
            "\xD3": 'O',
            "\xD4": 'O',
            "\u1ED2": 'O',
            "\u1ED0": 'O',
            "\u1ED6": 'O',
            "\u1ED4": 'O',
            "\xD5": 'O',
            "\u1E4C": 'O',
            "\u022C": 'O',
            "\u1E4E": 'O',
            "\u014C": 'O',
            "\u1E50": 'O',
            "\u1E52": 'O',
            "\u014E": 'O',
            "\u022E": 'O',
            "\u0230": 'O',
            "\xD6": 'O',
            "\u022A": 'O',
            "\u1ECE": 'O',
            "\u0150": 'O',
            "\u01D1": 'O',
            "\u020C": 'O',
            "\u020E": 'O',
            "\u01A0": 'O',
            "\u1EDC": 'O',
            "\u1EDA": 'O',
            "\u1EE0": 'O',
            "\u1EDE": 'O',
            "\u1EE2": 'O',
            "\u1ECC": 'O',
            "\u1ED8": 'O',
            "\u01EA": 'O',
            "\u01EC": 'O',
            "\xD8": 'O',
            "\u01FE": 'O',
            "\u0186": 'O',
            "\u019F": 'O',
            "\uA74A": 'O',
            "\uA74C": 'O',
            "\u0152": 'OE',
            "\u01A2": 'OI',
            "\uA74E": 'OO',
            "\u0222": 'OU',
            "\u24C5": 'P',
            "\uFF30": 'P',
            "\u1E54": 'P',
            "\u1E56": 'P',
            "\u01A4": 'P',
            "\u2C63": 'P',
            "\uA750": 'P',
            "\uA752": 'P',
            "\uA754": 'P',
            "\u24C6": 'Q',
            "\uFF31": 'Q',
            "\uA756": 'Q',
            "\uA758": 'Q',
            "\u024A": 'Q',
            "\u24C7": 'R',
            "\uFF32": 'R',
            "\u0154": 'R',
            "\u1E58": 'R',
            "\u0158": 'R',
            "\u0210": 'R',
            "\u0212": 'R',
            "\u1E5A": 'R',
            "\u1E5C": 'R',
            "\u0156": 'R',
            "\u1E5E": 'R',
            "\u024C": 'R',
            "\u2C64": 'R',
            "\uA75A": 'R',
            "\uA7A6": 'R',
            "\uA782": 'R',
            "\u24C8": 'S',
            "\uFF33": 'S',
            "\u1E9E": 'S',
            "\u015A": 'S',
            "\u1E64": 'S',
            "\u015C": 'S',
            "\u1E60": 'S',
            "\u0160": 'S',
            "\u1E66": 'S',
            "\u1E62": 'S',
            "\u1E68": 'S',
            "\u0218": 'S',
            "\u015E": 'S',
            "\u2C7E": 'S',
            "\uA7A8": 'S',
            "\uA784": 'S',
            "\u24C9": 'T',
            "\uFF34": 'T',
            "\u1E6A": 'T',
            "\u0164": 'T',
            "\u1E6C": 'T',
            "\u021A": 'T',
            "\u0162": 'T',
            "\u1E70": 'T',
            "\u1E6E": 'T',
            "\u0166": 'T',
            "\u01AC": 'T',
            "\u01AE": 'T',
            "\u023E": 'T',
            "\uA786": 'T',
            "\uA728": 'TZ',
            "\u24CA": 'U',
            "\uFF35": 'U',
            "\xD9": 'U',
            "\xDA": 'U',
            "\xDB": 'U',
            "\u0168": 'U',
            "\u1E78": 'U',
            "\u016A": 'U',
            "\u1E7A": 'U',
            "\u016C": 'U',
            "\xDC": 'U',
            "\u01DB": 'U',
            "\u01D7": 'U',
            "\u01D5": 'U',
            "\u01D9": 'U',
            "\u1EE6": 'U',
            "\u016E": 'U',
            "\u0170": 'U',
            "\u01D3": 'U',
            "\u0214": 'U',
            "\u0216": 'U',
            "\u01AF": 'U',
            "\u1EEA": 'U',
            "\u1EE8": 'U',
            "\u1EEE": 'U',
            "\u1EEC": 'U',
            "\u1EF0": 'U',
            "\u1EE4": 'U',
            "\u1E72": 'U',
            "\u0172": 'U',
            "\u1E76": 'U',
            "\u1E74": 'U',
            "\u0244": 'U',
            "\u24CB": 'V',
            "\uFF36": 'V',
            "\u1E7C": 'V',
            "\u1E7E": 'V',
            "\u01B2": 'V',
            "\uA75E": 'V',
            "\u0245": 'V',
            "\uA760": 'VY',
            "\u24CC": 'W',
            "\uFF37": 'W',
            "\u1E80": 'W',
            "\u1E82": 'W',
            "\u0174": 'W',
            "\u1E86": 'W',
            "\u1E84": 'W',
            "\u1E88": 'W',
            "\u2C72": 'W',
            "\u24CD": 'X',
            "\uFF38": 'X',
            "\u1E8A": 'X',
            "\u1E8C": 'X',
            "\u24CE": 'Y',
            "\uFF39": 'Y',
            "\u1EF2": 'Y',
            "\xDD": 'Y',
            "\u0176": 'Y',
            "\u1EF8": 'Y',
            "\u0232": 'Y',
            "\u1E8E": 'Y',
            "\u0178": 'Y',
            "\u1EF6": 'Y',
            "\u1EF4": 'Y',
            "\u01B3": 'Y',
            "\u024E": 'Y',
            "\u1EFE": 'Y',
            "\u24CF": 'Z',
            "\uFF3A": 'Z',
            "\u0179": 'Z',
            "\u1E90": 'Z',
            "\u017B": 'Z',
            "\u017D": 'Z',
            "\u1E92": 'Z',
            "\u1E94": 'Z',
            "\u01B5": 'Z',
            "\u0224": 'Z',
            "\u2C7F": 'Z',
            "\u2C6B": 'Z',
            "\uA762": 'Z',
            "\u24D0": 'a',
            "\uFF41": 'a',
            "\u1E9A": 'a',
            "\xE0": 'a',
            "\xE1": 'a',
            "\xE2": 'a',
            "\u1EA7": 'a',
            "\u1EA5": 'a',
            "\u1EAB": 'a',
            "\u1EA9": 'a',
            "\xE3": 'a',
            "\u0101": 'a',
            "\u0103": 'a',
            "\u1EB1": 'a',
            "\u1EAF": 'a',
            "\u1EB5": 'a',
            "\u1EB3": 'a',
            "\u0227": 'a',
            "\u01E1": 'a',
            "\xE4": 'a',
            "\u01DF": 'a',
            "\u1EA3": 'a',
            "\xE5": 'a',
            "\u01FB": 'a',
            "\u01CE": 'a',
            "\u0201": 'a',
            "\u0203": 'a',
            "\u1EA1": 'a',
            "\u1EAD": 'a',
            "\u1EB7": 'a',
            "\u1E01": 'a',
            "\u0105": 'a',
            "\u2C65": 'a',
            "\u0250": 'a',
            "\uA733": 'aa',
            "\xE6": 'ae',
            "\u01FD": 'ae',
            "\u01E3": 'ae',
            "\uA735": 'ao',
            "\uA737": 'au',
            "\uA739": 'av',
            "\uA73B": 'av',
            "\uA73D": 'ay',
            "\u24D1": 'b',
            "\uFF42": 'b',
            "\u1E03": 'b',
            "\u1E05": 'b',
            "\u1E07": 'b',
            "\u0180": 'b',
            "\u0183": 'b',
            "\u0253": 'b',
            "\u24D2": 'c',
            "\uFF43": 'c',
            "\u0107": 'c',
            "\u0109": 'c',
            "\u010B": 'c',
            "\u010D": 'c',
            "\xE7": 'c',
            "\u1E09": 'c',
            "\u0188": 'c',
            "\u023C": 'c',
            "\uA73F": 'c',
            "\u2184": 'c',
            "\u24D3": 'd',
            "\uFF44": 'd',
            "\u1E0B": 'd',
            "\u010F": 'd',
            "\u1E0D": 'd',
            "\u1E11": 'd',
            "\u1E13": 'd',
            "\u1E0F": 'd',
            "\u0111": 'd',
            "\u018C": 'd',
            "\u0256": 'd',
            "\u0257": 'd',
            "\uA77A": 'd',
            "\u01F3": 'dz',
            "\u01C6": 'dz',
            "\u24D4": 'e',
            "\uFF45": 'e',
            "\xE8": 'e',
            "\xE9": 'e',
            "\xEA": 'e',
            "\u1EC1": 'e',
            "\u1EBF": 'e',
            "\u1EC5": 'e',
            "\u1EC3": 'e',
            "\u1EBD": 'e',
            "\u0113": 'e',
            "\u1E15": 'e',
            "\u1E17": 'e',
            "\u0115": 'e',
            "\u0117": 'e',
            "\xEB": 'e',
            "\u1EBB": 'e',
            "\u011B": 'e',
            "\u0205": 'e',
            "\u0207": 'e',
            "\u1EB9": 'e',
            "\u1EC7": 'e',
            "\u0229": 'e',
            "\u1E1D": 'e',
            "\u0119": 'e',
            "\u1E19": 'e',
            "\u1E1B": 'e',
            "\u0247": 'e',
            "\u025B": 'e',
            "\u01DD": 'e',
            "\u24D5": 'f',
            "\uFF46": 'f',
            "\u1E1F": 'f',
            "\u0192": 'f',
            "\uA77C": 'f',
            "\u24D6": 'g',
            "\uFF47": 'g',
            "\u01F5": 'g',
            "\u011D": 'g',
            "\u1E21": 'g',
            "\u011F": 'g',
            "\u0121": 'g',
            "\u01E7": 'g',
            "\u0123": 'g',
            "\u01E5": 'g',
            "\u0260": 'g',
            "\uA7A1": 'g',
            "\u1D79": 'g',
            "\uA77F": 'g',
            "\u24D7": 'h',
            "\uFF48": 'h',
            "\u0125": 'h',
            "\u1E23": 'h',
            "\u1E27": 'h',
            "\u021F": 'h',
            "\u1E25": 'h',
            "\u1E29": 'h',
            "\u1E2B": 'h',
            "\u1E96": 'h',
            "\u0127": 'h',
            "\u2C68": 'h',
            "\u2C76": 'h',
            "\u0265": 'h',
            "\u0195": 'hv',
            "\u24D8": 'i',
            "\uFF49": 'i',
            "\xEC": 'i',
            "\xED": 'i',
            "\xEE": 'i',
            "\u0129": 'i',
            "\u012B": 'i',
            "\u012D": 'i',
            "\xEF": 'i',
            "\u1E2F": 'i',
            "\u1EC9": 'i',
            "\u01D0": 'i',
            "\u0209": 'i',
            "\u020B": 'i',
            "\u1ECB": 'i',
            "\u012F": 'i',
            "\u1E2D": 'i',
            "\u0268": 'i',
            "\u0131": 'i',
            "\u24D9": 'j',
            "\uFF4A": 'j',
            "\u0135": 'j',
            "\u01F0": 'j',
            "\u0249": 'j',
            "\u24DA": 'k',
            "\uFF4B": 'k',
            "\u1E31": 'k',
            "\u01E9": 'k',
            "\u1E33": 'k',
            "\u0137": 'k',
            "\u1E35": 'k',
            "\u0199": 'k',
            "\u2C6A": 'k',
            "\uA741": 'k',
            "\uA743": 'k',
            "\uA745": 'k',
            "\uA7A3": 'k',
            "\u24DB": 'l',
            "\uFF4C": 'l',
            "\u0140": 'l',
            "\u013A": 'l',
            "\u013E": 'l',
            "\u1E37": 'l',
            "\u1E39": 'l',
            "\u013C": 'l',
            "\u1E3D": 'l',
            "\u1E3B": 'l',
            "\u017F": 'l',
            "\u0142": 'l',
            "\u019A": 'l',
            "\u026B": 'l',
            "\u2C61": 'l',
            "\uA749": 'l',
            "\uA781": 'l',
            "\uA747": 'l',
            "\u01C9": 'lj',
            "\u24DC": 'm',
            "\uFF4D": 'm',
            "\u1E3F": 'm',
            "\u1E41": 'm',
            "\u1E43": 'm',
            "\u0271": 'm',
            "\u026F": 'm',
            "\u24DD": 'n',
            "\uFF4E": 'n',
            "\u01F9": 'n',
            "\u0144": 'n',
            "\xF1": 'n',
            "\u1E45": 'n',
            "\u0148": 'n',
            "\u1E47": 'n',
            "\u0146": 'n',
            "\u1E4B": 'n',
            "\u1E49": 'n',
            "\u019E": 'n',
            "\u0272": 'n',
            "\u0149": 'n',
            "\uA791": 'n',
            "\uA7A5": 'n',
            "\u01CC": 'nj',
            "\u24DE": 'o',
            "\uFF4F": 'o',
            "\xF2": 'o',
            "\xF3": 'o',
            "\xF4": 'o',
            "\u1ED3": 'o',
            "\u1ED1": 'o',
            "\u1ED7": 'o',
            "\u1ED5": 'o',
            "\xF5": 'o',
            "\u1E4D": 'o',
            "\u022D": 'o',
            "\u1E4F": 'o',
            "\u014D": 'o',
            "\u1E51": 'o',
            "\u1E53": 'o',
            "\u014F": 'o',
            "\u022F": 'o',
            "\u0231": 'o',
            "\xF6": 'o',
            "\u022B": 'o',
            "\u1ECF": 'o',
            "\u0151": 'o',
            "\u01D2": 'o',
            "\u020D": 'o',
            "\u020F": 'o',
            "\u01A1": 'o',
            "\u1EDD": 'o',
            "\u1EDB": 'o',
            "\u1EE1": 'o',
            "\u1EDF": 'o',
            "\u1EE3": 'o',
            "\u1ECD": 'o',
            "\u1ED9": 'o',
            "\u01EB": 'o',
            "\u01ED": 'o',
            "\xF8": 'o',
            "\u01FF": 'o',
            "\u0254": 'o',
            "\uA74B": 'o',
            "\uA74D": 'o',
            "\u0275": 'o',
            "\u0153": 'oe',
            "\u01A3": 'oi',
            "\u0223": 'ou',
            "\uA74F": 'oo',
            "\u24DF": 'p',
            "\uFF50": 'p',
            "\u1E55": 'p',
            "\u1E57": 'p',
            "\u01A5": 'p',
            "\u1D7D": 'p',
            "\uA751": 'p',
            "\uA753": 'p',
            "\uA755": 'p',
            "\u24E0": 'q',
            "\uFF51": 'q',
            "\u024B": 'q',
            "\uA757": 'q',
            "\uA759": 'q',
            "\u24E1": 'r',
            "\uFF52": 'r',
            "\u0155": 'r',
            "\u1E59": 'r',
            "\u0159": 'r',
            "\u0211": 'r',
            "\u0213": 'r',
            "\u1E5B": 'r',
            "\u1E5D": 'r',
            "\u0157": 'r',
            "\u1E5F": 'r',
            "\u024D": 'r',
            "\u027D": 'r',
            "\uA75B": 'r',
            "\uA7A7": 'r',
            "\uA783": 'r',
            "\u24E2": 's',
            "\uFF53": 's',
            "\xDF": 's',
            "\u015B": 's',
            "\u1E65": 's',
            "\u015D": 's',
            "\u1E61": 's',
            "\u0161": 's',
            "\u1E67": 's',
            "\u1E63": 's',
            "\u1E69": 's',
            "\u0219": 's',
            "\u015F": 's',
            "\u023F": 's',
            "\uA7A9": 's',
            "\uA785": 's',
            "\u1E9B": 's',
            "\u24E3": 't',
            "\uFF54": 't',
            "\u1E6B": 't',
            "\u1E97": 't',
            "\u0165": 't',
            "\u1E6D": 't',
            "\u021B": 't',
            "\u0163": 't',
            "\u1E71": 't',
            "\u1E6F": 't',
            "\u0167": 't',
            "\u01AD": 't',
            "\u0288": 't',
            "\u2C66": 't',
            "\uA787": 't',
            "\uA729": 'tz',
            "\u24E4": 'u',
            "\uFF55": 'u',
            "\xF9": 'u',
            "\xFA": 'u',
            "\xFB": 'u',
            "\u0169": 'u',
            "\u1E79": 'u',
            "\u016B": 'u',
            "\u1E7B": 'u',
            "\u016D": 'u',
            "\xFC": 'u',
            "\u01DC": 'u',
            "\u01D8": 'u',
            "\u01D6": 'u',
            "\u01DA": 'u',
            "\u1EE7": 'u',
            "\u016F": 'u',
            "\u0171": 'u',
            "\u01D4": 'u',
            "\u0215": 'u',
            "\u0217": 'u',
            "\u01B0": 'u',
            "\u1EEB": 'u',
            "\u1EE9": 'u',
            "\u1EEF": 'u',
            "\u1EED": 'u',
            "\u1EF1": 'u',
            "\u1EE5": 'u',
            "\u1E73": 'u',
            "\u0173": 'u',
            "\u1E77": 'u',
            "\u1E75": 'u',
            "\u0289": 'u',
            "\u24E5": 'v',
            "\uFF56": 'v',
            "\u1E7D": 'v',
            "\u1E7F": 'v',
            "\u028B": 'v',
            "\uA75F": 'v',
            "\u028C": 'v',
            "\uA761": 'vy',
            "\u24E6": 'w',
            "\uFF57": 'w',
            "\u1E81": 'w',
            "\u1E83": 'w',
            "\u0175": 'w',
            "\u1E87": 'w',
            "\u1E85": 'w',
            "\u1E98": 'w',
            "\u1E89": 'w',
            "\u2C73": 'w',
            "\u24E7": 'x',
            "\uFF58": 'x',
            "\u1E8B": 'x',
            "\u1E8D": 'x',
            "\u24E8": 'y',
            "\uFF59": 'y',
            "\u1EF3": 'y',
            "\xFD": 'y',
            "\u0177": 'y',
            "\u1EF9": 'y',
            "\u0233": 'y',
            "\u1E8F": 'y',
            "\xFF": 'y',
            "\u1EF7": 'y',
            "\u1E99": 'y',
            "\u1EF5": 'y',
            "\u01B4": 'y',
            "\u024F": 'y',
            "\u1EFF": 'y',
            "\u24E9": 'z',
            "\uFF5A": 'z',
            "\u017A": 'z',
            "\u1E91": 'z',
            "\u017C": 'z',
            "\u017E": 'z',
            "\u1E93": 'z',
            "\u1E95": 'z',
            "\u01B6": 'z',
            "\u0225": 'z',
            "\u0240": 'z',
            "\u2C6C": 'z',
            "\uA763": 'z',
            "\u0386": "\u0391",
            "\u0388": "\u0395",
            "\u0389": "\u0397",
            "\u038A": "\u0399",
            "\u03AA": "\u0399",
            "\u038C": "\u039F",
            "\u038E": "\u03A5",
            "\u03AB": "\u03A5",
            "\u038F": "\u03A9",
            "\u03AC": "\u03B1",
            "\u03AD": "\u03B5",
            "\u03AE": "\u03B7",
            "\u03AF": "\u03B9",
            "\u03CA": "\u03B9",
            "\u0390": "\u03B9",
            "\u03CC": "\u03BF",
            "\u03CD": "\u03C5",
            "\u03CB": "\u03C5",
            "\u03B0": "\u03C5",
            "\u03CE": "\u03C9",
            "\u03C2": "\u03C3",
            "\u2019": '\''
          };
          return diacritics;
        });
        S2.define('select2/data/base', ['../utils'], function (Utils) {
          function BaseAdapter($element, options) {
            BaseAdapter.__super__.constructor.call(this);
          }

          Utils.Extend(BaseAdapter, Utils.Observable);

          BaseAdapter.prototype.current = function (callback) {
            throw new Error('The `current` method must be defined in child classes.');
          };

          BaseAdapter.prototype.query = function (params, callback) {
            throw new Error('The `query` method must be defined in child classes.');
          };

          BaseAdapter.prototype.bind = function (container, $container) {// Can be implemented in subclasses
          };

          BaseAdapter.prototype.destroy = function () {// Can be implemented in subclasses
          };

          BaseAdapter.prototype.generateResultId = function (container, data) {
            var id = container.id + '-result-';
            id += Utils.generateChars(4);

            if (data.id != null) {
              id += '-' + data.id.toString();
            } else {
              id += '-' + Utils.generateChars(4);
            }

            return id;
          };

          return BaseAdapter;
        });
        S2.define('select2/data/select', ['./base', '../utils', 'jquery'], function (BaseAdapter, Utils, $) {
          function SelectAdapter($element, options) {
            this.$element = $element;
            this.options = options;

            SelectAdapter.__super__.constructor.call(this);
          }

          Utils.Extend(SelectAdapter, BaseAdapter);

          SelectAdapter.prototype.current = function (callback) {
            var data = [];
            var self = this;
            this.$element.find(':selected').each(function () {
              var $option = $(this);
              var option = self.item($option);
              data.push(option);
            });
            callback(data);
          };

          SelectAdapter.prototype.select = function (data) {
            var self = this;
            data.selected = true; // If data.element is a DOM node, use it instead

            if ($(data.element).is('option')) {
              data.element.selected = true;
              this.$element.trigger('input').trigger('change');
              return;
            }

            if (this.$element.prop('multiple')) {
              this.current(function (currentData) {
                var val = [];
                data = [data];
                data.push.apply(data, currentData);

                for (var d = 0; d < data.length; d++) {
                  var id = data[d].id;

                  if ($.inArray(id, val) === -1) {
                    val.push(id);
                  }
                }

                self.$element.val(val);
                self.$element.trigger('input').trigger('change');
              });
            } else {
              var val = data.id;
              this.$element.val(val);
              this.$element.trigger('input').trigger('change');
            }
          };

          SelectAdapter.prototype.unselect = function (data) {
            var self = this;

            if (!this.$element.prop('multiple')) {
              return;
            }

            data.selected = false;

            if ($(data.element).is('option')) {
              data.element.selected = false;
              this.$element.trigger('input').trigger('change');
              return;
            }

            this.current(function (currentData) {
              var val = [];

              for (var d = 0; d < currentData.length; d++) {
                var id = currentData[d].id;

                if (id !== data.id && $.inArray(id, val) === -1) {
                  val.push(id);
                }
              }

              self.$element.val(val);
              self.$element.trigger('input').trigger('change');
            });
          };

          SelectAdapter.prototype.bind = function (container, $container) {
            var self = this;
            this.container = container;
            container.on('select', function (params) {
              self.select(params.data);
            });
            container.on('unselect', function (params) {
              self.unselect(params.data);
            });
          };

          SelectAdapter.prototype.destroy = function () {
            // Remove anything added to child elements
            this.$element.find('*').each(function () {
              // Remove any custom data set by Select2
              Utils.RemoveData(this);
            });
          };

          SelectAdapter.prototype.query = function (params, callback) {
            var data = [];
            var self = this;
            var $options = this.$element.children();
            $options.each(function () {
              var $option = $(this);

              if (!$option.is('option') && !$option.is('optgroup')) {
                return;
              }

              var option = self.item($option);
              var matches = self.matches(params, option);

              if (matches !== null) {
                data.push(matches);
              }
            });
            callback({
              results: data
            });
          };

          SelectAdapter.prototype.addOptions = function ($options) {
            Utils.appendMany(this.$element, $options);
          };

          SelectAdapter.prototype.option = function (data) {
            var option;

            if (data.children) {
              option = document.createElement('optgroup');
              option.label = data.text;
            } else {
              option = document.createElement('option');

              if (option.textContent !== undefined) {
                option.textContent = data.text;
              } else {
                option.innerText = data.text;
              }
            }

            if (data.id !== undefined) {
              option.value = data.id;
            }

            if (data.disabled) {
              option.disabled = true;
            }

            if (data.selected) {
              option.selected = true;
            }

            if (data.title) {
              option.title = data.title;
            }

            var $option = $(option);

            var normalizedData = this._normalizeItem(data);

            normalizedData.element = option; // Override the option's data with the combined data

            Utils.StoreData(option, 'data', normalizedData);
            return $option;
          };

          SelectAdapter.prototype.item = function ($option) {
            var data = {};
            data = Utils.GetData($option[0], 'data');

            if (data != null) {
              return data;
            }

            if ($option.is('option')) {
              data = {
                id: $option.val(),
                text: $option.text(),
                disabled: $option.prop('disabled'),
                selected: $option.prop('selected'),
                title: $option.prop('title')
              };
            } else if ($option.is('optgroup')) {
              data = {
                text: $option.prop('label'),
                children: [],
                title: $option.prop('title')
              };
              var $children = $option.children('option');
              var children = [];

              for (var c = 0; c < $children.length; c++) {
                var $child = $($children[c]);
                var child = this.item($child);
                children.push(child);
              }

              data.children = children;
            }

            data = this._normalizeItem(data);
            data.element = $option[0];
            Utils.StoreData($option[0], 'data', data);
            return data;
          };

          SelectAdapter.prototype._normalizeItem = function (item) {
            if (item !== Object(item)) {
              item = {
                id: item,
                text: item
              };
            }

            item = $.extend({}, {
              text: ''
            }, item);
            var defaults = {
              selected: false,
              disabled: false
            };

            if (item.id != null) {
              item.id = item.id.toString();
            }

            if (item.text != null) {
              item.text = item.text.toString();
            }

            if (item._resultId == null && item.id && this.container != null) {
              item._resultId = this.generateResultId(this.container, item);
            }

            return $.extend({}, defaults, item);
          };

          SelectAdapter.prototype.matches = function (params, data) {
            var matcher = this.options.get('matcher');
            return matcher(params, data);
          };

          return SelectAdapter;
        });
        S2.define('select2/data/array', ['./select', '../utils', 'jquery'], function (SelectAdapter, Utils, $) {
          function ArrayAdapter($element, options) {
            this._dataToConvert = options.get('data') || [];

            ArrayAdapter.__super__.constructor.call(this, $element, options);
          }

          Utils.Extend(ArrayAdapter, SelectAdapter);

          ArrayAdapter.prototype.bind = function (container, $container) {
            ArrayAdapter.__super__.bind.call(this, container, $container);

            this.addOptions(this.convertToOptions(this._dataToConvert));
          };

          ArrayAdapter.prototype.select = function (data) {
            var $option = this.$element.find('option').filter(function (i, elm) {
              return elm.value == data.id.toString();
            });

            if ($option.length === 0) {
              $option = this.option(data);
              this.addOptions($option);
            }

            ArrayAdapter.__super__.select.call(this, data);
          };

          ArrayAdapter.prototype.convertToOptions = function (data) {
            var self = this;
            var $existing = this.$element.find('option');
            var existingIds = $existing.map(function () {
              return self.item($(this)).id;
            }).get();
            var $options = []; // Filter out all items except for the one passed in the argument

            function onlyItem(item) {
              return function () {
                return $(this).val() == item.id;
              };
            }

            for (var d = 0; d < data.length; d++) {
              var item = this._normalizeItem(data[d]); // Skip items which were pre-loaded, only merge the data


              if ($.inArray(item.id, existingIds) >= 0) {
                var $existingOption = $existing.filter(onlyItem(item));
                var existingData = this.item($existingOption);
                var newData = $.extend(true, {}, item, existingData);
                var $newOption = this.option(newData);
                $existingOption.replaceWith($newOption);
                continue;
              }

              var $option = this.option(item);

              if (item.children) {
                var $children = this.convertToOptions(item.children);
                Utils.appendMany($option, $children);
              }

              $options.push($option);
            }

            return $options;
          };

          return ArrayAdapter;
        });
        S2.define('select2/data/ajax', ['./array', '../utils', 'jquery'], function (ArrayAdapter, Utils, $) {
          function AjaxAdapter($element, options) {
            this.ajaxOptions = this._applyDefaults(options.get('ajax'));

            if (this.ajaxOptions.processResults != null) {
              this.processResults = this.ajaxOptions.processResults;
            }

            AjaxAdapter.__super__.constructor.call(this, $element, options);
          }

          Utils.Extend(AjaxAdapter, ArrayAdapter);

          AjaxAdapter.prototype._applyDefaults = function (options) {
            var defaults = {
              data: function data(params) {
                return $.extend({}, params, {
                  q: params.term
                });
              },
              transport: function transport(params, success, failure) {
                var $request = $.ajax(params);
                $request.then(success);
                $request.fail(failure);
                return $request;
              }
            };
            return $.extend({}, defaults, options, true);
          };

          AjaxAdapter.prototype.processResults = function (results) {
            return results;
          };

          AjaxAdapter.prototype.query = function (params, callback) {
            var matches = [];
            var self = this;

            if (this._request != null) {
              // JSONP requests cannot always be aborted
              if ($.isFunction(this._request.abort)) {
                this._request.abort();
              }

              this._request = null;
            }

            var options = $.extend({
              type: 'GET'
            }, this.ajaxOptions);

            if (typeof options.url === 'function') {
              options.url = options.url.call(this.$element, params);
            }

            if (typeof options.data === 'function') {
              options.data = options.data.call(this.$element, params);
            }

            function request() {
              var $request = options.transport(options, function (data) {
                var results = self.processResults(data, params);

                if (self.options.get('debug') && window.console && console.error) {
                  // Check to make sure that the response included a `results` key.
                  if (!results || !results.results || !$.isArray(results.results)) {
                    console.error('Select2: The AJAX results did not return an array in the ' + '`results` key of the response.');
                  }
                }

                callback(results);
              }, function () {
                // Attempt to detect if a request was aborted
                // Only works if the transport exposes a status property
                if ('status' in $request && ($request.status === 0 || $request.status === '0')) {
                  return;
                }

                self.trigger('results:message', {
                  message: 'errorLoading'
                });
              });
              self._request = $request;
            }

            if (this.ajaxOptions.delay && params.term != null) {
              if (this._queryTimeout) {
                window.clearTimeout(this._queryTimeout);
              }

              this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
            } else {
              request();
            }
          };

          return AjaxAdapter;
        });
        S2.define('select2/data/tags', ['jquery'], function ($) {
          function Tags(decorated, $element, options) {
            var tags = options.get('tags');
            var createTag = options.get('createTag');

            if (createTag !== undefined) {
              this.createTag = createTag;
            }

            var insertTag = options.get('insertTag');

            if (insertTag !== undefined) {
              this.insertTag = insertTag;
            }

            decorated.call(this, $element, options);

            if ($.isArray(tags)) {
              for (var t = 0; t < tags.length; t++) {
                var tag = tags[t];

                var item = this._normalizeItem(tag);

                var $option = this.option(item);
                this.$element.append($option);
              }
            }
          }

          Tags.prototype.query = function (decorated, params, callback) {
            var self = this;

            this._removeOldTags();

            if (params.term == null || params.page != null) {
              decorated.call(this, params, callback);
              return;
            }

            function wrapper(obj, child) {
              var data = obj.results;

              for (var i = 0; i < data.length; i++) {
                var option = data[i];
                var checkChildren = option.children != null && !wrapper({
                  results: option.children
                }, true);
                var optionText = (option.text || '').toUpperCase();
                var paramsTerm = (params.term || '').toUpperCase();
                var checkText = optionText === paramsTerm;

                if (checkText || checkChildren) {
                  if (child) {
                    return false;
                  }

                  obj.data = data;
                  callback(obj);
                  return;
                }
              }

              if (child) {
                return true;
              }

              var tag = self.createTag(params);

              if (tag != null) {
                var $option = self.option(tag);
                $option.attr('data-select2-tag', true);
                self.addOptions([$option]);
                self.insertTag(data, tag);
              }

              obj.results = data;
              callback(obj);
            }

            decorated.call(this, params, wrapper);
          };

          Tags.prototype.createTag = function (decorated, params) {
            var term = $.trim(params.term);

            if (term === '') {
              return null;
            }

            return {
              id: term,
              text: term
            };
          };

          Tags.prototype.insertTag = function (_, data, tag) {
            data.unshift(tag);
          };

          Tags.prototype._removeOldTags = function (_) {
            var $options = this.$element.find('option[data-select2-tag]');
            $options.each(function () {
              if (this.selected) {
                return;
              }

              $(this).remove();
            });
          };

          return Tags;
        });
        S2.define('select2/data/tokenizer', ['jquery'], function ($) {
          function Tokenizer(decorated, $element, options) {
            var tokenizer = options.get('tokenizer');

            if (tokenizer !== undefined) {
              this.tokenizer = tokenizer;
            }

            decorated.call(this, $element, options);
          }

          Tokenizer.prototype.bind = function (decorated, container, $container) {
            decorated.call(this, container, $container);
            this.$search = container.dropdown.$search || container.selection.$search || $container.find('.select2-search__field');
          };

          Tokenizer.prototype.query = function (decorated, params, callback) {
            var self = this;

            function createAndSelect(data) {
              // Normalize the data object so we can use it for checks
              var item = self._normalizeItem(data); // Check if the data object already exists as a tag
              // Select it if it doesn't


              var $existingOptions = self.$element.find('option').filter(function () {
                return $(this).val() === item.id;
              }); // If an existing option wasn't found for it, create the option

              if (!$existingOptions.length) {
                var $option = self.option(item);
                $option.attr('data-select2-tag', true);

                self._removeOldTags();

                self.addOptions([$option]);
              } // Select the item, now that we know there is an option for it


              select(item);
            }

            function select(data) {
              self.trigger('select', {
                data: data
              });
            }

            params.term = params.term || '';
            var tokenData = this.tokenizer(params, this.options, createAndSelect);

            if (tokenData.term !== params.term) {
              // Replace the search term if we have the search box
              if (this.$search.length) {
                this.$search.val(tokenData.term);
                this.$search.trigger('focus');
              }

              params.term = tokenData.term;
            }

            decorated.call(this, params, callback);
          };

          Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
            var separators = options.get('tokenSeparators') || [];
            var term = params.term;
            var i = 0;

            var createTag = this.createTag || function (params) {
              return {
                id: params.term,
                text: params.term
              };
            };

            while (i < term.length) {
              var termChar = term[i];

              if ($.inArray(termChar, separators) === -1) {
                i++;
                continue;
              }

              var part = term.substr(0, i);
              var partParams = $.extend({}, params, {
                term: part
              });
              var data = createTag(partParams);

              if (data == null) {
                i++;
                continue;
              }

              callback(data); // Reset the term to not include the tokenized portion

              term = term.substr(i + 1) || '';
              i = 0;
            }

            return {
              term: term
            };
          };

          return Tokenizer;
        });
        S2.define('select2/data/minimumInputLength', [], function () {
          function MinimumInputLength(decorated, $e, options) {
            this.minimumInputLength = options.get('minimumInputLength');
            decorated.call(this, $e, options);
          }

          MinimumInputLength.prototype.query = function (decorated, params, callback) {
            params.term = params.term || '';

            if (params.term.length < this.minimumInputLength) {
              this.trigger('results:message', {
                message: 'inputTooShort',
                args: {
                  minimum: this.minimumInputLength,
                  input: params.term,
                  params: params
                }
              });
              return;
            }

            decorated.call(this, params, callback);
          };

          return MinimumInputLength;
        });
        S2.define('select2/data/maximumInputLength', [], function () {
          function MaximumInputLength(decorated, $e, options) {
            this.maximumInputLength = options.get('maximumInputLength');
            decorated.call(this, $e, options);
          }

          MaximumInputLength.prototype.query = function (decorated, params, callback) {
            params.term = params.term || '';

            if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
              this.trigger('results:message', {
                message: 'inputTooLong',
                args: {
                  maximum: this.maximumInputLength,
                  input: params.term,
                  params: params
                }
              });
              return;
            }

            decorated.call(this, params, callback);
          };

          return MaximumInputLength;
        });
        S2.define('select2/data/maximumSelectionLength', [], function () {
          function MaximumSelectionLength(decorated, $e, options) {
            this.maximumSelectionLength = options.get('maximumSelectionLength');
            decorated.call(this, $e, options);
          }

          MaximumSelectionLength.prototype.bind = function (decorated, container, $container) {
            var self = this;
            decorated.call(this, container, $container);
            container.on('select', function () {
              self._checkIfMaximumSelected();
            });
          };

          MaximumSelectionLength.prototype.query = function (decorated, params, callback) {
            var self = this;

            this._checkIfMaximumSelected(function () {
              decorated.call(self, params, callback);
            });
          };

          MaximumSelectionLength.prototype._checkIfMaximumSelected = function (_, successCallback) {
            var self = this;
            this.current(function (currentData) {
              var count = currentData != null ? currentData.length : 0;

              if (self.maximumSelectionLength > 0 && count >= self.maximumSelectionLength) {
                self.trigger('results:message', {
                  message: 'maximumSelected',
                  args: {
                    maximum: self.maximumSelectionLength
                  }
                });
                return;
              }

              if (successCallback) {
                successCallback();
              }
            });
          };

          return MaximumSelectionLength;
        });
        S2.define('select2/dropdown', ['jquery', './utils'], function ($, Utils) {
          function Dropdown($element, options) {
            this.$element = $element;
            this.options = options;

            Dropdown.__super__.constructor.call(this);
          }

          Utils.Extend(Dropdown, Utils.Observable);

          Dropdown.prototype.render = function () {
            var $dropdown = $('<span class="select2-dropdown">' + '<span class="select2-results"></span>' + '</span>');
            $dropdown.attr('dir', this.options.get('dir'));
            this.$dropdown = $dropdown;
            return $dropdown;
          };

          Dropdown.prototype.bind = function () {// Should be implemented in subclasses
          };

          Dropdown.prototype.position = function ($dropdown, $container) {// Should be implemented in subclasses
          };

          Dropdown.prototype.destroy = function () {
            // Remove the dropdown from the DOM
            this.$dropdown.remove();
          };

          return Dropdown;
        });
        S2.define('select2/dropdown/search', ['jquery', '../utils'], function ($, Utils) {
          function Search() {}

          Search.prototype.render = function (decorated) {
            var $rendered = decorated.call(this);
            var $search = $('<span class="select2-search select2-search--dropdown">' + '<input class="select2-search__field" type="search" tabindex="-1"' + ' autocomplete="off" autocorrect="off" autocapitalize="none"' + ' spellcheck="false" role="searchbox" aria-autocomplete="list" />' + '</span>');
            this.$searchContainer = $search;
            this.$search = $search.find('input');
            $rendered.prepend($search);
            return $rendered;
          };

          Search.prototype.bind = function (decorated, container, $container) {
            var self = this;
            var resultsId = container.id + '-results';
            decorated.call(this, container, $container);
            this.$search.on('keydown', function (evt) {
              self.trigger('keypress', evt);
              self._keyUpPrevented = evt.isDefaultPrevented();
            }); // Workaround for browsers which do not support the `input` event
            // This will prevent double-triggering of events for browsers which support
            // both the `keyup` and `input` events.

            this.$search.on('input', function (evt) {
              // Unbind the duplicated `keyup` event
              $(this).off('keyup');
            });
            this.$search.on('keyup input', function (evt) {
              self.handleSearch(evt);
            });
            container.on('open', function () {
              self.$search.attr('tabindex', 0);
              self.$search.attr('aria-controls', resultsId);
              self.$search.trigger('focus');
              window.setTimeout(function () {
                self.$search.trigger('focus');
              }, 0);
            });
            container.on('close', function () {
              self.$search.attr('tabindex', -1);
              self.$search.removeAttr('aria-controls');
              self.$search.removeAttr('aria-activedescendant');
              self.$search.val('');
              self.$search.trigger('blur');
            });
            container.on('focus', function () {
              if (!container.isOpen()) {
                self.$search.trigger('focus');
              }
            });
            container.on('results:all', function (params) {
              if (params.query.term == null || params.query.term === '') {
                var showSearch = self.showSearch(params);

                if (showSearch) {
                  self.$searchContainer.removeClass('select2-search--hide');
                } else {
                  self.$searchContainer.addClass('select2-search--hide');
                }
              }
            });
            container.on('results:focus', function (params) {
              if (params.data._resultId) {
                self.$search.attr('aria-activedescendant', params.data._resultId);
              } else {
                self.$search.removeAttr('aria-activedescendant');
              }
            });
          };

          Search.prototype.handleSearch = function (evt) {
            if (!this._keyUpPrevented) {
              var input = this.$search.val();
              this.trigger('query', {
                term: input
              });
            }

            this._keyUpPrevented = false;
          };

          Search.prototype.showSearch = function (_, params) {
            return true;
          };

          return Search;
        });
        S2.define('select2/dropdown/hidePlaceholder', [], function () {
          function HidePlaceholder(decorated, $element, options, dataAdapter) {
            this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
            decorated.call(this, $element, options, dataAdapter);
          }

          HidePlaceholder.prototype.append = function (decorated, data) {
            data.results = this.removePlaceholder(data.results);
            decorated.call(this, data);
          };

          HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
            if (typeof placeholder === 'string') {
              placeholder = {
                id: '',
                text: placeholder
              };
            }

            return placeholder;
          };

          HidePlaceholder.prototype.removePlaceholder = function (_, data) {
            var modifiedData = data.slice(0);

            for (var d = data.length - 1; d >= 0; d--) {
              var item = data[d];

              if (this.placeholder.id === item.id) {
                modifiedData.splice(d, 1);
              }
            }

            return modifiedData;
          };

          return HidePlaceholder;
        });
        S2.define('select2/dropdown/infiniteScroll', ['jquery'], function ($) {
          function InfiniteScroll(decorated, $element, options, dataAdapter) {
            this.lastParams = {};
            decorated.call(this, $element, options, dataAdapter);
            this.$loadingMore = this.createLoadingMore();
            this.loading = false;
          }

          InfiniteScroll.prototype.append = function (decorated, data) {
            this.$loadingMore.remove();
            this.loading = false;
            decorated.call(this, data);

            if (this.showLoadingMore(data)) {
              this.$results.append(this.$loadingMore);
              this.loadMoreIfNeeded();
            }
          };

          InfiniteScroll.prototype.bind = function (decorated, container, $container) {
            var self = this;
            decorated.call(this, container, $container);
            container.on('query', function (params) {
              self.lastParams = params;
              self.loading = true;
            });
            container.on('query:append', function (params) {
              self.lastParams = params;
              self.loading = true;
            });
            this.$results.on('scroll', this.loadMoreIfNeeded.bind(this));
          };

          InfiniteScroll.prototype.loadMoreIfNeeded = function () {
            var isLoadMoreVisible = $.contains(document.documentElement, this.$loadingMore[0]);

            if (this.loading || !isLoadMoreVisible) {
              return;
            }

            var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
            var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);

            if (currentOffset + 50 >= loadingMoreOffset) {
              this.loadMore();
            }
          };

          InfiniteScroll.prototype.loadMore = function () {
            this.loading = true;
            var params = $.extend({}, {
              page: 1
            }, this.lastParams);
            params.page++;
            this.trigger('query:append', params);
          };

          InfiniteScroll.prototype.showLoadingMore = function (_, data) {
            return data.pagination && data.pagination.more;
          };

          InfiniteScroll.prototype.createLoadingMore = function () {
            var $option = $('<li ' + 'class="select2-results__option select2-results__option--load-more"' + 'role="option" aria-disabled="true"></li>');
            var message = this.options.get('translations').get('loadingMore');
            $option.html(message(this.lastParams));
            return $option;
          };

          return InfiniteScroll;
        });
        S2.define('select2/dropdown/attachBody', ['jquery', '../utils'], function ($, Utils) {
          function AttachBody(decorated, $element, options) {
            this.$dropdownParent = $(options.get('dropdownParent') || document.body);
            decorated.call(this, $element, options);
          }

          AttachBody.prototype.bind = function (decorated, container, $container) {
            var self = this;
            decorated.call(this, container, $container);
            container.on('open', function () {
              self._showDropdown();

              self._attachPositioningHandler(container); // Must bind after the results handlers to ensure correct sizing


              self._bindContainerResultHandlers(container);
            });
            container.on('close', function () {
              self._hideDropdown();

              self._detachPositioningHandler(container);
            });
            this.$dropdownContainer.on('mousedown', function (evt) {
              evt.stopPropagation();
            });
          };

          AttachBody.prototype.destroy = function (decorated) {
            decorated.call(this);
            this.$dropdownContainer.remove();
          };

          AttachBody.prototype.position = function (decorated, $dropdown, $container) {
            // Clone all of the container classes
            $dropdown.attr('class', $container.attr('class'));
            $dropdown.removeClass('select2');
            $dropdown.addClass('select2-container--open');
            $dropdown.css({
              position: 'absolute',
              top: -999999
            });
            this.$container = $container;
          };

          AttachBody.prototype.render = function (decorated) {
            var $container = $('<span></span>');
            var $dropdown = decorated.call(this);
            $container.append($dropdown);
            this.$dropdownContainer = $container;
            return $container;
          };

          AttachBody.prototype._hideDropdown = function (decorated) {
            this.$dropdownContainer.detach();
          };

          AttachBody.prototype._bindContainerResultHandlers = function (decorated, container) {
            // These should only be bound once
            if (this._containerResultsHandlersBound) {
              return;
            }

            var self = this;
            container.on('results:all', function () {
              self._positionDropdown();

              self._resizeDropdown();
            });
            container.on('results:append', function () {
              self._positionDropdown();

              self._resizeDropdown();
            });
            container.on('results:message', function () {
              self._positionDropdown();

              self._resizeDropdown();
            });
            container.on('select', function () {
              self._positionDropdown();

              self._resizeDropdown();
            });
            container.on('unselect', function () {
              self._positionDropdown();

              self._resizeDropdown();
            });
            this._containerResultsHandlersBound = true;
          };

          AttachBody.prototype._attachPositioningHandler = function (decorated, container) {
            var self = this;
            var scrollEvent = 'scroll.select2.' + container.id;
            var resizeEvent = 'resize.select2.' + container.id;
            var orientationEvent = 'orientationchange.select2.' + container.id;
            var $watchers = this.$container.parents().filter(Utils.hasScroll);
            $watchers.each(function () {
              Utils.StoreData(this, 'select2-scroll-position', {
                x: $(this).scrollLeft(),
                y: $(this).scrollTop()
              });
            });
            $watchers.on(scrollEvent, function (ev) {
              var position = Utils.GetData(this, 'select2-scroll-position');
              $(this).scrollTop(position.y);
            });
            $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent, function (e) {
              self._positionDropdown();

              self._resizeDropdown();
            });
          };

          AttachBody.prototype._detachPositioningHandler = function (decorated, container) {
            var scrollEvent = 'scroll.select2.' + container.id;
            var resizeEvent = 'resize.select2.' + container.id;
            var orientationEvent = 'orientationchange.select2.' + container.id;
            var $watchers = this.$container.parents().filter(Utils.hasScroll);
            $watchers.off(scrollEvent);
            $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
          };

          AttachBody.prototype._positionDropdown = function () {
            var $window = $(window);
            var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
            var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');
            var newDirection = null;
            var offset = this.$container.offset();
            offset.bottom = offset.top + this.$container.outerHeight(false);
            var container = {
              height: this.$container.outerHeight(false)
            };
            container.top = offset.top;
            container.bottom = offset.top + container.height;
            var dropdown = {
              height: this.$dropdown.outerHeight(false)
            };
            var viewport = {
              top: $window.scrollTop(),
              bottom: $window.scrollTop() + $window.height()
            };
            var enoughRoomAbove = viewport.top < offset.top - dropdown.height;
            var enoughRoomBelow = viewport.bottom > offset.bottom + dropdown.height;
            var css = {
              left: offset.left,
              top: container.bottom
            }; // Determine what the parent element is to use for calculating the offset

            var $offsetParent = this.$dropdownParent; // For statically positioned elements, we need to get the element
            // that is determining the offset

            if ($offsetParent.css('position') === 'static') {
              $offsetParent = $offsetParent.offsetParent();
            }

            var parentOffset = {
              top: 0,
              left: 0
            };

            if ($.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
              parentOffset = $offsetParent.offset();
            }

            css.top -= parentOffset.top;
            css.left -= parentOffset.left;

            if (!isCurrentlyAbove && !isCurrentlyBelow) {
              newDirection = 'below';
            }

            if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
              newDirection = 'above';
            } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
              newDirection = 'below';
            }

            if (newDirection == 'above' || isCurrentlyAbove && newDirection !== 'below') {
              css.top = container.top - parentOffset.top - dropdown.height;
            }

            if (newDirection != null) {
              this.$dropdown.removeClass('select2-dropdown--below select2-dropdown--above').addClass('select2-dropdown--' + newDirection);
              this.$container.removeClass('select2-container--below select2-container--above').addClass('select2-container--' + newDirection);
            }

            this.$dropdownContainer.css(css);
          };

          AttachBody.prototype._resizeDropdown = function () {
            var css = {
              width: this.$container.outerWidth(false) + 'px'
            };

            if (this.options.get('dropdownAutoWidth')) {
              css.minWidth = css.width;
              css.position = 'relative';
              css.width = 'auto';
            }

            this.$dropdown.css(css);
          };

          AttachBody.prototype._showDropdown = function (decorated) {
            this.$dropdownContainer.appendTo(this.$dropdownParent);

            this._positionDropdown();

            this._resizeDropdown();
          };

          return AttachBody;
        });
        S2.define('select2/dropdown/minimumResultsForSearch', [], function () {
          function countResults(data) {
            var count = 0;

            for (var d = 0; d < data.length; d++) {
              var item = data[d];

              if (item.children) {
                count += countResults(item.children);
              } else {
                count++;
              }
            }

            return count;
          }

          function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
            this.minimumResultsForSearch = options.get('minimumResultsForSearch');

            if (this.minimumResultsForSearch < 0) {
              this.minimumResultsForSearch = Infinity;
            }

            decorated.call(this, $element, options, dataAdapter);
          }

          MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
            if (countResults(params.data.results) < this.minimumResultsForSearch) {
              return false;
            }

            return decorated.call(this, params);
          };

          return MinimumResultsForSearch;
        });
        S2.define('select2/dropdown/selectOnClose', ['../utils'], function (Utils) {
          function SelectOnClose() {}

          SelectOnClose.prototype.bind = function (decorated, container, $container) {
            var self = this;
            decorated.call(this, container, $container);
            container.on('close', function (params) {
              self._handleSelectOnClose(params);
            });
          };

          SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
            if (params && params.originalSelect2Event != null) {
              var event = params.originalSelect2Event; // Don't select an item if the close event was triggered from a select or
              // unselect event

              if (event._type === 'select' || event._type === 'unselect') {
                return;
              }
            }

            var $highlightedResults = this.getHighlightedResults(); // Only select highlighted results

            if ($highlightedResults.length < 1) {
              return;
            }

            var data = Utils.GetData($highlightedResults[0], 'data'); // Don't re-select already selected resulte

            if (data.element != null && data.element.selected || data.element == null && data.selected) {
              return;
            }

            this.trigger('select', {
              data: data
            });
          };

          return SelectOnClose;
        });
        S2.define('select2/dropdown/closeOnSelect', [], function () {
          function CloseOnSelect() {}

          CloseOnSelect.prototype.bind = function (decorated, container, $container) {
            var self = this;
            decorated.call(this, container, $container);
            container.on('select', function (evt) {
              self._selectTriggered(evt);
            });
            container.on('unselect', function (evt) {
              self._selectTriggered(evt);
            });
          };

          CloseOnSelect.prototype._selectTriggered = function (_, evt) {
            var originalEvent = evt.originalEvent; // Don't close if the control key is being held

            if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
              return;
            }

            this.trigger('close', {
              originalEvent: originalEvent,
              originalSelect2Event: evt
            });
          };

          return CloseOnSelect;
        });
        S2.define('select2/i18n/en', [], function () {
          // English
          return {
            errorLoading: function errorLoading() {
              return 'The results could not be loaded.';
            },
            inputTooLong: function inputTooLong(args) {
              var overChars = args.input.length - args.maximum;
              var message = 'Please delete ' + overChars + ' character';

              if (overChars != 1) {
                message += 's';
              }

              return message;
            },
            inputTooShort: function inputTooShort(args) {
              var remainingChars = args.minimum - args.input.length;
              var message = 'Please enter ' + remainingChars + ' or more characters';
              return message;
            },
            loadingMore: function loadingMore() {
              return 'Loading more results';
            },
            maximumSelected: function maximumSelected(args) {
              var message = 'You can only select ' + args.maximum + ' item';

              if (args.maximum != 1) {
                message += 's';
              }

              return message;
            },
            noResults: function noResults() {
              return 'No results found';
            },
            searching: function searching() {
              return 'Searching';
            },
            removeAllItems: function removeAllItems() {
              return 'Remove all items';
            }
          };
        });
        S2.define('select2/defaults', ['jquery', 'require', './results', './selection/single', './selection/multiple', './selection/placeholder', './selection/allowClear', './selection/search', './selection/eventRelay', './utils', './translation', './diacritics', './data/select', './data/array', './data/ajax', './data/tags', './data/tokenizer', './data/minimumInputLength', './data/maximumInputLength', './data/maximumSelectionLength', './dropdown', './dropdown/search', './dropdown/hidePlaceholder', './dropdown/infiniteScroll', './dropdown/attachBody', './dropdown/minimumResultsForSearch', './dropdown/selectOnClose', './dropdown/closeOnSelect', './i18n/en'], function ($, require, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, EnglishTranslation) {
          function Defaults() {
            this.reset();
          }

          Defaults.prototype.apply = function (options) {
            options = $.extend(true, {}, this.defaults, options);

            if (options.dataAdapter == null) {
              if (options.ajax != null) {
                options.dataAdapter = AjaxData;
              } else if (options.data != null) {
                options.dataAdapter = ArrayData;
              } else {
                options.dataAdapter = SelectData;
              }

              if (options.minimumInputLength > 0) {
                options.dataAdapter = Utils.Decorate(options.dataAdapter, MinimumInputLength);
              }

              if (options.maximumInputLength > 0) {
                options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumInputLength);
              }

              if (options.maximumSelectionLength > 0) {
                options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumSelectionLength);
              }

              if (options.tags) {
                options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
              }

              if (options.tokenSeparators != null || options.tokenizer != null) {
                options.dataAdapter = Utils.Decorate(options.dataAdapter, Tokenizer);
              }

              if (options.query != null) {
                var Query = require(options.amdBase + 'compat/query');

                options.dataAdapter = Utils.Decorate(options.dataAdapter, Query);
              }

              if (options.initSelection != null) {
                var InitSelection = require(options.amdBase + 'compat/initSelection');

                options.dataAdapter = Utils.Decorate(options.dataAdapter, InitSelection);
              }
            }

            if (options.resultsAdapter == null) {
              options.resultsAdapter = ResultsList;

              if (options.ajax != null) {
                options.resultsAdapter = Utils.Decorate(options.resultsAdapter, InfiniteScroll);
              }

              if (options.placeholder != null) {
                options.resultsAdapter = Utils.Decorate(options.resultsAdapter, HidePlaceholder);
              }

              if (options.selectOnClose) {
                options.resultsAdapter = Utils.Decorate(options.resultsAdapter, SelectOnClose);
              }
            }

            if (options.dropdownAdapter == null) {
              if (options.multiple) {
                options.dropdownAdapter = Dropdown;
              } else {
                var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
                options.dropdownAdapter = SearchableDropdown;
              }

              if (options.minimumResultsForSearch !== 0) {
                options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, MinimumResultsForSearch);
              }

              if (options.closeOnSelect) {
                options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, CloseOnSelect);
              }

              if (options.dropdownCssClass != null || options.dropdownCss != null || options.adaptDropdownCssClass != null) {
                var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

                options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, DropdownCSS);
              }

              options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, AttachBody);
            }

            if (options.selectionAdapter == null) {
              if (options.multiple) {
                options.selectionAdapter = MultipleSelection;
              } else {
                options.selectionAdapter = SingleSelection;
              } // Add the placeholder mixin if a placeholder was specified


              if (options.placeholder != null) {
                options.selectionAdapter = Utils.Decorate(options.selectionAdapter, Placeholder);
              }

              if (options.allowClear) {
                options.selectionAdapter = Utils.Decorate(options.selectionAdapter, AllowClear);
              }

              if (options.multiple) {
                options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionSearch);
              }

              if (options.containerCssClass != null || options.containerCss != null || options.adaptContainerCssClass != null) {
                var ContainerCSS = require(options.amdBase + 'compat/containerCss');

                options.selectionAdapter = Utils.Decorate(options.selectionAdapter, ContainerCSS);
              }

              options.selectionAdapter = Utils.Decorate(options.selectionAdapter, EventRelay);
            } // If the defaults were not previously applied from an element, it is
            // possible for the language option to have not been resolved


            options.language = this._resolveLanguage(options.language); // Always fall back to English since it will always be complete

            options.language.push('en');
            var uniqueLanguages = [];

            for (var l = 0; l < options.language.length; l++) {
              var language = options.language[l];

              if (uniqueLanguages.indexOf(language) === -1) {
                uniqueLanguages.push(language);
              }
            }

            options.language = uniqueLanguages;
            options.translations = this._processTranslations(options.language, options.debug);
            return options;
          };

          Defaults.prototype.reset = function () {
            function stripDiacritics(text) {
              // Used 'uni range + named function' from http://jsperf.com/diacritics/18
              function match(a) {
                return DIACRITICS[a] || a;
              }

              return text.replace(/[^\u0000-\u007E]/g, match);
            }

            function matcher(params, data) {
              // Always return the object if there is nothing to compare
              if ($.trim(params.term) === '') {
                return data;
              } // Do a recursive check for options with children


              if (data.children && data.children.length > 0) {
                // Clone the data object if there are children
                // This is required as we modify the object to remove any non-matches
                var match = $.extend(true, {}, data); // Check each child of the option

                for (var c = data.children.length - 1; c >= 0; c--) {
                  var child = data.children[c];
                  var matches = matcher(params, child); // If there wasn't a match, remove the object in the array

                  if (matches == null) {
                    match.children.splice(c, 1);
                  }
                } // If any children matched, return the new object


                if (match.children.length > 0) {
                  return match;
                } // If there were no matching children, check just the plain object


                return matcher(params, match);
              }

              var original = stripDiacritics(data.text).toUpperCase();
              var term = stripDiacritics(params.term).toUpperCase(); // Check if the text contains the term

              if (original.indexOf(term) > -1) {
                return data;
              } // If it doesn't contain the term, don't return anything


              return null;
            }

            this.defaults = {
              amdBase: './',
              amdLanguageBase: './i18n/',
              closeOnSelect: true,
              debug: false,
              dropdownAutoWidth: false,
              escapeMarkup: Utils.escapeMarkup,
              language: {},
              matcher: matcher,
              minimumInputLength: 0,
              maximumInputLength: 0,
              maximumSelectionLength: 0,
              minimumResultsForSearch: 0,
              selectOnClose: false,
              scrollAfterSelect: false,
              sorter: function sorter(data) {
                return data;
              },
              templateResult: function templateResult(result) {
                return result.text;
              },
              templateSelection: function templateSelection(selection) {
                return selection.text;
              },
              theme: 'default',
              width: 'resolve'
            };
          };

          Defaults.prototype.applyFromElement = function (options, $element) {
            var optionLanguage = options.language;
            var defaultLanguage = this.defaults.language;
            var elementLanguage = $element.prop('lang');
            var parentLanguage = $element.closest('[lang]').prop('lang');
            var languages = Array.prototype.concat.call(this._resolveLanguage(elementLanguage), this._resolveLanguage(optionLanguage), this._resolveLanguage(defaultLanguage), this._resolveLanguage(parentLanguage));
            options.language = languages;
            return options;
          };

          Defaults.prototype._resolveLanguage = function (language) {
            if (!language) {
              return [];
            }

            if ($.isEmptyObject(language)) {
              return [];
            }

            if ($.isPlainObject(language)) {
              return [language];
            }

            var languages;

            if (!$.isArray(language)) {
              languages = [language];
            } else {
              languages = language;
            }

            var resolvedLanguages = [];

            for (var l = 0; l < languages.length; l++) {
              resolvedLanguages.push(languages[l]);

              if (typeof languages[l] === 'string' && languages[l].indexOf('-') > 0) {
                // Extract the region information if it is included
                var languageParts = languages[l].split('-');
                var baseLanguage = languageParts[0];
                resolvedLanguages.push(baseLanguage);
              }
            }

            return resolvedLanguages;
          };

          Defaults.prototype._processTranslations = function (languages, debug) {
            var translations = new Translation();

            for (var l = 0; l < languages.length; l++) {
              var languageData = new Translation();
              var language = languages[l];

              if (typeof language === 'string') {
                try {
                  // Try to load it with the original name
                  languageData = Translation.loadPath(language);
                } catch (e) {
                  try {
                    // If we couldn't load it, check if it wasn't the full path
                    language = this.defaults.amdLanguageBase + language;
                    languageData = Translation.loadPath(language);
                  } catch (ex) {
                    // The translation could not be loaded at all. Sometimes this is
                    // because of a configuration problem, other times this can be
                    // because of how Select2 helps load all possible translation files
                    if (debug && window.console && console.warn) {
                      console.warn('Select2: The language file for "' + language + '" could ' + 'not be automatically loaded. A fallback will be used instead.');
                    }
                  }
                }
              } else if ($.isPlainObject(language)) {
                languageData = new Translation(language);
              } else {
                languageData = language;
              }

              translations.extend(languageData);
            }

            return translations;
          };

          Defaults.prototype.set = function (key, value) {
            var camelKey = $.camelCase(key);
            var data = {};
            data[camelKey] = value;

            var convertedData = Utils._convertData(data);

            $.extend(true, this.defaults, convertedData);
          };

          var defaults = new Defaults();
          return defaults;
        });
        S2.define('select2/options', ['require', 'jquery', './defaults', './utils'], function (require, $, Defaults, Utils) {
          function Options(options, $element) {
            this.options = options;

            if ($element != null) {
              this.fromElement($element);
            }

            if ($element != null) {
              this.options = Defaults.applyFromElement(this.options, $element);
            }

            this.options = Defaults.apply(this.options);

            if ($element && $element.is('input')) {
              var InputCompat = require(this.get('amdBase') + 'compat/inputData');

              this.options.dataAdapter = Utils.Decorate(this.options.dataAdapter, InputCompat);
            }
          }

          Options.prototype.fromElement = function ($e) {
            var excludedData = ['select2'];

            if (this.options.multiple == null) {
              this.options.multiple = $e.prop('multiple');
            }

            if (this.options.disabled == null) {
              this.options.disabled = $e.prop('disabled');
            }

            if (this.options.dir == null) {
              if ($e.prop('dir')) {
                this.options.dir = $e.prop('dir');
              } else if ($e.closest('[dir]').prop('dir')) {
                this.options.dir = $e.closest('[dir]').prop('dir');
              } else {
                this.options.dir = 'ltr';
              }
            }

            $e.prop('disabled', this.options.disabled);
            $e.prop('multiple', this.options.multiple);

            if (Utils.GetData($e[0], 'select2Tags')) {
              if (this.options.debug && window.console && console.warn) {
                console.warn('Select2: The `data-select2-tags` attribute has been changed to ' + 'use the `data-data` and `data-tags="true"` attributes and will be ' + 'removed in future versions of Select2.');
              }

              Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));
              Utils.StoreData($e[0], 'tags', true);
            }

            if (Utils.GetData($e[0], 'ajaxUrl')) {
              if (this.options.debug && window.console && console.warn) {
                console.warn('Select2: The `data-ajax-url` attribute has been changed to ' + '`data-ajax--url` and support for the old attribute will be removed' + ' in future versions of Select2.');
              }

              $e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));
              Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));
            }

            var dataset = {};

            function upperCaseLetter(_, letter) {
              return letter.toUpperCase();
            } // Pre-load all of the attributes which are prefixed with `data-`


            for (var attr = 0; attr < $e[0].attributes.length; attr++) {
              var attributeName = $e[0].attributes[attr].name;
              var prefix = 'data-';

              if (attributeName.substr(0, prefix.length) == prefix) {
                // Get the contents of the attribute after `data-`
                var dataName = attributeName.substring(prefix.length); // Get the data contents from the consistent source
                // This is more than likely the jQuery data helper

                var dataValue = Utils.GetData($e[0], dataName); // camelCase the attribute name to match the spec

                var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter); // Store the data attribute contents into the dataset since

                dataset[camelDataName] = dataValue;
              }
            } // Prefer the element's `dataset` attribute if it exists
            // jQuery 1.x does not correctly handle data attributes with multiple dashes


            if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
              dataset = $.extend(true, {}, $e[0].dataset, dataset);
            } // Prefer our internal data cache if it exists


            var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);
            data = Utils._convertData(data);

            for (var key in data) {
              if ($.inArray(key, excludedData) > -1) {
                continue;
              }

              if ($.isPlainObject(this.options[key])) {
                $.extend(this.options[key], data[key]);
              } else {
                this.options[key] = data[key];
              }
            }

            return this;
          };

          Options.prototype.get = function (key) {
            return this.options[key];
          };

          Options.prototype.set = function (key, val) {
            this.options[key] = val;
          };

          return Options;
        });
        S2.define('select2/core', ['jquery', './options', './utils', './keys'], function ($, Options, Utils, KEYS) {
          var Select2 = function Select2($element, options) {
            if (Utils.GetData($element[0], 'select2') != null) {
              Utils.GetData($element[0], 'select2').destroy();
            }

            this.$element = $element;
            this.id = this._generateId($element);
            options = options || {};
            this.options = new Options(options, $element);

            Select2.__super__.constructor.call(this); // Set up the tabindex


            var tabindex = $element.attr('tabindex') || 0;
            Utils.StoreData($element[0], 'old-tabindex', tabindex);
            $element.attr('tabindex', '-1'); // Set up containers and adapters

            var DataAdapter = this.options.get('dataAdapter');
            this.dataAdapter = new DataAdapter($element, this.options);
            var $container = this.render();

            this._placeContainer($container);

            var SelectionAdapter = this.options.get('selectionAdapter');
            this.selection = new SelectionAdapter($element, this.options);
            this.$selection = this.selection.render();
            this.selection.position(this.$selection, $container);
            var DropdownAdapter = this.options.get('dropdownAdapter');
            this.dropdown = new DropdownAdapter($element, this.options);
            this.$dropdown = this.dropdown.render();
            this.dropdown.position(this.$dropdown, $container);
            var ResultsAdapter = this.options.get('resultsAdapter');
            this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
            this.$results = this.results.render();
            this.results.position(this.$results, this.$dropdown); // Bind events

            var self = this; // Bind the container to all of the adapters

            this._bindAdapters(); // Register any DOM event handlers


            this._registerDomEvents(); // Register any internal event handlers


            this._registerDataEvents();

            this._registerSelectionEvents();

            this._registerDropdownEvents();

            this._registerResultsEvents();

            this._registerEvents(); // Set the initial state


            this.dataAdapter.current(function (initialData) {
              self.trigger('selection:update', {
                data: initialData
              });
            }); // Hide the original select

            $element.addClass('select2-hidden-accessible');
            $element.attr('aria-hidden', 'true'); // Synchronize any monitored attributes

            this._syncAttributes();

            Utils.StoreData($element[0], 'select2', this); // Ensure backwards compatibility with $element.data('select2').

            $element.data('select2', this);
          };

          Utils.Extend(Select2, Utils.Observable);

          Select2.prototype._generateId = function ($element) {
            var id = '';

            if ($element.attr('id') != null) {
              id = $element.attr('id');
            } else if ($element.attr('name') != null) {
              id = $element.attr('name') + '-' + Utils.generateChars(2);
            } else {
              id = Utils.generateChars(4);
            }

            id = id.replace(/(:|\.|\[|\]|,)/g, '');
            id = 'select2-' + id;
            return id;
          };

          Select2.prototype._placeContainer = function ($container) {
            $container.insertAfter(this.$element);

            var width = this._resolveWidth(this.$element, this.options.get('width'));

            if (width != null) {
              $container.css('width', width);
            }
          };

          Select2.prototype._resolveWidth = function ($element, method) {
            var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

            if (method == 'resolve') {
              var styleWidth = this._resolveWidth($element, 'style');

              if (styleWidth != null) {
                return styleWidth;
              }

              return this._resolveWidth($element, 'element');
            }

            if (method == 'element') {
              var elementWidth = $element.outerWidth(false);

              if (elementWidth <= 0) {
                return 'auto';
              }

              return elementWidth + 'px';
            }

            if (method == 'style') {
              var style = $element.attr('style');

              if (typeof style !== 'string') {
                return null;
              }

              var attrs = style.split(';');

              for (var i = 0, l = attrs.length; i < l; i = i + 1) {
                var attr = attrs[i].replace(/\s/g, '');
                var matches = attr.match(WIDTH);

                if (matches !== null && matches.length >= 1) {
                  return matches[1];
                }
              }

              return null;
            }

            if (method == 'computedstyle') {
              var computedStyle = window.getComputedStyle($element[0]);
              return computedStyle.width;
            }

            return method;
          };

          Select2.prototype._bindAdapters = function () {
            this.dataAdapter.bind(this, this.$container);
            this.selection.bind(this, this.$container);
            this.dropdown.bind(this, this.$container);
            this.results.bind(this, this.$container);
          };

          Select2.prototype._registerDomEvents = function () {
            var self = this;
            this.$element.on('change.select2', function () {
              self.dataAdapter.current(function (data) {
                self.trigger('selection:update', {
                  data: data
                });
              });
            });
            this.$element.on('focus.select2', function (evt) {
              self.trigger('focus', evt);
            });
            this._syncA = Utils.bind(this._syncAttributes, this);
            this._syncS = Utils.bind(this._syncSubtree, this);

            if (this.$element[0].attachEvent) {
              this.$element[0].attachEvent('onpropertychange', this._syncA);
            }

            var observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;

            if (observer != null) {
              this._observer = new observer(function (mutations) {
                self._syncA();

                self._syncS(null, mutations);
              });

              this._observer.observe(this.$element[0], {
                attributes: true,
                childList: true,
                subtree: false
              });
            } else if (this.$element[0].addEventListener) {
              this.$element[0].addEventListener('DOMAttrModified', self._syncA, false);
              this.$element[0].addEventListener('DOMNodeInserted', self._syncS, false);
              this.$element[0].addEventListener('DOMNodeRemoved', self._syncS, false);
            }
          };

          Select2.prototype._registerDataEvents = function () {
            var self = this;
            this.dataAdapter.on('*', function (name, params) {
              self.trigger(name, params);
            });
          };

          Select2.prototype._registerSelectionEvents = function () {
            var self = this;
            var nonRelayEvents = ['toggle', 'focus'];
            this.selection.on('toggle', function () {
              self.toggleDropdown();
            });
            this.selection.on('focus', function (params) {
              self.focus(params);
            });
            this.selection.on('*', function (name, params) {
              if ($.inArray(name, nonRelayEvents) !== -1) {
                return;
              }

              self.trigger(name, params);
            });
          };

          Select2.prototype._registerDropdownEvents = function () {
            var self = this;
            this.dropdown.on('*', function (name, params) {
              self.trigger(name, params);
            });
          };

          Select2.prototype._registerResultsEvents = function () {
            var self = this;
            this.results.on('*', function (name, params) {
              self.trigger(name, params);
            });
          };

          Select2.prototype._registerEvents = function () {
            var self = this;
            this.on('open', function () {
              self.$container.addClass('select2-container--open');
            });
            this.on('close', function () {
              self.$container.removeClass('select2-container--open');
            });
            this.on('enable', function () {
              self.$container.removeClass('select2-container--disabled');
            });
            this.on('disable', function () {
              self.$container.addClass('select2-container--disabled');
            });
            this.on('blur', function () {
              self.$container.removeClass('select2-container--focus');
            });
            this.on('query', function (params) {
              if (!self.isOpen()) {
                self.trigger('open', {});
              }

              this.dataAdapter.query(params, function (data) {
                self.trigger('results:all', {
                  data: data,
                  query: params
                });
              });
            });
            this.on('query:append', function (params) {
              this.dataAdapter.query(params, function (data) {
                self.trigger('results:append', {
                  data: data,
                  query: params
                });
              });
            });
            this.on('keypress', function (evt) {
              var key = evt.which;

              if (self.isOpen()) {
                if (key === KEYS.ESC || key === KEYS.TAB || key === KEYS.UP && evt.altKey) {
                  self.close(evt);
                  evt.preventDefault();
                } else if (key === KEYS.ENTER) {
                  self.trigger('results:select', {});
                  evt.preventDefault();
                } else if (key === KEYS.SPACE && evt.ctrlKey) {
                  self.trigger('results:toggle', {});
                  evt.preventDefault();
                } else if (key === KEYS.UP) {
                  self.trigger('results:previous', {});
                  evt.preventDefault();
                } else if (key === KEYS.DOWN) {
                  self.trigger('results:next', {});
                  evt.preventDefault();
                }
              } else {
                if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                  self.open();
                  evt.preventDefault();
                }
              }
            });
          };

          Select2.prototype._syncAttributes = function () {
            this.options.set('disabled', this.$element.prop('disabled'));

            if (this.isDisabled()) {
              if (this.isOpen()) {
                this.close();
              }

              this.trigger('disable', {});
            } else {
              this.trigger('enable', {});
            }
          };

          Select2.prototype._isChangeMutation = function (evt, mutations) {
            var changed = false;
            var self = this; // Ignore any mutation events raised for elements that aren't options or
            // optgroups. This handles the case when the select element is destroyed

            if (evt && evt.target && evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP') {
              return;
            }

            if (!mutations) {
              // If mutation events aren't supported, then we can only assume that the
              // change affected the selections
              changed = true;
            } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
              for (var n = 0; n < mutations.addedNodes.length; n++) {
                var node = mutations.addedNodes[n];

                if (node.selected) {
                  changed = true;
                }
              }
            } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
              changed = true;
            } else if ($.isArray(mutations)) {
              $.each(mutations, function (evt, mutation) {
                if (self._isChangeMutation(evt, mutation)) {
                  // We've found a change mutation.
                  // Let's escape from the loop and continue
                  changed = true;
                  return false;
                }
              });
            }

            return changed;
          };

          Select2.prototype._syncSubtree = function (evt, mutations) {
            var changed = this._isChangeMutation(evt, mutations);

            var self = this; // Only re-pull the data if we think there is a change

            if (changed) {
              this.dataAdapter.current(function (currentData) {
                self.trigger('selection:update', {
                  data: currentData
                });
              });
            }
          };
          /**
           * Override the trigger method to automatically trigger pre-events when
           * there are events that can be prevented.
           */


          Select2.prototype.trigger = function (name, args) {
            var actualTrigger = Select2.__super__.trigger;
            var preTriggerMap = {
              'open': 'opening',
              'close': 'closing',
              'select': 'selecting',
              'unselect': 'unselecting',
              'clear': 'clearing'
            };

            if (args === undefined) {
              args = {};
            }

            if (name in preTriggerMap) {
              var preTriggerName = preTriggerMap[name];
              var preTriggerArgs = {
                prevented: false,
                name: name,
                args: args
              };
              actualTrigger.call(this, preTriggerName, preTriggerArgs);

              if (preTriggerArgs.prevented) {
                args.prevented = true;
                return;
              }
            }

            actualTrigger.call(this, name, args);
          };

          Select2.prototype.toggleDropdown = function () {
            if (this.isDisabled()) {
              return;
            }

            if (this.isOpen()) {
              this.close();
            } else {
              this.open();
            }
          };

          Select2.prototype.open = function () {
            if (this.isOpen()) {
              return;
            }

            if (this.isDisabled()) {
              return;
            }

            this.trigger('query', {});
          };

          Select2.prototype.close = function (evt) {
            if (!this.isOpen()) {
              return;
            }

            this.trigger('close', {
              originalEvent: evt
            });
          };
          /**
           * Helper method to abstract the "enabled" (not "disabled") state of this
           * object.
           *
           * @return {true} if the instance is not disabled.
           * @return {false} if the instance is disabled.
           */


          Select2.prototype.isEnabled = function () {
            return !this.isDisabled();
          };
          /**
           * Helper method to abstract the "disabled" state of this object.
           *
           * @return {true} if the disabled option is true.
           * @return {false} if the disabled option is false.
           */


          Select2.prototype.isDisabled = function () {
            return this.options.get('disabled');
          };

          Select2.prototype.isOpen = function () {
            return this.$container.hasClass('select2-container--open');
          };

          Select2.prototype.hasFocus = function () {
            return this.$container.hasClass('select2-container--focus');
          };

          Select2.prototype.focus = function (data) {
            // No need to re-trigger focus events if we are already focused
            if (this.hasFocus()) {
              return;
            }

            this.$container.addClass('select2-container--focus');
            this.trigger('focus', {});
          };

          Select2.prototype.enable = function (args) {
            if (this.options.get('debug') && window.console && console.warn) {
              console.warn('Select2: The `select2("enable")` method has been deprecated and will' + ' be removed in later Select2 versions. Use $element.prop("disabled")' + ' instead.');
            }

            if (args == null || args.length === 0) {
              args = [true];
            }

            var disabled = !args[0];
            this.$element.prop('disabled', disabled);
          };

          Select2.prototype.data = function () {
            if (this.options.get('debug') && arguments.length > 0 && window.console && console.warn) {
              console.warn('Select2: Data can no longer be set using `select2("data")`. You ' + 'should consider setting the value instead using `$element.val()`.');
            }

            var data = [];
            this.dataAdapter.current(function (currentData) {
              data = currentData;
            });
            return data;
          };

          Select2.prototype.val = function (args) {
            if (this.options.get('debug') && window.console && console.warn) {
              console.warn('Select2: The `select2("val")` method has been deprecated and will be' + ' removed in later Select2 versions. Use $element.val() instead.');
            }

            if (args == null || args.length === 0) {
              return this.$element.val();
            }

            var newVal = args[0];

            if ($.isArray(newVal)) {
              newVal = $.map(newVal, function (obj) {
                return obj.toString();
              });
            }

            this.$element.val(newVal).trigger('input').trigger('change');
          };

          Select2.prototype.destroy = function () {
            this.$container.remove();

            if (this.$element[0].detachEvent) {
              this.$element[0].detachEvent('onpropertychange', this._syncA);
            }

            if (this._observer != null) {
              this._observer.disconnect();

              this._observer = null;
            } else if (this.$element[0].removeEventListener) {
              this.$element[0].removeEventListener('DOMAttrModified', this._syncA, false);
              this.$element[0].removeEventListener('DOMNodeInserted', this._syncS, false);
              this.$element[0].removeEventListener('DOMNodeRemoved', this._syncS, false);
            }

            this._syncA = null;
            this._syncS = null;
            this.$element.off('.select2');
            this.$element.attr('tabindex', Utils.GetData(this.$element[0], 'old-tabindex'));
            this.$element.removeClass('select2-hidden-accessible');
            this.$element.attr('aria-hidden', 'false');
            Utils.RemoveData(this.$element[0]);
            this.$element.removeData('select2');
            this.dataAdapter.destroy();
            this.selection.destroy();
            this.dropdown.destroy();
            this.results.destroy();
            this.dataAdapter = null;
            this.selection = null;
            this.dropdown = null;
            this.results = null;
          };

          Select2.prototype.render = function () {
            var $container = $('<span class="select2 select2-container">' + '<span class="selection"></span>' + '<span class="dropdown-wrapper" aria-hidden="true"></span>' + '</span>');
            $container.attr('dir', this.options.get('dir'));
            this.$container = $container;
            this.$container.addClass('select2-container--' + this.options.get('theme'));
            Utils.StoreData($container[0], 'element', this.$element);
            return $container;
          };

          return Select2;
        });
        S2.define('select2/compat/utils', ['jquery'], function ($) {
          function syncCssClasses($dest, $src, adapter) {
            var classes,
                replacements = [],
                adapted;
            classes = $.trim($dest.attr('class'));

            if (classes) {
              classes = '' + classes; // for IE which returns object

              $(classes.split(/\s+/)).each(function () {
                // Save all Select2 classes
                if (this.indexOf('select2-') === 0) {
                  replacements.push(this);
                }
              });
            }

            classes = $.trim($src.attr('class'));

            if (classes) {
              classes = '' + classes; // for IE which returns object

              $(classes.split(/\s+/)).each(function () {
                // Only adapt non-Select2 classes
                if (this.indexOf('select2-') !== 0) {
                  adapted = adapter(this);

                  if (adapted != null) {
                    replacements.push(adapted);
                  }
                }
              });
            }

            $dest.attr('class', replacements.join(' '));
          }

          return {
            syncCssClasses: syncCssClasses
          };
        });
        S2.define('select2/compat/containerCss', ['jquery', './utils'], function ($, CompatUtils) {
          // No-op CSS adapter that discards all classes by default
          function _containerAdapter(clazz) {
            return null;
          }

          function ContainerCSS() {}

          ContainerCSS.prototype.render = function (decorated) {
            var $container = decorated.call(this);
            var containerCssClass = this.options.get('containerCssClass') || '';

            if ($.isFunction(containerCssClass)) {
              containerCssClass = containerCssClass(this.$element);
            }

            var containerCssAdapter = this.options.get('adaptContainerCssClass');
            containerCssAdapter = containerCssAdapter || _containerAdapter;

            if (containerCssClass.indexOf(':all:') !== -1) {
              containerCssClass = containerCssClass.replace(':all:', '');
              var _cssAdapter = containerCssAdapter;

              containerCssAdapter = function containerCssAdapter(clazz) {
                var adapted = _cssAdapter(clazz);

                if (adapted != null) {
                  // Append the old one along with the adapted one
                  return adapted + ' ' + clazz;
                }

                return clazz;
              };
            }

            var containerCss = this.options.get('containerCss') || {};

            if ($.isFunction(containerCss)) {
              containerCss = containerCss(this.$element);
            }

            CompatUtils.syncCssClasses($container, this.$element, containerCssAdapter);
            $container.css(containerCss);
            $container.addClass(containerCssClass);
            return $container;
          };

          return ContainerCSS;
        });
        S2.define('select2/compat/dropdownCss', ['jquery', './utils'], function ($, CompatUtils) {
          // No-op CSS adapter that discards all classes by default
          function _dropdownAdapter(clazz) {
            return null;
          }

          function DropdownCSS() {}

          DropdownCSS.prototype.render = function (decorated) {
            var $dropdown = decorated.call(this);
            var dropdownCssClass = this.options.get('dropdownCssClass') || '';

            if ($.isFunction(dropdownCssClass)) {
              dropdownCssClass = dropdownCssClass(this.$element);
            }

            var dropdownCssAdapter = this.options.get('adaptDropdownCssClass');
            dropdownCssAdapter = dropdownCssAdapter || _dropdownAdapter;

            if (dropdownCssClass.indexOf(':all:') !== -1) {
              dropdownCssClass = dropdownCssClass.replace(':all:', '');
              var _cssAdapter = dropdownCssAdapter;

              dropdownCssAdapter = function dropdownCssAdapter(clazz) {
                var adapted = _cssAdapter(clazz);

                if (adapted != null) {
                  // Append the old one along with the adapted one
                  return adapted + ' ' + clazz;
                }

                return clazz;
              };
            }

            var dropdownCss = this.options.get('dropdownCss') || {};

            if ($.isFunction(dropdownCss)) {
              dropdownCss = dropdownCss(this.$element);
            }

            CompatUtils.syncCssClasses($dropdown, this.$element, dropdownCssAdapter);
            $dropdown.css(dropdownCss);
            $dropdown.addClass(dropdownCssClass);
            return $dropdown;
          };

          return DropdownCSS;
        });
        S2.define('select2/compat/initSelection', ['jquery'], function ($) {
          function InitSelection(decorated, $element, options) {
            if (options.get('debug') && window.console && console.warn) {
              console.warn('Select2: The `initSelection` option has been deprecated in favor' + ' of a custom data adapter that overrides the `current` method. ' + 'This method is now called multiple times instead of a single ' + 'time when the instance is initialized. Support will be removed ' + 'for the `initSelection` option in future versions of Select2');
            }

            this.initSelection = options.get('initSelection');
            this._isInitialized = false;
            decorated.call(this, $element, options);
          }

          InitSelection.prototype.current = function (decorated, callback) {
            var self = this;

            if (this._isInitialized) {
              decorated.call(this, callback);
              return;
            }

            this.initSelection.call(null, this.$element, function (data) {
              self._isInitialized = true;

              if (!$.isArray(data)) {
                data = [data];
              }

              callback(data);
            });
          };

          return InitSelection;
        });
        S2.define('select2/compat/inputData', ['jquery', '../utils'], function ($, Utils) {
          function InputData(decorated, $element, options) {
            this._currentData = [];
            this._valueSeparator = options.get('valueSeparator') || ',';

            if ($element.prop('type') === 'hidden') {
              if (options.get('debug') && console && console.warn) {
                console.warn('Select2: Using a hidden input with Select2 is no longer ' + 'supported and may stop working in the future. It is recommended ' + 'to use a `<select>` element instead.');
              }
            }

            decorated.call(this, $element, options);
          }

          InputData.prototype.current = function (_, callback) {
            function getSelected(data, selectedIds) {
              var selected = [];

              if (data.selected || $.inArray(data.id, selectedIds) !== -1) {
                data.selected = true;
                selected.push(data);
              } else {
                data.selected = false;
              }

              if (data.children) {
                selected.push.apply(selected, getSelected(data.children, selectedIds));
              }

              return selected;
            }

            var selected = [];

            for (var d = 0; d < this._currentData.length; d++) {
              var data = this._currentData[d];
              selected.push.apply(selected, getSelected(data, this.$element.val().split(this._valueSeparator)));
            }

            callback(selected);
          };

          InputData.prototype.select = function (_, data) {
            if (!this.options.get('multiple')) {
              this.current(function (allData) {
                $.map(allData, function (data) {
                  data.selected = false;
                });
              });
              this.$element.val(data.id);
              this.$element.trigger('input').trigger('change');
            } else {
              var value = this.$element.val();
              value += this._valueSeparator + data.id;
              this.$element.val(value);
              this.$element.trigger('input').trigger('change');
            }
          };

          InputData.prototype.unselect = function (_, data) {
            var self = this;
            data.selected = false;
            this.current(function (allData) {
              var values = [];

              for (var d = 0; d < allData.length; d++) {
                var item = allData[d];

                if (data.id == item.id) {
                  continue;
                }

                values.push(item.id);
              }

              self.$element.val(values.join(self._valueSeparator));
              self.$element.trigger('input').trigger('change');
            });
          };

          InputData.prototype.query = function (_, params, callback) {
            var results = [];

            for (var d = 0; d < this._currentData.length; d++) {
              var data = this._currentData[d];
              var matches = this.matches(params, data);

              if (matches !== null) {
                results.push(matches);
              }
            }

            callback({
              results: results
            });
          };

          InputData.prototype.addOptions = function (_, $options) {
            var options = $.map($options, function ($option) {
              return Utils.GetData($option[0], 'data');
            });

            this._currentData.push.apply(this._currentData, options);
          };

          return InputData;
        });
        S2.define('select2/compat/matcher', ['jquery'], function ($) {
          function oldMatcher(matcher) {
            function wrappedMatcher(params, data) {
              var match = $.extend(true, {}, data);

              if (params.term == null || $.trim(params.term) === '') {
                return match;
              }

              if (data.children) {
                for (var c = data.children.length - 1; c >= 0; c--) {
                  var child = data.children[c]; // Check if the child object matches
                  // The old matcher returned a boolean true or false

                  var doesMatch = matcher(params.term, child.text, child); // If the child didn't match, pop it off

                  if (!doesMatch) {
                    match.children.splice(c, 1);
                  }
                }

                if (match.children.length > 0) {
                  return match;
                }
              }

              if (matcher(params.term, data.text, data)) {
                return match;
              }

              return null;
            }

            return wrappedMatcher;
          }

          return oldMatcher;
        });
        S2.define('select2/compat/query', [], function () {
          function Query(decorated, $element, options) {
            if (options.get('debug') && window.console && console.warn) {
              console.warn('Select2: The `query` option has been deprecated in favor of a ' + 'custom data adapter that overrides the `query` method. Support ' + 'will be removed for the `query` option in future versions of ' + 'Select2.');
            }

            decorated.call(this, $element, options);
          }

          Query.prototype.query = function (_, params, callback) {
            params.callback = callback;
            var query = this.options.get('query');
            query.call(null, params);
          };

          return Query;
        });
        S2.define('select2/dropdown/attachContainer', [], function () {
          function AttachContainer(decorated, $element, options) {
            decorated.call(this, $element, options);
          }

          AttachContainer.prototype.position = function (decorated, $dropdown, $container) {
            var $dropdownContainer = $container.find('.dropdown-wrapper');
            $dropdownContainer.append($dropdown);
            $dropdown.addClass('select2-dropdown--below');
            $container.addClass('select2-container--below');
          };

          return AttachContainer;
        });
        S2.define('select2/dropdown/stopPropagation', [], function () {
          function StopPropagation() {}

          StopPropagation.prototype.bind = function (decorated, container, $container) {
            decorated.call(this, container, $container);
            var stoppedEvents = ['blur', 'change', 'click', 'dblclick', 'focus', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'keypress', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseup', 'search', 'touchend', 'touchstart'];
            this.$dropdown.on(stoppedEvents.join(' '), function (evt) {
              evt.stopPropagation();
            });
          };

          return StopPropagation;
        });
        S2.define('select2/selection/stopPropagation', [], function () {
          function StopPropagation() {}

          StopPropagation.prototype.bind = function (decorated, container, $container) {
            decorated.call(this, container, $container);
            var stoppedEvents = ['blur', 'change', 'click', 'dblclick', 'focus', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'keypress', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseup', 'search', 'touchend', 'touchstart'];
            this.$selection.on(stoppedEvents.join(' '), function (evt) {
              evt.stopPropagation();
            });
          };

          return StopPropagation;
        });
        /*!
         * jQuery Mousewheel 3.1.13
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         */

        (function (factory) {
          if (typeof S2.define === 'function' && S2.define.amd) {
            // AMD. Register as an anonymous module.
            S2.define('jquery-mousewheel', ['jquery'], factory);
          } else if (true) {
            // Node/CommonJS style for Browserify
            module.exports = factory;
          } else {}
        })(function ($) {
          var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
              toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
              slice = Array.prototype.slice,
              nullLowestDeltaTimeout,
              lowestDelta;

          if ($.event.fixHooks) {
            for (var i = toFix.length; i;) {
              $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
            }
          }

          var special = $.event.special.mousewheel = {
            version: '3.1.12',
            setup: function setup() {
              if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                  this.addEventListener(toBind[--i], handler, false);
                }
              } else {
                this.onmousewheel = handler;
              } // Store the line height and page height for this particular element


              $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
              $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
            },
            teardown: function teardown() {
              if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                  this.removeEventListener(toBind[--i], handler, false);
                }
              } else {
                this.onmousewheel = null;
              } // Clean up the data we added to the element


              $.removeData(this, 'mousewheel-line-height');
              $.removeData(this, 'mousewheel-page-height');
            },
            getLineHeight: function getLineHeight(elem) {
              var $elem = $(elem),
                  $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();

              if (!$parent.length) {
                $parent = $('body');
              }

              return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
            },
            getPageHeight: function getPageHeight(elem) {
              return $(elem).height();
            },
            settings: {
              adjustOldDeltas: true,
              // see shouldAdjustOldDeltas() below
              normalizeOffset: true // calls getBoundingClientRect for each event

            }
          };
          $.fn.extend({
            mousewheel: function mousewheel(fn) {
              return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
            },
            unmousewheel: function unmousewheel(fn) {
              return this.unbind('mousewheel', fn);
            }
          });

          function handler(event) {
            var orgEvent = event || window.event,
                args = slice.call(arguments, 1),
                delta = 0,
                deltaX = 0,
                deltaY = 0,
                absDelta = 0,
                offsetX = 0,
                offsetY = 0;
            event = $.event.fix(orgEvent);
            event.type = 'mousewheel'; // Old school scrollwheel delta

            if ('detail' in orgEvent) {
              deltaY = orgEvent.detail * -1;
            }

            if ('wheelDelta' in orgEvent) {
              deltaY = orgEvent.wheelDelta;
            }

            if ('wheelDeltaY' in orgEvent) {
              deltaY = orgEvent.wheelDeltaY;
            }

            if ('wheelDeltaX' in orgEvent) {
              deltaX = orgEvent.wheelDeltaX * -1;
            } // Firefox < 17 horizontal scrolling related to DOMMouseScroll event


            if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
              deltaX = deltaY * -1;
              deltaY = 0;
            } // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy


            delta = deltaY === 0 ? deltaX : deltaY; // New school wheel delta (wheel event)

            if ('deltaY' in orgEvent) {
              deltaY = orgEvent.deltaY * -1;
              delta = deltaY;
            }

            if ('deltaX' in orgEvent) {
              deltaX = orgEvent.deltaX;

              if (deltaY === 0) {
                delta = deltaX * -1;
              }
            } // No change actually happened, no reason to go any further


            if (deltaY === 0 && deltaX === 0) {
              return;
            } // Need to convert lines and pages to pixels if we aren't already in pixels
            // There are three delta modes:
            //   * deltaMode 0 is by pixels, nothing to do
            //   * deltaMode 1 is by lines
            //   * deltaMode 2 is by pages


            if (orgEvent.deltaMode === 1) {
              var lineHeight = $.data(this, 'mousewheel-line-height');
              delta *= lineHeight;
              deltaY *= lineHeight;
              deltaX *= lineHeight;
            } else if (orgEvent.deltaMode === 2) {
              var pageHeight = $.data(this, 'mousewheel-page-height');
              delta *= pageHeight;
              deltaY *= pageHeight;
              deltaX *= pageHeight;
            } // Store lowest absolute delta to normalize the delta values


            absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

            if (!lowestDelta || absDelta < lowestDelta) {
              lowestDelta = absDelta; // Adjust older deltas if necessary

              if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
              }
            } // Adjust older deltas if necessary


            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
              // Divide all the things by 40!
              delta /= 40;
              deltaX /= 40;
              deltaY /= 40;
            } // Get a whole, normalized value for the deltas


            delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
            deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
            deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta); // Normalise offsetX and offsetY properties

            if (special.settings.normalizeOffset && this.getBoundingClientRect) {
              var boundingRect = this.getBoundingClientRect();
              offsetX = event.clientX - boundingRect.left;
              offsetY = event.clientY - boundingRect.top;
            } // Add information to the event object


            event.deltaX = deltaX;
            event.deltaY = deltaY;
            event.deltaFactor = lowestDelta;
            event.offsetX = offsetX;
            event.offsetY = offsetY; // Go ahead and set deltaMode to 0 since we converted to pixels
            // Although this is a little odd since we overwrite the deltaX/Y
            // properties with normalized deltas.

            event.deltaMode = 0; // Add event and delta to the front of the arguments

            args.unshift(event, delta, deltaX, deltaY); // Clearout lowestDelta after sometime to better
            // handle multiple device types that give different
            // a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120

            if (nullLowestDeltaTimeout) {
              clearTimeout(nullLowestDeltaTimeout);
            }

            nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
            return ($.event.dispatch || $.event.handle).apply(this, args);
          }

          function nullLowestDelta() {
            lowestDelta = null;
          }

          function shouldAdjustOldDeltas(orgEvent, absDelta) {
            // If this is an older event and the delta is divisable by 120,
            // then we are assuming that the browser is treating this as an
            // older mouse wheel event and that we should divide the deltas
            // by 40 to try and get a more usable deltaFactor.
            // Side note, this actually impacts the reported scroll distance
            // in older browsers and can cause scrolling to be slower than native.
            // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
            return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
          }
        });

        S2.define('jquery.select2', ['jquery', 'jquery-mousewheel', './select2/core', './select2/defaults', './select2/utils'], function ($, _, Select2, Defaults, Utils) {
          if ($.fn.select2 == null) {
            // All methods that should return the element
            var thisMethods = ['open', 'close', 'destroy'];

            $.fn.select2 = function (options) {
              options = options || {};

              if (_typeof(options) === 'object') {
                this.each(function () {
                  var instanceOptions = $.extend(true, {}, options);
                  var instance = new Select2($(this), instanceOptions);
                });
                return this;
              } else if (typeof options === 'string') {
                var ret;
                var args = Array.prototype.slice.call(arguments, 1);
                this.each(function () {
                  var instance = Utils.GetData(this, 'select2');

                  if (instance == null && window.console && console.error) {
                    console.error('The select2(\'' + options + '\') method was called on an ' + 'element that is not using Select2.');
                  }

                  ret = instance[options].apply(instance, args);
                }); // Check if we should be returning `this`

                if ($.inArray(options, thisMethods) > -1) {
                  return this;
                }

                return ret;
              } else {
                throw new Error('Invalid arguments for Select2: ' + options);
              }
            };
          }

          if ($.fn.select2.defaults == null) {
            $.fn.select2.defaults = Defaults;
          }

          return Select2;
        }); // Return the AMD loader configuration so it can be used outside of this file

        return {
          define: S2.define,
          require: S2.require
        };
      }(); // Autoload the jQuery bindings
      // We know that all of the modules exist above this, so we're safe


      var select2 = S2.require('jquery.select2'); // Hold the AMD module references on the jQuery function that was just loaded
      // This allows Select2 to use the internal loader outside of this file, such
      // as in the language files.


      jQuery.fn.select2.amd = S2; // Return the Select2 instance for anyone who is importing it.

      return select2;
    });
    /***/

  },

  /***/
  "./resources/assets/vendor/libs/select2/select2.js":
  /*!*********************************************************!*\
    !*** ./resources/assets/vendor/libs/select2/select2.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function resourcesAssetsVendorLibsSelect2Select2Js(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! select2/dist/js/select2.full.js */
    "./node_modules/select2/dist/js/select2.full.js");
    /***/

  },

  /***/
  102:
  /*!***************************************************************!*\
    !*** multi ./resources/assets/vendor/libs/select2/select2.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\xampp\htdocs\globalplanthire\resources\assets\vendor\libs\select2\select2.js */
    "./resources/assets/vendor/libs/select2/select2.js");
    /***/
  },

  /***/
  "jquery":
  /*!*************************!*\
    !*** external "jQuery" ***!
    \*************************/

  /*! no static exports found */

  /***/
  function jquery(module, exports) {
    (function () {
      module.exports = window["jQuery"];
    })();
    /***/

  }
  /******/

}));

/***/ }),

/***/ "./resources/assets/libs/summernote-bs4/summernote-bs4.min.js":
/*!********************************************************************!*\
  !*** ./resources/assets/libs/summernote-bs4/summernote-bs4.min.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! For license information please see summernote-bs4.min.js.LICENSE.txt */
!function (t, e) {
  if ("object" == ( false ? undefined : _typeof(exports)) && "object" == ( false ? undefined : _typeof(module))) module.exports = e(__webpack_require__(/*! jquery */ "jquery"));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "jquery")], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else { var o, n; }
}(window, function (t) {
  return function (t) {
    var e = {};

    function n(o) {
      if (e[o]) return e[o].exports;
      var i = e[o] = {
        i: o,
        l: !1,
        exports: {}
      };
      return t[o].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
    }

    return n.m = t, n.c = e, n.d = function (t, e, o) {
      n.o(t, e) || Object.defineProperty(t, e, {
        enumerable: !0,
        get: o
      });
    }, n.r = function (t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      });
    }, n.t = function (t, e) {
      if (1 & e && (t = n(t)), 8 & e) return t;
      if (4 & e && "object" == _typeof(t) && t && t.__esModule) return t;
      var o = Object.create(null);
      if (n.r(o), Object.defineProperty(o, "default", {
        enumerable: !0,
        value: t
      }), 2 & e && "string" != typeof t) for (var i in t) {
        n.d(o, i, function (e) {
          return t[e];
        }.bind(null, i));
      }
      return o;
    }, n.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t["default"];
      } : function () {
        return t;
      };
      return n.d(e, "a", e), e;
    }, n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, n.p = "", n(n.s = 53);
  }({
    0: function _(e, n) {
      e.exports = t;
    },
    1: function _(t, e, n) {
      "use strict";

      var o = n(0),
          i = n.n(o);

      function r(t) {
        return (r = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
          return _typeof(t);
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
        })(t);
      }

      function a(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var s = function () {
        function t(e, n, o, i) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.markup = e, this.children = n, this.options = o, this.callback = i;
        }

        var e, n, o;
        return e = t, (n = [{
          key: "render",
          value: function value(t) {
            var e = i()(this.markup);

            if (this.options && this.options.contents && e.html(this.options.contents), this.options && this.options.className && e.addClass(this.options.className), this.options && this.options.data && i.a.each(this.options.data, function (t, n) {
              e.attr("data-" + t, n);
            }), this.options && this.options.click && e.on("click", this.options.click), this.children) {
              var n = e.find(".note-children-container");
              this.children.forEach(function (t) {
                t.render(n.length ? n : e);
              });
            }

            return this.callback && this.callback(e, this.options), this.options && this.options.callback && this.options.callback(e), t && t.append(e), e;
          }
        }]) && a(e.prototype, n), o && a(e, o), t;
      }();

      e.a = {
        create: function create(t, e) {
          return function () {
            var n = "object" === r(arguments[1]) ? arguments[1] : arguments[0],
                o = Array.isArray(arguments[0]) ? arguments[0] : [];
            return n && n.children && (o = n.children), new s(t, o, n, e);
          };
        }
      };
    },
    2: function _(t, e) {
      (function (e) {
        t.exports = e;
      }).call(this, {});
    },
    3: function _(t, e, n) {
      "use strict";

      var o = n(0),
          i = n.n(o);
      i.a.summernote = i.a.summernote || {
        lang: {}
      }, i.a.extend(i.a.summernote.lang, {
        "en-US": {
          font: {
            bold: "Bold",
            italic: "Italic",
            underline: "Underline",
            clear: "Remove Font Style",
            height: "Line Height",
            name: "Font Family",
            strikethrough: "Strikethrough",
            subscript: "Subscript",
            superscript: "Superscript",
            size: "Font Size",
            sizeunit: "Font Size Unit"
          },
          image: {
            image: "Picture",
            insert: "Insert Image",
            resizeFull: "Resize full",
            resizeHalf: "Resize half",
            resizeQuarter: "Resize quarter",
            resizeNone: "Original size",
            floatLeft: "Float Left",
            floatRight: "Float Right",
            floatNone: "Remove float",
            shapeRounded: "Shape: Rounded",
            shapeCircle: "Shape: Circle",
            shapeThumbnail: "Shape: Thumbnail",
            shapeNone: "Shape: None",
            dragImageHere: "Drag image or text here",
            dropImage: "Drop image or Text",
            selectFromFiles: "Select from files",
            maximumFileSize: "Maximum file size",
            maximumFileSizeError: "Maximum file size exceeded.",
            url: "Image URL",
            remove: "Remove Image",
            original: "Original"
          },
          video: {
            video: "Video",
            videoLink: "Video Link",
            insert: "Insert Video",
            url: "Video URL",
            providers: "(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)"
          },
          link: {
            link: "Link",
            insert: "Insert Link",
            unlink: "Unlink",
            edit: "Edit",
            textToDisplay: "Text to display",
            url: "To what URL should this link go?",
            openInNewWindow: "Open in new window",
            useProtocol: "Use default protocol"
          },
          table: {
            table: "Table",
            addRowAbove: "Add row above",
            addRowBelow: "Add row below",
            addColLeft: "Add column left",
            addColRight: "Add column right",
            delRow: "Delete row",
            delCol: "Delete column",
            delTable: "Delete table"
          },
          hr: {
            insert: "Insert Horizontal Rule"
          },
          style: {
            style: "Style",
            p: "Normal",
            blockquote: "Quote",
            pre: "Code",
            h1: "Header 1",
            h2: "Header 2",
            h3: "Header 3",
            h4: "Header 4",
            h5: "Header 5",
            h6: "Header 6"
          },
          lists: {
            unordered: "Unordered list",
            ordered: "Ordered list"
          },
          options: {
            help: "Help",
            fullscreen: "Full Screen",
            codeview: "Code View"
          },
          paragraph: {
            paragraph: "Paragraph",
            outdent: "Outdent",
            indent: "Indent",
            left: "Align left",
            center: "Align center",
            right: "Align right",
            justify: "Justify full"
          },
          color: {
            recent: "Recent Color",
            more: "More Color",
            background: "Background Color",
            foreground: "Text Color",
            transparent: "Transparent",
            setTransparent: "Set transparent",
            reset: "Reset",
            resetToDefault: "Reset to default",
            cpSelect: "Select"
          },
          shortcut: {
            shortcuts: "Keyboard shortcuts",
            close: "Close",
            textFormatting: "Text formatting",
            action: "Action",
            paragraphFormatting: "Paragraph formatting",
            documentStyle: "Document Style",
            extraKeys: "Extra keys"
          },
          help: {
            escape: "Escape",
            insertParagraph: "Insert Paragraph",
            undo: "Undo the last command",
            redo: "Redo the last command",
            tab: "Tab",
            untab: "Untab",
            bold: "Set a bold style",
            italic: "Set a italic style",
            underline: "Set a underline style",
            strikethrough: "Set a strikethrough style",
            removeFormat: "Clean a style",
            justifyLeft: "Set left align",
            justifyCenter: "Set center align",
            justifyRight: "Set right align",
            justifyFull: "Set full align",
            insertUnorderedList: "Toggle unordered list",
            insertOrderedList: "Toggle ordered list",
            outdent: "Outdent on current paragraph",
            indent: "Indent on current paragraph",
            formatPara: "Change current block's format as a paragraph(P tag)",
            formatH1: "Change current block's format as H1",
            formatH2: "Change current block's format as H2",
            formatH3: "Change current block's format as H3",
            formatH4: "Change current block's format as H4",
            formatH5: "Change current block's format as H5",
            formatH6: "Change current block's format as H6",
            insertHorizontalRule: "Insert horizontal rule",
            "linkDialog.show": "Show Link Dialog"
          },
          history: {
            undo: "Undo",
            redo: "Redo"
          },
          specialChar: {
            specialChar: "SPECIAL CHARACTERS",
            select: "Select Special characters"
          },
          output: {
            noSelection: "No Selection Made!"
          }
        }
      });
      var r =  true && n(2),
          a = ["sans-serif", "serif", "monospace", "cursive", "fantasy"];

      function s(t) {
        return -1 === i.a.inArray(t.toLowerCase(), a) ? "'".concat(t, "'") : t;
      }

      var l,
          c = navigator.userAgent,
          u = /MSIE|Trident/i.test(c);

      if (u) {
        var d = /MSIE (\d+[.]\d+)/.exec(c);
        d && (l = parseFloat(d[1])), (d = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(c)) && (l = parseFloat(d[1]));
      }

      var h = /Edge\/\d+/.test(c),
          f = "ontouchstart" in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0,
          p = u ? "DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted" : "input",
          m = {
        isMac: navigator.appVersion.indexOf("Mac") > -1,
        isMSIE: u,
        isEdge: h,
        isFF: !h && /firefox/i.test(c),
        isPhantom: /PhantomJS/i.test(c),
        isWebkit: !h && /webkit/i.test(c),
        isChrome: !h && /chrome/i.test(c),
        isSafari: !h && /safari/i.test(c) && !/chrome/i.test(c),
        browserVersion: l,
        jqueryVersion: parseFloat(i.a.fn.jquery),
        isSupportAmd: r,
        isSupportTouch: f,
        isFontInstalled: function isFontInstalled(t) {
          var e = "Comic Sans MS" === t ? "Courier New" : "Comic Sans MS",
              n = document.createElement("canvas").getContext("2d");
          n.font = "200px '" + e + "'";
          var o = n.measureText("mmmmmmmmmmwwwww").width;
          return n.font = "200px " + s(t) + ', "' + e + '"', o !== n.measureText("mmmmmmmmmmwwwww").width;
        },
        isW3CRangeSupport: !!document.createRange,
        inputEventName: p,
        genericFontFamilies: a,
        validFontName: s
      };
      var v = 0;
      var g = {
        eq: function eq(t) {
          return function (e) {
            return t === e;
          };
        },
        eq2: function eq2(t, e) {
          return t === e;
        },
        peq2: function peq2(t) {
          return function (e, n) {
            return e[t] === n[t];
          };
        },
        ok: function ok() {
          return !0;
        },
        fail: function fail() {
          return !1;
        },
        self: function self(t) {
          return t;
        },
        not: function not(t) {
          return function () {
            return !t.apply(t, arguments);
          };
        },
        and: function and(t, e) {
          return function (n) {
            return t(n) && e(n);
          };
        },
        invoke: function invoke(t, e) {
          return function () {
            return t[e].apply(t, arguments);
          };
        },
        resetUniqueId: function resetUniqueId() {
          v = 0;
        },
        uniqueId: function uniqueId(t) {
          var e = ++v + "";
          return t ? t + e : e;
        },
        rect2bnd: function rect2bnd(t) {
          var e = i()(document);
          return {
            top: t.top + e.scrollTop(),
            left: t.left + e.scrollLeft(),
            width: t.right - t.left,
            height: t.bottom - t.top
          };
        },
        invertObject: function invertObject(t) {
          var e = {};

          for (var n in t) {
            Object.prototype.hasOwnProperty.call(t, n) && (e[t[n]] = n);
          }

          return e;
        },
        namespaceToCamel: function namespaceToCamel(t, e) {
          return (e = e || "") + t.split(".").map(function (t) {
            return t.substring(0, 1).toUpperCase() + t.substring(1);
          }).join("");
        },
        debounce: function debounce(t, e, n) {
          var o;
          return function () {
            var i = this,
                r = arguments,
                a = function a() {
              o = null, n || t.apply(i, r);
            },
                s = n && !o;

            clearTimeout(o), o = setTimeout(a, e), s && t.apply(i, r);
          };
        },
        isValidUrl: function isValidUrl(t) {
          return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi.test(t);
        }
      };

      function b(t) {
        return t[0];
      }

      function y(t) {
        return t[t.length - 1];
      }

      function k(t) {
        return t.slice(1);
      }

      function w(t, e) {
        if (t && t.length && e) {
          if (t.indexOf) return -1 !== t.indexOf(e);
          if (t.contains) return t.contains(e);
        }

        return !1;
      }

      var C = {
        head: b,
        last: y,
        initial: function initial(t) {
          return t.slice(0, t.length - 1);
        },
        tail: k,
        prev: function prev(t, e) {
          if (t && t.length && e) {
            var n = t.indexOf(e);
            return -1 === n ? null : t[n - 1];
          }

          return null;
        },
        next: function next(t, e) {
          if (t && t.length && e) {
            var n = t.indexOf(e);
            return -1 === n ? null : t[n + 1];
          }

          return null;
        },
        find: function find(t, e) {
          for (var n = 0, o = t.length; n < o; n++) {
            var i = t[n];
            if (e(i)) return i;
          }
        },
        contains: w,
        all: function all(t, e) {
          for (var n = 0, o = t.length; n < o; n++) {
            if (!e(t[n])) return !1;
          }

          return !0;
        },
        sum: function sum(t, e) {
          return e = e || g.self, t.reduce(function (t, n) {
            return t + e(n);
          }, 0);
        },
        from: function from(t) {
          for (var e = [], n = t.length, o = -1; ++o < n;) {
            e[o] = t[o];
          }

          return e;
        },
        isEmpty: function isEmpty(t) {
          return !t || !t.length;
        },
        clusterBy: function clusterBy(t, e) {
          return t.length ? k(t).reduce(function (t, n) {
            var o = y(t);
            return e(y(o), n) ? o[o.length] = n : t[t.length] = [n], t;
          }, [[b(t)]]) : [];
        },
        compact: function compact(t) {
          for (var e = [], n = 0, o = t.length; n < o; n++) {
            t[n] && e.push(t[n]);
          }

          return e;
        },
        unique: function unique(t) {
          for (var e = [], n = 0, o = t.length; n < o; n++) {
            w(e, t[n]) || e.push(t[n]);
          }

          return e;
        }
      },
          x = String.fromCharCode(160);

      function S(t) {
        return t && i()(t).hasClass("note-editable");
      }

      function T(t) {
        return t = t.toUpperCase(), function (e) {
          return e && e.nodeName.toUpperCase() === t;
        };
      }

      function E(t) {
        return t && 3 === t.nodeType;
      }

      function I(t) {
        return t && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT|^AUDIO|^VIDEO|^EMBED/.test(t.nodeName.toUpperCase());
      }

      function $(t) {
        return !S(t) && t && /^DIV|^P|^LI|^H[1-7]/.test(t.nodeName.toUpperCase());
      }

      var N = T("PRE"),
          P = T("LI");
      var R = T("TABLE"),
          L = T("DATA");

      function A(t) {
        return !(B(t) || F(t) || D(t) || $(t) || R(t) || z(t) || L(t));
      }

      function F(t) {
        return t && /^UL|^OL/.test(t.nodeName.toUpperCase());
      }

      var D = T("HR");

      function H(t) {
        return t && /^TD|^TH/.test(t.nodeName.toUpperCase());
      }

      var z = T("BLOCKQUOTE");

      function B(t) {
        return H(t) || z(t) || S(t);
      }

      var M = T("A");
      var O = T("BODY");
      var j = m.isMSIE && m.browserVersion < 11 ? "&nbsp;" : "<br>";

      function U(t) {
        return E(t) ? t.nodeValue.length : t ? t.childNodes.length : 0;
      }

      function W(t) {
        var e = U(t);
        return 0 === e || !E(t) && 1 === e && t.innerHTML === j || !(!C.all(t.childNodes, E) || "" !== t.innerHTML);
      }

      function K(t) {
        I(t) || U(t) || (t.innerHTML = j);
      }

      function q(t, e) {
        for (; t;) {
          if (e(t)) return t;
          if (S(t)) break;
          t = t.parentNode;
        }

        return null;
      }

      function V(t, e) {
        e = e || g.fail;
        var n = [];
        return q(t, function (t) {
          return S(t) || n.push(t), e(t);
        }), n;
      }

      function _(t, e) {
        e = e || g.fail;

        for (var n = []; t && !e(t);) {
          n.push(t), t = t.nextSibling;
        }

        return n;
      }

      function G(t, e) {
        var n = e.nextSibling,
            o = e.parentNode;
        return n ? o.insertBefore(t, n) : o.appendChild(t), t;
      }

      function Y(t, e) {
        return i.a.each(e, function (e, n) {
          t.appendChild(n);
        }), t;
      }

      function Z(t) {
        return 0 === t.offset;
      }

      function X(t) {
        return t.offset === U(t.node);
      }

      function Q(t) {
        return Z(t) || X(t);
      }

      function J(t, e) {
        for (; t && t !== e;) {
          if (0 !== et(t)) return !1;
          t = t.parentNode;
        }

        return !0;
      }

      function tt(t, e) {
        if (!e) return !1;

        for (; t && t !== e;) {
          if (et(t) !== U(t.parentNode) - 1) return !1;
          t = t.parentNode;
        }

        return !0;
      }

      function et(t) {
        for (var e = 0; t = t.previousSibling;) {
          e += 1;
        }

        return e;
      }

      function nt(t) {
        return !!(t && t.childNodes && t.childNodes.length);
      }

      function ot(t, e) {
        var n, o;

        if (0 === t.offset) {
          if (S(t.node)) return null;
          n = t.node.parentNode, o = et(t.node);
        } else nt(t.node) ? o = U(n = t.node.childNodes[t.offset - 1]) : (n = t.node, o = e ? 0 : t.offset - 1);

        return {
          node: n,
          offset: o
        };
      }

      function it(t, e) {
        var n, o;

        if (U(t.node) === t.offset) {
          if (S(t.node)) return null;
          var i = at(t.node);
          i ? (n = i, o = 0) : (n = t.node.parentNode, o = et(t.node) + 1);
        } else nt(t.node) ? (n = t.node.childNodes[t.offset], o = 0) : (n = t.node, o = e ? U(t.node) : t.offset + 1);

        return {
          node: n,
          offset: o
        };
      }

      function rt(t, e) {
        var n, o;
        if (W(t.node)) return {
          node: n = t.node.nextSibling,
          offset: o = 0
        };

        if (U(t.node) === t.offset) {
          if (S(t.node)) return null;
          var i = at(t.node);
          i ? (n = i, o = 0) : (n = t.node.parentNode, o = et(t.node) + 1), S(n) && (n = t.node.nextSibling, o = 0);
        } else if (nt(t.node)) {
          if (o = 0, W(n = t.node.childNodes[t.offset])) return null;
        } else if (n = t.node, o = e ? U(t.node) : t.offset + 1, W(n)) return null;

        return {
          node: n,
          offset: o
        };
      }

      function at(t) {
        if (t.nextSibling && t.parent === t.nextSibling.parent) return E(t.nextSibling) ? t.nextSibling : at(t.nextSibling);
      }

      function st(t, e) {
        return t.node === e.node && t.offset === e.offset;
      }

      function lt(t, e) {
        var n = e && e.isSkipPaddingBlankHTML,
            o = e && e.isNotSplitEdgePoint,
            i = e && e.isDiscardEmptySplits;

        if (i && (n = !0), Q(t) && (E(t.node) || o)) {
          if (Z(t)) return t.node;
          if (X(t)) return t.node.nextSibling;
        }

        if (E(t.node)) return t.node.splitText(t.offset);
        var r = t.node.childNodes[t.offset],
            a = G(t.node.cloneNode(!1), t.node);
        return Y(a, _(r)), n || (K(t.node), K(a)), i && (W(t.node) && dt(t.node), W(a)) ? (dt(a), t.node.nextSibling) : a;
      }

      function ct(t, e, n) {
        var o = V(e.node, g.eq(t));
        return o.length ? 1 === o.length ? lt(e, n) : o.reduce(function (t, o) {
          return t === e.node && (t = lt(e, n)), lt({
            node: o,
            offset: t ? et(t) : U(o)
          }, n);
        }) : null;
      }

      function ut(t) {
        return document.createElement(t);
      }

      function dt(t, e) {
        if (t && t.parentNode) {
          if (t.removeNode) return t.removeNode(e);
          var n = t.parentNode;

          if (!e) {
            for (var o = [], i = 0, r = t.childNodes.length; i < r; i++) {
              o.push(t.childNodes[i]);
            }

            for (var a = 0, s = o.length; a < s; a++) {
              n.insertBefore(o[a], t);
            }
          }

          n.removeChild(t);
        }
      }

      var ht = T("TEXTAREA");

      function ft(t, e) {
        var n = ht(t[0]) ? t.val() : t.html();
        return e ? n.replace(/[\n\r]/g, "") : n;
      }

      var pt = {
        NBSP_CHAR: x,
        ZERO_WIDTH_NBSP_CHAR: "\uFEFF",
        blank: j,
        emptyPara: "<p>".concat(j, "</p>"),
        makePredByNodeName: T,
        isEditable: S,
        isControlSizing: function isControlSizing(t) {
          return t && i()(t).hasClass("note-control-sizing");
        },
        isText: E,
        isElement: function isElement(t) {
          return t && 1 === t.nodeType;
        },
        isVoid: I,
        isPara: $,
        isPurePara: function isPurePara(t) {
          return $(t) && !P(t);
        },
        isHeading: function isHeading(t) {
          return t && /^H[1-7]/.test(t.nodeName.toUpperCase());
        },
        isInline: A,
        isBlock: g.not(A),
        isBodyInline: function isBodyInline(t) {
          return A(t) && !q(t, $);
        },
        isBody: O,
        isParaInline: function isParaInline(t) {
          return A(t) && !!q(t, $);
        },
        isPre: N,
        isList: F,
        isTable: R,
        isData: L,
        isCell: H,
        isBlockquote: z,
        isBodyContainer: B,
        isAnchor: M,
        isDiv: T("DIV"),
        isLi: P,
        isBR: T("BR"),
        isSpan: T("SPAN"),
        isB: T("B"),
        isU: T("U"),
        isS: T("S"),
        isI: T("I"),
        isImg: T("IMG"),
        isTextarea: ht,
        deepestChildIsEmpty: function deepestChildIsEmpty(t) {
          do {
            if (null === t.firstElementChild || "" === t.firstElementChild.innerHTML) break;
          } while (t = t.firstElementChild);

          return W(t);
        },
        isEmpty: W,
        isEmptyAnchor: g.and(M, W),
        isClosestSibling: function isClosestSibling(t, e) {
          return t.nextSibling === e || t.previousSibling === e;
        },
        withClosestSiblings: function withClosestSiblings(t, e) {
          e = e || g.ok;
          var n = [];
          return t.previousSibling && e(t.previousSibling) && n.push(t.previousSibling), n.push(t), t.nextSibling && e(t.nextSibling) && n.push(t.nextSibling), n;
        },
        nodeLength: U,
        isLeftEdgePoint: Z,
        isRightEdgePoint: X,
        isEdgePoint: Q,
        isLeftEdgeOf: J,
        isRightEdgeOf: tt,
        isLeftEdgePointOf: function isLeftEdgePointOf(t, e) {
          return Z(t) && J(t.node, e);
        },
        isRightEdgePointOf: function isRightEdgePointOf(t, e) {
          return X(t) && tt(t.node, e);
        },
        prevPoint: ot,
        nextPoint: it,
        nextPointWithEmptyNode: rt,
        isSamePoint: st,
        isVisiblePoint: function isVisiblePoint(t) {
          if (E(t.node) || !nt(t.node) || W(t.node)) return !0;
          var e = t.node.childNodes[t.offset - 1],
              n = t.node.childNodes[t.offset];
          return !(e && !I(e) || n && !I(n));
        },
        prevPointUntil: function prevPointUntil(t, e) {
          for (; t;) {
            if (e(t)) return t;
            t = ot(t);
          }

          return null;
        },
        nextPointUntil: function nextPointUntil(t, e) {
          for (; t;) {
            if (e(t)) return t;
            t = it(t);
          }

          return null;
        },
        isCharPoint: function isCharPoint(t) {
          if (!E(t.node)) return !1;
          var e = t.node.nodeValue.charAt(t.offset - 1);
          return e && " " !== e && e !== x;
        },
        isSpacePoint: function isSpacePoint(t) {
          if (!E(t.node)) return !1;
          var e = t.node.nodeValue.charAt(t.offset - 1);
          return " " === e || e === x;
        },
        walkPoint: function walkPoint(t, e, n, o) {
          for (var i = t; i && (n(i), !st(i, e));) {
            i = rt(i, o && t.node !== i.node && e.node !== i.node);
          }
        },
        ancestor: q,
        singleChildAncestor: function singleChildAncestor(t, e) {
          for (t = t.parentNode; t && 1 === U(t);) {
            if (e(t)) return t;
            if (S(t)) break;
            t = t.parentNode;
          }

          return null;
        },
        listAncestor: V,
        lastAncestor: function lastAncestor(t, e) {
          var n = V(t);
          return C.last(n.filter(e));
        },
        listNext: _,
        listPrev: function listPrev(t, e) {
          e = e || g.fail;

          for (var n = []; t && !e(t);) {
            n.push(t), t = t.previousSibling;
          }

          return n;
        },
        listDescendant: function listDescendant(t, e) {
          var n = [];
          return e = e || g.ok, function o(i) {
            t !== i && e(i) && n.push(i);

            for (var r = 0, a = i.childNodes.length; r < a; r++) {
              o(i.childNodes[r]);
            }
          }(t), n;
        },
        commonAncestor: function commonAncestor(t, e) {
          for (var n = V(t), o = e; o; o = o.parentNode) {
            if (n.indexOf(o) > -1) return o;
          }

          return null;
        },
        wrap: function wrap(t, e) {
          var n = t.parentNode,
              o = i()("<" + e + ">")[0];
          return n.insertBefore(o, t), o.appendChild(t), o;
        },
        insertAfter: G,
        appendChildNodes: Y,
        position: et,
        hasChildren: nt,
        makeOffsetPath: function makeOffsetPath(t, e) {
          return V(e, g.eq(t)).map(et).reverse();
        },
        fromOffsetPath: function fromOffsetPath(t, e) {
          for (var n = t, o = 0, i = e.length; o < i; o++) {
            n = n.childNodes.length <= e[o] ? n.childNodes[n.childNodes.length - 1] : n.childNodes[e[o]];
          }

          return n;
        },
        splitTree: ct,
        splitPoint: function splitPoint(t, e) {
          var n,
              o,
              i = e ? $ : B,
              r = V(t.node, i),
              a = C.last(r) || t.node;
          i(a) ? (n = r[r.length - 2], o = a) : o = (n = a).parentNode;
          var s = n && ct(n, t, {
            isSkipPaddingBlankHTML: e,
            isNotSplitEdgePoint: e
          });
          return s || o !== t.node || (s = t.node.childNodes[t.offset]), {
            rightNode: s,
            container: o
          };
        },
        create: ut,
        createText: function createText(t) {
          return document.createTextNode(t);
        },
        remove: dt,
        removeWhile: function removeWhile(t, e) {
          for (; t && !S(t) && e(t);) {
            var n = t.parentNode;
            dt(t), t = n;
          }
        },
        replace: function replace(t, e) {
          if (t.nodeName.toUpperCase() === e.toUpperCase()) return t;
          var n = ut(e);
          return t.style.cssText && (n.style.cssText = t.style.cssText), Y(n, C.from(t.childNodes)), G(n, t), dt(t), n;
        },
        html: function html(t, e) {
          var n = ft(t);

          if (e) {
            n = (n = n.replace(/<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g, function (t, e, n) {
              n = n.toUpperCase();
              var o = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(n) && !!e,
                  i = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(n);
              return t + (o || i ? "\n" : "");
            })).trim();
          }

          return n;
        },
        value: ft,
        posFromPlaceholder: function posFromPlaceholder(t) {
          var e = i()(t),
              n = e.offset(),
              o = e.outerHeight(!0);
          return {
            left: n.left,
            top: n.top + o
          };
        },
        attachEvents: function attachEvents(t, e) {
          Object.keys(e).forEach(function (n) {
            t.on(n, e[n]);
          });
        },
        detachEvents: function detachEvents(t, e) {
          Object.keys(e).forEach(function (n) {
            t.off(n, e[n]);
          });
        },
        isCustomStyleTag: function isCustomStyleTag(t) {
          return t && !E(t) && C.contains(t.classList, "note-styletag");
        }
      };

      function mt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var vt = function () {
        function t(e, n) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.$note = e, this.memos = {}, this.modules = {}, this.layoutInfo = {}, this.options = i.a.extend(!0, {}, n), i.a.summernote.ui = i.a.summernote.ui_template(this.options), this.ui = i.a.summernote.ui, this.initialize();
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            return this.layoutInfo = this.ui.createLayout(this.$note), this._initialize(), this.$note.hide(), this;
          }
        }, {
          key: "destroy",
          value: function value() {
            this._destroy(), this.$note.removeData("summernote"), this.ui.removeLayout(this.$note, this.layoutInfo);
          }
        }, {
          key: "reset",
          value: function value() {
            var t = this.isDisabled();
            this.code(pt.emptyPara), this._destroy(), this._initialize(), t && this.disable();
          }
        }, {
          key: "_initialize",
          value: function value() {
            var t = this;
            this.options.id = g.uniqueId(i.a.now()), this.options.container = this.options.container || this.layoutInfo.editor;
            var e = i.a.extend({}, this.options.buttons);
            Object.keys(e).forEach(function (n) {
              t.memo("button." + n, e[n]);
            });
            var n = i.a.extend({}, this.options.modules, i.a.summernote.plugins || {});
            Object.keys(n).forEach(function (e) {
              t.module(e, n[e], !0);
            }), Object.keys(this.modules).forEach(function (e) {
              t.initializeModule(e);
            });
          }
        }, {
          key: "_destroy",
          value: function value() {
            var t = this;
            Object.keys(this.modules).reverse().forEach(function (e) {
              t.removeModule(e);
            }), Object.keys(this.memos).forEach(function (e) {
              t.removeMemo(e);
            }), this.triggerEvent("destroy", this);
          }
        }, {
          key: "code",
          value: function value(t) {
            var e = this.invoke("codeview.isActivated");
            if (void 0 === t) return this.invoke("codeview.sync"), e ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
            e ? this.invoke("codeview.sync", t) : this.layoutInfo.editable.html(t), this.$note.val(t), this.triggerEvent("change", t, this.layoutInfo.editable);
          }
        }, {
          key: "isDisabled",
          value: function value() {
            return "false" === this.layoutInfo.editable.attr("contenteditable");
          }
        }, {
          key: "enable",
          value: function value() {
            this.layoutInfo.editable.attr("contenteditable", !0), this.invoke("toolbar.activate", !0), this.triggerEvent("disable", !1), this.options.editing = !0;
          }
        }, {
          key: "disable",
          value: function value() {
            this.invoke("codeview.isActivated") && this.invoke("codeview.deactivate"), this.layoutInfo.editable.attr("contenteditable", !1), this.options.editing = !1, this.invoke("toolbar.deactivate", !0), this.triggerEvent("disable", !0);
          }
        }, {
          key: "triggerEvent",
          value: function value() {
            var t = C.head(arguments),
                e = C.tail(C.from(arguments)),
                n = this.options.callbacks[g.namespaceToCamel(t, "on")];
            n && n.apply(this.$note[0], e), this.$note.trigger("summernote." + t, e);
          }
        }, {
          key: "initializeModule",
          value: function value(t) {
            var e = this.modules[t];
            e.shouldInitialize = e.shouldInitialize || g.ok, e.shouldInitialize() && (e.initialize && e.initialize(), e.events && pt.attachEvents(this.$note, e.events));
          }
        }, {
          key: "module",
          value: function value(t, e, n) {
            if (1 === arguments.length) return this.modules[t];
            this.modules[t] = new e(this), n || this.initializeModule(t);
          }
        }, {
          key: "removeModule",
          value: function value(t) {
            var e = this.modules[t];
            e.shouldInitialize() && (e.events && pt.detachEvents(this.$note, e.events), e.destroy && e.destroy()), delete this.modules[t];
          }
        }, {
          key: "memo",
          value: function value(t, e) {
            if (1 === arguments.length) return this.memos[t];
            this.memos[t] = e;
          }
        }, {
          key: "removeMemo",
          value: function value(t) {
            this.memos[t] && this.memos[t].destroy && this.memos[t].destroy(), delete this.memos[t];
          }
        }, {
          key: "createInvokeHandlerAndUpdateState",
          value: function value(t, e) {
            var n = this;
            return function (o) {
              n.createInvokeHandler(t, e)(o), n.invoke("buttons.updateCurrentStyle");
            };
          }
        }, {
          key: "createInvokeHandler",
          value: function value(t, e) {
            var n = this;
            return function (o) {
              o.preventDefault();
              var r = i()(o.target);
              n.invoke(t, e || r.closest("[data-value]").data("value"), r);
            };
          }
        }, {
          key: "invoke",
          value: function value() {
            var t = C.head(arguments),
                e = C.tail(C.from(arguments)),
                n = t.split("."),
                o = n.length > 1,
                i = o && C.head(n),
                r = o ? C.last(n) : C.head(n),
                a = this.modules[i || "editor"];
            return !i && this[r] ? this[r].apply(this, e) : a && a[r] && a.shouldInitialize() ? a[r].apply(a, e) : void 0;
          }
        }]) && mt(e.prototype, n), o && mt(e, o), t;
      }();

      function gt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      function bt(t, e) {
        var n,
            o,
            i = t.parentElement(),
            r = document.body.createTextRange(),
            a = C.from(i.childNodes);

        for (n = 0; n < a.length; n++) {
          if (!pt.isText(a[n])) {
            if (r.moveToElementText(a[n]), r.compareEndPoints("StartToStart", t) >= 0) break;
            o = a[n];
          }
        }

        if (0 !== n && pt.isText(a[n - 1])) {
          var s = document.body.createTextRange(),
              l = null;
          s.moveToElementText(o || i), s.collapse(!o), l = o ? o.nextSibling : i.firstChild;
          var c = t.duplicate();
          c.setEndPoint("StartToStart", s);

          for (var u = c.text.replace(/[\r\n]/g, "").length; u > l.nodeValue.length && l.nextSibling;) {
            u -= l.nodeValue.length, l = l.nextSibling;
          }

          l.nodeValue;
          e && l.nextSibling && pt.isText(l.nextSibling) && u === l.nodeValue.length && (u -= l.nodeValue.length, l = l.nextSibling), i = l, n = u;
        }

        return {
          cont: i,
          offset: n
        };
      }

      function yt(t) {
        var e = document.body.createTextRange(),
            n = function t(e, n) {
          var o, i;

          if (pt.isText(e)) {
            var r = pt.listPrev(e, g.not(pt.isText)),
                a = C.last(r).previousSibling;
            o = a || e.parentNode, n += C.sum(C.tail(r), pt.nodeLength), i = !a;
          } else {
            if (o = e.childNodes[n] || e, pt.isText(o)) return t(o, 0);
            n = 0, i = !1;
          }

          return {
            node: o,
            collapseToStart: i,
            offset: n
          };
        }(t.node, t.offset);

        return e.moveToElementText(n.node), e.collapse(n.collapseToStart), e.moveStart("character", n.offset), e;
      }

      i.a.fn.extend({
        summernote: function summernote() {
          var t = i.a.type(C.head(arguments)),
              e = "string" === t,
              n = "object" === t,
              o = i.a.extend({}, i.a.summernote.options, n ? C.head(arguments) : {});
          o.langInfo = i.a.extend(!0, {}, i.a.summernote.lang["en-US"], i.a.summernote.lang[o.lang]), o.icons = i.a.extend(!0, {}, i.a.summernote.options.icons, o.icons), o.tooltip = "auto" === o.tooltip ? !m.isSupportTouch : o.tooltip, this.each(function (t, e) {
            var n = i()(e);

            if (!n.data("summernote")) {
              var r = new vt(n, o);
              n.data("summernote", r), n.data("summernote").triggerEvent("init", r.layoutInfo);
            }
          });
          var r = this.first();

          if (r.length) {
            var a = r.data("summernote");
            if (e) return a.invoke.apply(a, C.from(arguments));
            o.focus && a.invoke("editor.focus");
          }

          return this;
        }
      });

      var kt = function () {
        function t(e, n, o, i) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.sc = e, this.so = n, this.ec = o, this.eo = i, this.isOnEditable = this.makeIsOn(pt.isEditable), this.isOnList = this.makeIsOn(pt.isList), this.isOnAnchor = this.makeIsOn(pt.isAnchor), this.isOnCell = this.makeIsOn(pt.isCell), this.isOnData = this.makeIsOn(pt.isData);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "nativeRange",
          value: function value() {
            if (m.isW3CRangeSupport) {
              var t = document.createRange();
              return t.setStart(this.sc, this.so), t.setEnd(this.ec, this.eo), t;
            }

            var e = yt({
              node: this.sc,
              offset: this.so
            });
            return e.setEndPoint("EndToEnd", yt({
              node: this.ec,
              offset: this.eo
            })), e;
          }
        }, {
          key: "getPoints",
          value: function value() {
            return {
              sc: this.sc,
              so: this.so,
              ec: this.ec,
              eo: this.eo
            };
          }
        }, {
          key: "getStartPoint",
          value: function value() {
            return {
              node: this.sc,
              offset: this.so
            };
          }
        }, {
          key: "getEndPoint",
          value: function value() {
            return {
              node: this.ec,
              offset: this.eo
            };
          }
        }, {
          key: "select",
          value: function value() {
            var t = this.nativeRange();

            if (m.isW3CRangeSupport) {
              var e = document.getSelection();
              e.rangeCount > 0 && e.removeAllRanges(), e.addRange(t);
            } else t.select();

            return this;
          }
        }, {
          key: "scrollIntoView",
          value: function value(t) {
            var e = i()(t).height();
            return t.scrollTop + e < this.sc.offsetTop && (t.scrollTop += Math.abs(t.scrollTop + e - this.sc.offsetTop)), this;
          }
        }, {
          key: "normalize",
          value: function value() {
            var e = function e(t, _e) {
              if (!t) return t;
              if (pt.isVisiblePoint(t) && (!pt.isEdgePoint(t) || pt.isRightEdgePoint(t) && !_e || pt.isLeftEdgePoint(t) && _e || pt.isRightEdgePoint(t) && _e && pt.isVoid(t.node.nextSibling) || pt.isLeftEdgePoint(t) && !_e && pt.isVoid(t.node.previousSibling) || pt.isBlock(t.node) && pt.isEmpty(t.node))) return t;
              var n = pt.ancestor(t.node, pt.isBlock),
                  o = !1;

              if (!o) {
                var i = pt.prevPoint(t) || {
                  node: null
                };
                o = (pt.isLeftEdgePointOf(t, n) || pt.isVoid(i.node)) && !_e;
              }

              var r = !1;

              if (!r) {
                var a = pt.nextPoint(t) || {
                  node: null
                };
                r = (pt.isRightEdgePointOf(t, n) || pt.isVoid(a.node)) && _e;
              }

              if (o || r) {
                if (pt.isVisiblePoint(t)) return t;
                _e = !_e;
              }

              return (_e ? pt.nextPointUntil(pt.nextPoint(t), pt.isVisiblePoint) : pt.prevPointUntil(pt.prevPoint(t), pt.isVisiblePoint)) || t;
            },
                n = e(this.getEndPoint(), !1),
                o = this.isCollapsed() ? n : e(this.getStartPoint(), !0);

            return new t(o.node, o.offset, n.node, n.offset);
          }
        }, {
          key: "nodes",
          value: function value(t, e) {
            t = t || g.ok;
            var n = e && e.includeAncestor,
                o = e && e.fullyContains,
                i = this.getStartPoint(),
                r = this.getEndPoint(),
                a = [],
                s = [];
            return pt.walkPoint(i, r, function (e) {
              var i;
              pt.isEditable(e.node) || (o ? (pt.isLeftEdgePoint(e) && s.push(e.node), pt.isRightEdgePoint(e) && C.contains(s, e.node) && (i = e.node)) : i = n ? pt.ancestor(e.node, t) : e.node, i && t(i) && a.push(i));
            }, !0), C.unique(a);
          }
        }, {
          key: "commonAncestor",
          value: function value() {
            return pt.commonAncestor(this.sc, this.ec);
          }
        }, {
          key: "expand",
          value: function value(e) {
            var n = pt.ancestor(this.sc, e),
                o = pt.ancestor(this.ec, e);
            if (!n && !o) return new t(this.sc, this.so, this.ec, this.eo);
            var i = this.getPoints();
            return n && (i.sc = n, i.so = 0), o && (i.ec = o, i.eo = pt.nodeLength(o)), new t(i.sc, i.so, i.ec, i.eo);
          }
        }, {
          key: "collapse",
          value: function value(e) {
            return e ? new t(this.sc, this.so, this.sc, this.so) : new t(this.ec, this.eo, this.ec, this.eo);
          }
        }, {
          key: "splitText",
          value: function value() {
            var e = this.sc === this.ec,
                n = this.getPoints();
            return pt.isText(this.ec) && !pt.isEdgePoint(this.getEndPoint()) && this.ec.splitText(this.eo), pt.isText(this.sc) && !pt.isEdgePoint(this.getStartPoint()) && (n.sc = this.sc.splitText(this.so), n.so = 0, e && (n.ec = n.sc, n.eo = this.eo - this.so)), new t(n.sc, n.so, n.ec, n.eo);
          }
        }, {
          key: "deleteContents",
          value: function value() {
            if (this.isCollapsed()) return this;
            var e = this.splitText(),
                n = e.nodes(null, {
              fullyContains: !0
            }),
                o = pt.prevPointUntil(e.getStartPoint(), function (t) {
              return !C.contains(n, t.node);
            }),
                r = [];
            return i.a.each(n, function (t, e) {
              var n = e.parentNode;
              o.node !== n && 1 === pt.nodeLength(n) && r.push(n), pt.remove(e, !1);
            }), i.a.each(r, function (t, e) {
              pt.remove(e, !1);
            }), new t(o.node, o.offset, o.node, o.offset).normalize();
          }
        }, {
          key: "makeIsOn",
          value: function value(t) {
            return function () {
              var e = pt.ancestor(this.sc, t);
              return !!e && e === pt.ancestor(this.ec, t);
            };
          }
        }, {
          key: "isLeftEdgeOf",
          value: function value(t) {
            if (!pt.isLeftEdgePoint(this.getStartPoint())) return !1;
            var e = pt.ancestor(this.sc, t);
            return e && pt.isLeftEdgeOf(this.sc, e);
          }
        }, {
          key: "isCollapsed",
          value: function value() {
            return this.sc === this.ec && this.so === this.eo;
          }
        }, {
          key: "wrapBodyInlineWithPara",
          value: function value() {
            if (pt.isBodyContainer(this.sc) && pt.isEmpty(this.sc)) return this.sc.innerHTML = pt.emptyPara, new t(this.sc.firstChild, 0, this.sc.firstChild, 0);
            var e,
                n = this.normalize();
            if (pt.isParaInline(this.sc) || pt.isPara(this.sc)) return n;

            if (pt.isInline(n.sc)) {
              var o = pt.listAncestor(n.sc, g.not(pt.isInline));
              e = C.last(o), pt.isInline(e) || (e = o[o.length - 2] || n.sc.childNodes[n.so]);
            } else e = n.sc.childNodes[n.so > 0 ? n.so - 1 : 0];

            if (e) {
              var i = pt.listPrev(e, pt.isParaInline).reverse();

              if ((i = i.concat(pt.listNext(e.nextSibling, pt.isParaInline))).length) {
                var r = pt.wrap(C.head(i), "p");
                pt.appendChildNodes(r, C.tail(i));
              }
            }

            return this.normalize();
          }
        }, {
          key: "insertNode",
          value: function value(t) {
            var e = this;
            (pt.isText(t) || pt.isInline(t)) && (e = this.wrapBodyInlineWithPara().deleteContents());
            var n = pt.splitPoint(e.getStartPoint(), pt.isInline(t));
            return n.rightNode ? (n.rightNode.parentNode.insertBefore(t, n.rightNode), pt.isEmpty(n.rightNode) && pt.isPara(t) && n.rightNode.parentNode.removeChild(n.rightNode)) : n.container.appendChild(t), t;
          }
        }, {
          key: "pasteHTML",
          value: function value(t) {
            t = i.a.trim(t);
            var e = i()("<div></div>").html(t)[0],
                n = C.from(e.childNodes),
                o = this,
                r = !1;
            return o.so >= 0 && (n = n.reverse(), r = !0), n = n.map(function (t) {
              return o.insertNode(t);
            }), r && (n = n.reverse()), n;
          }
        }, {
          key: "toString",
          value: function value() {
            var t = this.nativeRange();
            return m.isW3CRangeSupport ? t.toString() : t.text;
          }
        }, {
          key: "getWordRange",
          value: function value(e) {
            var n = this.getEndPoint();
            if (!pt.isCharPoint(n)) return this;
            var o = pt.prevPointUntil(n, function (t) {
              return !pt.isCharPoint(t);
            });
            return e && (n = pt.nextPointUntil(n, function (t) {
              return !pt.isCharPoint(t);
            })), new t(o.node, o.offset, n.node, n.offset);
          }
        }, {
          key: "getWordsRange",
          value: function value(e) {
            var n = this.getEndPoint(),
                o = function o(t) {
              return !pt.isCharPoint(t) && !pt.isSpacePoint(t);
            };

            if (o(n)) return this;
            var i = pt.prevPointUntil(n, o);
            return e && (n = pt.nextPointUntil(n, o)), new t(i.node, i.offset, n.node, n.offset);
          }
        }, {
          key: "getWordsMatchRange",
          value: function value(e) {
            var n = this.getEndPoint(),
                o = pt.prevPointUntil(n, function (o) {
              if (!pt.isCharPoint(o) && !pt.isSpacePoint(o)) return !0;
              var i = new t(o.node, o.offset, n.node, n.offset),
                  r = e.exec(i.toString());
              return r && 0 === r.index;
            }),
                i = new t(o.node, o.offset, n.node, n.offset),
                r = i.toString(),
                a = e.exec(r);
            return a && a[0].length === r.length ? i : null;
          }
        }, {
          key: "bookmark",
          value: function value(t) {
            return {
              s: {
                path: pt.makeOffsetPath(t, this.sc),
                offset: this.so
              },
              e: {
                path: pt.makeOffsetPath(t, this.ec),
                offset: this.eo
              }
            };
          }
        }, {
          key: "paraBookmark",
          value: function value(t) {
            return {
              s: {
                path: C.tail(pt.makeOffsetPath(C.head(t), this.sc)),
                offset: this.so
              },
              e: {
                path: C.tail(pt.makeOffsetPath(C.last(t), this.ec)),
                offset: this.eo
              }
            };
          }
        }, {
          key: "getClientRects",
          value: function value() {
            return this.nativeRange().getClientRects();
          }
        }]) && gt(e.prototype, n), o && gt(e, o), t;
      }(),
          wt = {
        create: function create(t, e, n, o) {
          if (4 === arguments.length) return new kt(t, e, n, o);
          if (2 === arguments.length) return new kt(t, e, n = t, o = e);
          var i = this.createFromSelection();

          if (!i && 1 === arguments.length) {
            var r = arguments[0];
            return pt.isEditable(r) && (r = r.lastChild), this.createFromBodyElement(r, pt.emptyPara === arguments[0].innerHTML);
          }

          return i;
        },
        createFromBodyElement: function createFromBodyElement(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              n = this.createFromNode(t);
          return n.collapse(e);
        },
        createFromSelection: function createFromSelection() {
          var t, e, n, o;

          if (m.isW3CRangeSupport) {
            var i = document.getSelection();
            if (!i || 0 === i.rangeCount) return null;
            if (pt.isBody(i.anchorNode)) return null;
            var r = i.getRangeAt(0);
            t = r.startContainer, e = r.startOffset, n = r.endContainer, o = r.endOffset;
          } else {
            var a = document.selection.createRange(),
                s = a.duplicate();
            s.collapse(!1);
            var l = a;
            l.collapse(!0);
            var c = bt(l, !0),
                u = bt(s, !1);
            pt.isText(c.node) && pt.isLeftEdgePoint(c) && pt.isTextNode(u.node) && pt.isRightEdgePoint(u) && u.node.nextSibling === c.node && (c = u), t = c.cont, e = c.offset, n = u.cont, o = u.offset;
          }

          return new kt(t, e, n, o);
        },
        createFromNode: function createFromNode(t) {
          var e = t,
              n = 0,
              o = t,
              i = pt.nodeLength(o);
          return pt.isVoid(e) && (n = pt.listPrev(e).length - 1, e = e.parentNode), pt.isBR(o) ? (i = pt.listPrev(o).length - 1, o = o.parentNode) : pt.isVoid(o) && (i = pt.listPrev(o).length, o = o.parentNode), this.create(e, n, o, i);
        },
        createFromNodeBefore: function createFromNodeBefore(t) {
          return this.createFromNode(t).collapse(!0);
        },
        createFromNodeAfter: function createFromNodeAfter(t) {
          return this.createFromNode(t).collapse();
        },
        createFromBookmark: function createFromBookmark(t, e) {
          var n = pt.fromOffsetPath(t, e.s.path),
              o = e.s.offset,
              i = pt.fromOffsetPath(t, e.e.path),
              r = e.e.offset;
          return new kt(n, o, i, r);
        },
        createFromParaBookmark: function createFromParaBookmark(t, e) {
          var n = t.s.offset,
              o = t.e.offset,
              i = pt.fromOffsetPath(C.head(e), t.s.path),
              r = pt.fromOffsetPath(C.last(e), t.e.path);
          return new kt(i, n, r, o);
        }
      },
          Ct = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        ESCAPE: 27,
        SPACE: 32,
        DELETE: 46,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        NUM0: 48,
        NUM1: 49,
        NUM2: 50,
        NUM3: 51,
        NUM4: 52,
        NUM5: 53,
        NUM6: 54,
        NUM7: 55,
        NUM8: 56,
        B: 66,
        E: 69,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        R: 82,
        S: 83,
        U: 85,
        V: 86,
        Y: 89,
        Z: 90,
        SLASH: 191,
        LEFTBRACKET: 219,
        BACKSLASH: 220,
        RIGHTBRACKET: 221,
        HOME: 36,
        END: 35,
        PAGEUP: 33,
        PAGEDOWN: 34
      },
          xt = {
        isEdit: function isEdit(t) {
          return C.contains([Ct.BACKSPACE, Ct.TAB, Ct.ENTER, Ct.SPACE, Ct.DELETE], t);
        },
        isMove: function isMove(t) {
          return C.contains([Ct.LEFT, Ct.UP, Ct.RIGHT, Ct.DOWN], t);
        },
        isNavigation: function isNavigation(t) {
          return C.contains([Ct.HOME, Ct.END, Ct.PAGEUP, Ct.PAGEDOWN], t);
        },
        nameFromCode: g.invertObject(Ct),
        code: Ct
      };

      function St(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Tt = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.stack = [], this.stackOffset = -1, this.context = e, this.$editable = e.layoutInfo.editable, this.editable = this.$editable[0];
        }

        var e, n, o;
        return e = t, (n = [{
          key: "makeSnapshot",
          value: function value() {
            var t = wt.create(this.editable);
            return {
              contents: this.$editable.html(),
              bookmark: t && t.isOnEditable() ? t.bookmark(this.editable) : {
                s: {
                  path: [],
                  offset: 0
                },
                e: {
                  path: [],
                  offset: 0
                }
              }
            };
          }
        }, {
          key: "applySnapshot",
          value: function value(t) {
            null !== t.contents && this.$editable.html(t.contents), null !== t.bookmark && wt.createFromBookmark(this.editable, t.bookmark).select();
          }
        }, {
          key: "rewind",
          value: function value() {
            this.$editable.html() !== this.stack[this.stackOffset].contents && this.recordUndo(), this.stackOffset = 0, this.applySnapshot(this.stack[this.stackOffset]);
          }
        }, {
          key: "commit",
          value: function value() {
            this.stack = [], this.stackOffset = -1, this.recordUndo();
          }
        }, {
          key: "reset",
          value: function value() {
            this.stack = [], this.stackOffset = -1, this.$editable.html(""), this.recordUndo();
          }
        }, {
          key: "undo",
          value: function value() {
            this.$editable.html() !== this.stack[this.stackOffset].contents && this.recordUndo(), this.stackOffset > 0 && (this.stackOffset--, this.applySnapshot(this.stack[this.stackOffset]));
          }
        }, {
          key: "redo",
          value: function value() {
            this.stack.length - 1 > this.stackOffset && (this.stackOffset++, this.applySnapshot(this.stack[this.stackOffset]));
          }
        }, {
          key: "recordUndo",
          value: function value() {
            this.stackOffset++, this.stack.length > this.stackOffset && (this.stack = this.stack.slice(0, this.stackOffset)), this.stack.push(this.makeSnapshot()), this.stack.length > this.context.options.historyLimit && (this.stack.shift(), this.stackOffset -= 1);
          }
        }]) && St(e.prototype, n), o && St(e, o), t;
      }();

      function Et(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var It = function () {
        function t() {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "jQueryCSS",
          value: function value(t, e) {
            if (m.jqueryVersion < 1.9) {
              var n = {};
              return i.a.each(e, function (e, o) {
                n[o] = t.css(o);
              }), n;
            }

            return t.css(e);
          }
        }, {
          key: "fromNode",
          value: function value(t) {
            var e = this.jQueryCSS(t, ["font-family", "font-size", "text-align", "list-style-type", "line-height"]) || {},
                n = t[0].style.fontSize || e["font-size"];
            return e["font-size"] = parseInt(n, 10), e["font-size-unit"] = n.match(/[a-z%]+$/), e;
          }
        }, {
          key: "stylePara",
          value: function value(t, e) {
            i.a.each(t.nodes(pt.isPara, {
              includeAncestor: !0
            }), function (t, n) {
              i()(n).css(e);
            });
          }
        }, {
          key: "styleNodes",
          value: function value(t, e) {
            t = t.splitText();
            var n = e && e.nodeName || "SPAN",
                o = !(!e || !e.expandClosestSibling),
                r = !(!e || !e.onlyPartialContains);
            if (t.isCollapsed()) return [t.insertNode(pt.create(n))];
            var a = pt.makePredByNodeName(n),
                s = t.nodes(pt.isText, {
              fullyContains: !0
            }).map(function (t) {
              return pt.singleChildAncestor(t, a) || pt.wrap(t, n);
            });

            if (o) {
              if (r) {
                var l = t.nodes();
                a = g.and(a, function (t) {
                  return C.contains(l, t);
                });
              }

              return s.map(function (t) {
                var e = pt.withClosestSiblings(t, a),
                    n = C.head(e),
                    o = C.tail(e);
                return i.a.each(o, function (t, e) {
                  pt.appendChildNodes(n, e.childNodes), pt.remove(e);
                }), C.head(e);
              });
            }

            return s;
          }
        }, {
          key: "current",
          value: function value(t) {
            var e = i()(pt.isElement(t.sc) ? t.sc : t.sc.parentNode),
                n = this.fromNode(e);

            try {
              n = i.a.extend(n, {
                "font-bold": document.queryCommandState("bold") ? "bold" : "normal",
                "font-italic": document.queryCommandState("italic") ? "italic" : "normal",
                "font-underline": document.queryCommandState("underline") ? "underline" : "normal",
                "font-subscript": document.queryCommandState("subscript") ? "subscript" : "normal",
                "font-superscript": document.queryCommandState("superscript") ? "superscript" : "normal",
                "font-strikethrough": document.queryCommandState("strikethrough") ? "strikethrough" : "normal",
                "font-family": document.queryCommandValue("fontname") || n["font-family"]
              });
            } catch (t) {}

            if (t.isOnList()) {
              var o = ["circle", "disc", "disc-leading-zero", "square"].indexOf(n["list-style-type"]) > -1;
              n["list-style"] = o ? "unordered" : "ordered";
            } else n["list-style"] = "none";

            var r = pt.ancestor(t.sc, pt.isPara);
            if (r && r.style["line-height"]) n["line-height"] = r.style.lineHeight;else {
              var a = parseInt(n["line-height"], 10) / parseInt(n["font-size"], 10);
              n["line-height"] = a.toFixed(1);
            }
            return n.anchor = t.isOnAnchor() && pt.ancestor(t.sc, pt.isAnchor), n.ancestors = pt.listAncestor(t.sc, pt.isEditable), n.range = t, n;
          }
        }]) && Et(e.prototype, n), o && Et(e, o), t;
      }();

      function $t(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Nt = function () {
        function t() {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "insertOrderedList",
          value: function value(t) {
            this.toggleList("OL", t);
          }
        }, {
          key: "insertUnorderedList",
          value: function value(t) {
            this.toggleList("UL", t);
          }
        }, {
          key: "indent",
          value: function value(t) {
            var e = this,
                n = wt.create(t).wrapBodyInlineWithPara(),
                o = n.nodes(pt.isPara, {
              includeAncestor: !0
            }),
                r = C.clusterBy(o, g.peq2("parentNode"));
            i.a.each(r, function (t, n) {
              var o = C.head(n);

              if (pt.isLi(o)) {
                var r = e.findList(o.previousSibling);
                r ? n.map(function (t) {
                  return r.appendChild(t);
                }) : (e.wrapList(n, o.parentNode.nodeName), n.map(function (t) {
                  return t.parentNode;
                }).map(function (t) {
                  return e.appendToPrevious(t);
                }));
              } else i.a.each(n, function (t, e) {
                i()(e).css("marginLeft", function (t, e) {
                  return (parseInt(e, 10) || 0) + 25;
                });
              });
            }), n.select();
          }
        }, {
          key: "outdent",
          value: function value(t) {
            var e = this,
                n = wt.create(t).wrapBodyInlineWithPara(),
                o = n.nodes(pt.isPara, {
              includeAncestor: !0
            }),
                r = C.clusterBy(o, g.peq2("parentNode"));
            i.a.each(r, function (t, n) {
              var o = C.head(n);
              pt.isLi(o) ? e.releaseList([n]) : i.a.each(n, function (t, e) {
                i()(e).css("marginLeft", function (t, e) {
                  return (e = parseInt(e, 10) || 0) > 25 ? e - 25 : "";
                });
              });
            }), n.select();
          }
        }, {
          key: "toggleList",
          value: function value(t, e) {
            var n = this,
                o = wt.create(e).wrapBodyInlineWithPara(),
                r = o.nodes(pt.isPara, {
              includeAncestor: !0
            }),
                a = o.paraBookmark(r),
                s = C.clusterBy(r, g.peq2("parentNode"));

            if (C.find(r, pt.isPurePara)) {
              var l = [];
              i.a.each(s, function (e, o) {
                l = l.concat(n.wrapList(o, t));
              }), r = l;
            } else {
              var c = o.nodes(pt.isList, {
                includeAncestor: !0
              }).filter(function (e) {
                return !i.a.nodeName(e, t);
              });
              c.length ? i.a.each(c, function (e, n) {
                pt.replace(n, t);
              }) : r = this.releaseList(s, !0);
            }

            wt.createFromParaBookmark(a, r).select();
          }
        }, {
          key: "wrapList",
          value: function value(t, e) {
            var n = C.head(t),
                o = C.last(t),
                i = pt.isList(n.previousSibling) && n.previousSibling,
                r = pt.isList(o.nextSibling) && o.nextSibling,
                a = i || pt.insertAfter(pt.create(e || "UL"), o);
            return t = t.map(function (t) {
              return pt.isPurePara(t) ? pt.replace(t, "LI") : t;
            }), pt.appendChildNodes(a, t), r && (pt.appendChildNodes(a, C.from(r.childNodes)), pt.remove(r)), t;
          }
        }, {
          key: "releaseList",
          value: function value(t, e) {
            var n = this,
                o = [];
            return i.a.each(t, function (t, r) {
              var a = C.head(r),
                  s = C.last(r),
                  l = e ? pt.lastAncestor(a, pt.isList) : a.parentNode,
                  c = l.parentNode;
              if ("LI" === l.parentNode.nodeName) r.map(function (t) {
                var e = n.findNextSiblings(t);
                c.nextSibling ? c.parentNode.insertBefore(t, c.nextSibling) : c.parentNode.appendChild(t), e.length && (n.wrapList(e, l.nodeName), t.appendChild(e[0].parentNode));
              }), 0 === l.children.length && c.removeChild(l), 0 === c.childNodes.length && c.parentNode.removeChild(c);else {
                var u = l.childNodes.length > 1 ? pt.splitTree(l, {
                  node: s.parentNode,
                  offset: pt.position(s) + 1
                }, {
                  isSkipPaddingBlankHTML: !0
                }) : null,
                    d = pt.splitTree(l, {
                  node: a.parentNode,
                  offset: pt.position(a)
                }, {
                  isSkipPaddingBlankHTML: !0
                });
                r = e ? pt.listDescendant(d, pt.isLi) : C.from(d.childNodes).filter(pt.isLi), !e && pt.isList(l.parentNode) || (r = r.map(function (t) {
                  return pt.replace(t, "P");
                })), i.a.each(C.from(r).reverse(), function (t, e) {
                  pt.insertAfter(e, l);
                });
                var h = C.compact([l, d, u]);
                i.a.each(h, function (t, e) {
                  var n = [e].concat(pt.listDescendant(e, pt.isList));
                  i.a.each(n.reverse(), function (t, e) {
                    pt.nodeLength(e) || pt.remove(e, !0);
                  });
                });
              }
              o = o.concat(r);
            }), o;
          }
        }, {
          key: "appendToPrevious",
          value: function value(t) {
            return t.previousSibling ? pt.appendChildNodes(t.previousSibling, [t]) : this.wrapList([t], "LI");
          }
        }, {
          key: "findList",
          value: function value(t) {
            return t ? C.find(t.children, function (t) {
              return ["OL", "UL"].indexOf(t.nodeName) > -1;
            }) : null;
          }
        }, {
          key: "findNextSiblings",
          value: function value(t) {
            for (var e = []; t.nextSibling;) {
              e.push(t.nextSibling), t = t.nextSibling;
            }

            return e;
          }
        }]) && $t(e.prototype, n), o && $t(e, o), t;
      }();

      function Pt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Rt = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.bullet = new Nt(), this.options = e.options;
        }

        var e, n, o;
        return e = t, (n = [{
          key: "insertTab",
          value: function value(t, e) {
            var n = pt.createText(new Array(e + 1).join(pt.NBSP_CHAR));
            (t = t.deleteContents()).insertNode(n, !0), (t = wt.create(n, e)).select();
          }
        }, {
          key: "insertParagraph",
          value: function value(t, e) {
            e = (e = (e = e || wt.create(t)).deleteContents()).wrapBodyInlineWithPara();
            var n,
                o = pt.ancestor(e.sc, pt.isPara);

            if (o) {
              if (pt.isLi(o) && (pt.isEmpty(o) || pt.deepestChildIsEmpty(o))) return void this.bullet.toggleList(o.parentNode.nodeName);
              var r = null;

              if (1 === this.options.blockquoteBreakingLevel ? r = pt.ancestor(o, pt.isBlockquote) : 2 === this.options.blockquoteBreakingLevel && (r = pt.lastAncestor(o, pt.isBlockquote)), r) {
                n = i()(pt.emptyPara)[0], pt.isRightEdgePoint(e.getStartPoint()) && pt.isBR(e.sc.nextSibling) && i()(e.sc.nextSibling).remove();
                var a = pt.splitTree(r, e.getStartPoint(), {
                  isDiscardEmptySplits: !0
                });
                a ? a.parentNode.insertBefore(n, a) : pt.insertAfter(n, r);
              } else {
                n = pt.splitTree(o, e.getStartPoint());
                var s = pt.listDescendant(o, pt.isEmptyAnchor);
                s = s.concat(pt.listDescendant(n, pt.isEmptyAnchor)), i.a.each(s, function (t, e) {
                  pt.remove(e);
                }), (pt.isHeading(n) || pt.isPre(n) || pt.isCustomStyleTag(n)) && pt.isEmpty(n) && (n = pt.replace(n, "p"));
              }
            } else {
              var l = e.sc.childNodes[e.so];
              n = i()(pt.emptyPara)[0], l ? e.sc.insertBefore(n, l) : e.sc.appendChild(n);
            }

            wt.create(n, 0).normalize().select().scrollIntoView(t);
          }
        }]) && Pt(e.prototype, n), o && Pt(e, o), t;
      }();

      function Lt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var At = function t(e, n, o, i) {
        var r = {
          colPos: 0,
          rowPos: 0
        },
            a = [],
            s = [];

        function l(t, e, n, o, i, r, s) {
          var l = {
            baseRow: n,
            baseCell: o,
            isRowSpan: i,
            isColSpan: r,
            isVirtual: s
          };
          a[t] || (a[t] = []), a[t][e] = l;
        }

        function c(t, e, n, o) {
          return {
            baseCell: t.baseCell,
            action: e,
            virtualTable: {
              rowIndex: n,
              cellIndex: o
            }
          };
        }

        function u(t, e) {
          if (!a[t]) return e;
          if (!a[t][e]) return e;

          for (var n = e; a[t][n];) {
            if (n++, !a[t][n]) return n;
          }
        }

        function d(t, e) {
          var n = u(t.rowIndex, e.cellIndex),
              o = e.colSpan > 1,
              i = e.rowSpan > 1,
              a = t.rowIndex === r.rowPos && e.cellIndex === r.colPos;
          l(t.rowIndex, n, t, e, i, o, !1);
          var s = e.attributes.rowSpan ? parseInt(e.attributes.rowSpan.value, 10) : 0;
          if (s > 1) for (var c = 1; c < s; c++) {
            var d = t.rowIndex + c;
            h(d, n, e, a), l(d, n, t, e, !0, o, !0);
          }
          var f = e.attributes.colSpan ? parseInt(e.attributes.colSpan.value, 10) : 0;
          if (f > 1) for (var p = 1; p < f; p++) {
            var m = u(t.rowIndex, n + p);
            h(t.rowIndex, m, e, a), l(t.rowIndex, m, t, e, i, !0, !0);
          }
        }

        function h(t, e, n, o) {
          t === r.rowPos && r.colPos >= n.cellIndex && n.cellIndex <= e && !o && r.colPos++;
        }

        function f(e) {
          switch (n) {
            case t.where.Column:
              if (e.isColSpan) return t.resultAction.SubtractSpanCount;
              break;

            case t.where.Row:
              if (!e.isVirtual && e.isRowSpan) return t.resultAction.AddCell;
              if (e.isRowSpan) return t.resultAction.SubtractSpanCount;
          }

          return t.resultAction.RemoveCell;
        }

        function p(e) {
          switch (n) {
            case t.where.Column:
              if (e.isColSpan) return t.resultAction.SumSpanCount;
              if (e.isRowSpan && e.isVirtual) return t.resultAction.Ignore;
              break;

            case t.where.Row:
              if (e.isRowSpan) return t.resultAction.SumSpanCount;
              if (e.isColSpan && e.isVirtual) return t.resultAction.Ignore;
          }

          return t.resultAction.AddCell;
        }

        this.getActionList = function () {
          for (var e = n === t.where.Row ? r.rowPos : -1, i = n === t.where.Column ? r.colPos : -1, l = 0, u = !0; u;) {
            var d = e >= 0 ? e : l,
                h = i >= 0 ? i : l,
                m = a[d];
            if (!m) return u = !1, s;
            var v = m[h];
            if (!v) return u = !1, s;
            var g = t.resultAction.Ignore;

            switch (o) {
              case t.requestAction.Add:
                g = p(v);
                break;

              case t.requestAction.Delete:
                g = f(v);
            }

            s.push(c(v, g, d, h)), l++;
          }

          return s;
        }, e && e.tagName && ("td" === e.tagName.toLowerCase() || "th" === e.tagName.toLowerCase()) && (r.colPos = e.cellIndex, e.parentElement && e.parentElement.tagName && "tr" === e.parentElement.tagName.toLowerCase() && (r.rowPos = e.parentElement.rowIndex)), function () {
          for (var t = i.rows, e = 0; e < t.length; e++) {
            for (var n = t[e].cells, o = 0; o < n.length; o++) {
              d(t[e], n[o]);
            }
          }
        }();
      };

      At.where = {
        Row: 0,
        Column: 1
      }, At.requestAction = {
        Add: 0,
        Delete: 1
      }, At.resultAction = {
        Ignore: 0,
        SubtractSpanCount: 1,
        RemoveCell: 2,
        AddCell: 3,
        SumSpanCount: 4
      };

      var Ft = function () {
        function t() {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "tab",
          value: function value(t, e) {
            var n = pt.ancestor(t.commonAncestor(), pt.isCell),
                o = pt.ancestor(n, pt.isTable),
                i = pt.listDescendant(o, pt.isCell),
                r = C[e ? "prev" : "next"](i, n);
            r && wt.create(r, 0).select();
          }
        }, {
          key: "addRow",
          value: function value(t, e) {
            for (var n = pt.ancestor(t.commonAncestor(), pt.isCell), o = i()(n).closest("tr"), r = this.recoverAttributes(o), a = i()("<tr" + r + "></tr>"), s = new At(n, At.where.Row, At.requestAction.Add, i()(o).closest("table")[0]).getActionList(), l = 0; l < s.length; l++) {
              var c = s[l],
                  u = this.recoverAttributes(c.baseCell);

              switch (c.action) {
                case At.resultAction.AddCell:
                  a.append("<td" + u + ">" + pt.blank + "</td>");
                  break;

                case At.resultAction.SumSpanCount:
                  if ("top" === e && (c.baseCell.parent ? c.baseCell.closest("tr").rowIndex : 0) <= o[0].rowIndex) {
                    var d = i()("<div></div>").append(i()("<td" + u + ">" + pt.blank + "</td>").removeAttr("rowspan")).html();
                    a.append(d);
                    break;
                  }

                  var h = parseInt(c.baseCell.rowSpan, 10);
                  h++, c.baseCell.setAttribute("rowSpan", h);
              }
            }

            if ("top" === e) o.before(a);else {
              if (n.rowSpan > 1) {
                var f = o[0].rowIndex + (n.rowSpan - 2);
                return void i()(i()(o).parent().find("tr")[f]).after(i()(a));
              }

              o.after(a);
            }
          }
        }, {
          key: "addCol",
          value: function value(t, e) {
            var n = pt.ancestor(t.commonAncestor(), pt.isCell),
                o = i()(n).closest("tr");
            i()(o).siblings().push(o);

            for (var r = new At(n, At.where.Column, At.requestAction.Add, i()(o).closest("table")[0]).getActionList(), a = 0; a < r.length; a++) {
              var s = r[a],
                  l = this.recoverAttributes(s.baseCell);

              switch (s.action) {
                case At.resultAction.AddCell:
                  "right" === e ? i()(s.baseCell).after("<td" + l + ">" + pt.blank + "</td>") : i()(s.baseCell).before("<td" + l + ">" + pt.blank + "</td>");
                  break;

                case At.resultAction.SumSpanCount:
                  if ("right" === e) {
                    var c = parseInt(s.baseCell.colSpan, 10);
                    c++, s.baseCell.setAttribute("colSpan", c);
                  } else i()(s.baseCell).before("<td" + l + ">" + pt.blank + "</td>");

              }
            }
          }
        }, {
          key: "recoverAttributes",
          value: function value(t) {
            var e = "";
            if (!t) return e;

            for (var n = t.attributes || [], o = 0; o < n.length; o++) {
              "id" !== n[o].name.toLowerCase() && n[o].specified && (e += " " + n[o].name + "='" + n[o].value + "'");
            }

            return e;
          }
        }, {
          key: "deleteRow",
          value: function value(t) {
            for (var e = pt.ancestor(t.commonAncestor(), pt.isCell), n = i()(e).closest("tr"), o = n.children("td, th").index(i()(e)), r = n[0].rowIndex, a = new At(e, At.where.Row, At.requestAction.Delete, i()(n).closest("table")[0]).getActionList(), s = 0; s < a.length; s++) {
              if (a[s]) {
                var l = a[s].baseCell,
                    c = a[s].virtualTable,
                    u = l.rowSpan && l.rowSpan > 1,
                    d = u ? parseInt(l.rowSpan, 10) : 0;

                switch (a[s].action) {
                  case At.resultAction.Ignore:
                    continue;

                  case At.resultAction.AddCell:
                    var h = n.next("tr")[0];
                    if (!h) continue;
                    var f = n[0].cells[o];
                    u && (d > 2 ? (d--, h.insertBefore(f, h.cells[o]), h.cells[o].setAttribute("rowSpan", d), h.cells[o].innerHTML = "") : 2 === d && (h.insertBefore(f, h.cells[o]), h.cells[o].removeAttribute("rowSpan"), h.cells[o].innerHTML = ""));
                    continue;

                  case At.resultAction.SubtractSpanCount:
                    u && (d > 2 ? (d--, l.setAttribute("rowSpan", d), c.rowIndex !== r && l.cellIndex === o && (l.innerHTML = "")) : 2 === d && (l.removeAttribute("rowSpan"), c.rowIndex !== r && l.cellIndex === o && (l.innerHTML = "")));
                    continue;

                  case At.resultAction.RemoveCell:
                    continue;
                }
              }
            }

            n.remove();
          }
        }, {
          key: "deleteCol",
          value: function value(t) {
            for (var e = pt.ancestor(t.commonAncestor(), pt.isCell), n = i()(e).closest("tr"), o = n.children("td, th").index(i()(e)), r = new At(e, At.where.Column, At.requestAction.Delete, i()(n).closest("table")[0]).getActionList(), a = 0; a < r.length; a++) {
              if (r[a]) switch (r[a].action) {
                case At.resultAction.Ignore:
                  continue;

                case At.resultAction.SubtractSpanCount:
                  var s = r[a].baseCell;

                  if (s.colSpan && s.colSpan > 1) {
                    var l = s.colSpan ? parseInt(s.colSpan, 10) : 0;
                    l > 2 ? (l--, s.setAttribute("colSpan", l), s.cellIndex === o && (s.innerHTML = "")) : 2 === l && (s.removeAttribute("colSpan"), s.cellIndex === o && (s.innerHTML = ""));
                  }

                  continue;

                case At.resultAction.RemoveCell:
                  pt.remove(r[a].baseCell, !0);
                  continue;
              }
            }
          }
        }, {
          key: "createTable",
          value: function value(t, e, n) {
            for (var o, r = [], a = 0; a < t; a++) {
              r.push("<td>" + pt.blank + "</td>");
            }

            o = r.join("");

            for (var s, l = [], c = 0; c < e; c++) {
              l.push("<tr>" + o + "</tr>");
            }

            s = l.join("");
            var u = i()("<table>" + s + "</table>");
            return n && n.tableClassName && u.addClass(n.tableClassName), u[0];
          }
        }, {
          key: "deleteTable",
          value: function value(t) {
            var e = pt.ancestor(t.commonAncestor(), pt.isCell);
            i()(e).closest("table").remove();
          }
        }]) && Lt(e.prototype, n), o && Lt(e, o), t;
      }();

      function Dt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Ht = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$note = e.layoutInfo.note, this.$editor = e.layoutInfo.editor, this.$editable = e.layoutInfo.editable, this.options = e.options, this.lang = this.options.langInfo, this.editable = this.$editable[0], this.lastRange = null, this.snapshot = null, this.style = new It(), this.table = new Ft(), this.typing = new Rt(e), this.bullet = new Nt(), this.history = new Tt(e), this.context.memo("help.escape", this.lang.help.escape), this.context.memo("help.undo", this.lang.help.undo), this.context.memo("help.redo", this.lang.help.redo), this.context.memo("help.tab", this.lang.help.tab), this.context.memo("help.untab", this.lang.help.untab), this.context.memo("help.insertParagraph", this.lang.help.insertParagraph), this.context.memo("help.insertOrderedList", this.lang.help.insertOrderedList), this.context.memo("help.insertUnorderedList", this.lang.help.insertUnorderedList), this.context.memo("help.indent", this.lang.help.indent), this.context.memo("help.outdent", this.lang.help.outdent), this.context.memo("help.formatPara", this.lang.help.formatPara), this.context.memo("help.insertHorizontalRule", this.lang.help.insertHorizontalRule), this.context.memo("help.fontName", this.lang.help.fontName);

          for (var o = ["bold", "italic", "underline", "strikethrough", "superscript", "subscript", "justifyLeft", "justifyCenter", "justifyRight", "justifyFull", "formatBlock", "removeFormat", "backColor"], r = 0, a = o.length; r < a; r++) {
            this[o[r]] = function (t) {
              return function (e) {
                n.beforeCommand(), document.execCommand(t, !1, e), n.afterCommand(!0);
              };
            }(o[r]), this.context.memo("help." + o[r], this.lang.help[o[r]]);
          }

          this.fontName = this.wrapCommand(function (t) {
            return n.fontStyling("font-family", m.validFontName(t));
          }), this.fontSize = this.wrapCommand(function (t) {
            var e = n.currentStyle()["font-size-unit"];
            return n.fontStyling("font-size", t + e);
          }), this.fontSizeUnit = this.wrapCommand(function (t) {
            var e = n.currentStyle()["font-size"];
            return n.fontStyling("font-size", e + t);
          });

          for (var s = 1; s <= 6; s++) {
            this["formatH" + s] = function (t) {
              return function () {
                n.formatBlock("H" + t);
              };
            }(s), this.context.memo("help.formatH" + s, this.lang.help["formatH" + s]);
          }

          this.insertParagraph = this.wrapCommand(function () {
            n.typing.insertParagraph(n.editable);
          }), this.insertOrderedList = this.wrapCommand(function () {
            n.bullet.insertOrderedList(n.editable);
          }), this.insertUnorderedList = this.wrapCommand(function () {
            n.bullet.insertUnorderedList(n.editable);
          }), this.indent = this.wrapCommand(function () {
            n.bullet.indent(n.editable);
          }), this.outdent = this.wrapCommand(function () {
            n.bullet.outdent(n.editable);
          }), this.insertNode = this.wrapCommand(function (t) {
            n.isLimited(i()(t).text().length) || (n.getLastRange().insertNode(t), n.setLastRange(wt.createFromNodeAfter(t).select()));
          }), this.insertText = this.wrapCommand(function (t) {
            if (!n.isLimited(t.length)) {
              var e = n.getLastRange().insertNode(pt.createText(t));
              n.setLastRange(wt.create(e, pt.nodeLength(e)).select());
            }
          }), this.pasteHTML = this.wrapCommand(function (t) {
            if (!n.isLimited(t.length)) {
              t = n.context.invoke("codeview.purify", t);
              var e = n.getLastRange().pasteHTML(t);
              n.setLastRange(wt.createFromNodeAfter(C.last(e)).select());
            }
          }), this.formatBlock = this.wrapCommand(function (t, e) {
            var o = n.options.callbacks.onApplyCustomStyle;
            o ? o.call(n, e, n.context, n.onFormatBlock) : n.onFormatBlock(t, e);
          }), this.insertHorizontalRule = this.wrapCommand(function () {
            var t = n.getLastRange().insertNode(pt.create("HR"));
            t.nextSibling && n.setLastRange(wt.create(t.nextSibling, 0).normalize().select());
          }), this.lineHeight = this.wrapCommand(function (t) {
            n.style.stylePara(n.getLastRange(), {
              lineHeight: t
            });
          }), this.createLink = this.wrapCommand(function (t) {
            var e = t.url,
                o = t.text,
                r = t.isNewWindow,
                a = t.checkProtocol,
                s = t.range || n.getLastRange(),
                l = o.length - s.toString().length;

            if (!(l > 0 && n.isLimited(l))) {
              var c = s.toString() !== o;
              "string" == typeof e && (e = e.trim()), n.options.onCreateLink ? e = n.options.onCreateLink(e) : a && (e = /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/.test(e) ? e : n.options.defaultProtocol + e);
              var u = [];

              if (c) {
                var d = (s = s.deleteContents()).insertNode(i()("<A>" + o + "</A>")[0]);
                u.push(d);
              } else u = n.style.styleNodes(s, {
                nodeName: "A",
                expandClosestSibling: !0,
                onlyPartialContains: !0
              });

              i.a.each(u, function (t, n) {
                i()(n).attr("href", e), r ? i()(n).attr("target", "_blank") : i()(n).removeAttr("target");
              }), n.setLastRange(n.createRangeFromList(u).select());
            }
          }), this.color = this.wrapCommand(function (t) {
            var e = t.foreColor,
                n = t.backColor;
            e && document.execCommand("foreColor", !1, e), n && document.execCommand("backColor", !1, n);
          }), this.foreColor = this.wrapCommand(function (t) {
            document.execCommand("foreColor", !1, t);
          }), this.insertTable = this.wrapCommand(function (t) {
            var e = t.split("x");
            n.getLastRange().deleteContents().insertNode(n.table.createTable(e[0], e[1], n.options));
          }), this.removeMedia = this.wrapCommand(function () {
            var t = i()(n.restoreTarget()).parent();
            t.closest("figure").length ? t.closest("figure").remove() : t = i()(n.restoreTarget()).detach(), n.context.triggerEvent("media.delete", t, n.$editable);
          }), this.floatMe = this.wrapCommand(function (t) {
            var e = i()(n.restoreTarget());
            e.toggleClass("note-float-left", "left" === t), e.toggleClass("note-float-right", "right" === t), e.css("float", "none" === t ? "" : t);
          }), this.resize = this.wrapCommand(function (t) {
            var e = i()(n.restoreTarget());
            0 === (t = parseFloat(t)) ? e.css("width", "") : e.css({
              width: 100 * t + "%",
              height: ""
            });
          });
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            var t = this;
            this.$editable.on("keydown", function (e) {
              if (e.keyCode === xt.code.ENTER && t.context.triggerEvent("enter", e), t.context.triggerEvent("keydown", e), t.snapshot = t.history.makeSnapshot(), t.hasKeyShortCut = !1, e.isDefaultPrevented() || (t.options.shortcuts ? t.hasKeyShortCut = t.handleKeyMap(e) : t.preventDefaultEditableShortCuts(e)), t.isLimited(1, e)) {
                var n = t.getLastRange();
                if (n.eo - n.so == 0) return !1;
              }

              t.setLastRange(), t.options.recordEveryKeystroke && !1 === t.hasKeyShortCut && t.history.recordUndo();
            }).on("keyup", function (e) {
              t.setLastRange(), t.context.triggerEvent("keyup", e);
            }).on("focus", function (e) {
              t.setLastRange(), t.context.triggerEvent("focus", e);
            }).on("blur", function (e) {
              t.context.triggerEvent("blur", e);
            }).on("mousedown", function (e) {
              t.context.triggerEvent("mousedown", e);
            }).on("mouseup", function (e) {
              t.setLastRange(), t.history.recordUndo(), t.context.triggerEvent("mouseup", e);
            }).on("scroll", function (e) {
              t.context.triggerEvent("scroll", e);
            }).on("paste", function (e) {
              t.setLastRange(), t.context.triggerEvent("paste", e);
            }).on("input", function () {
              t.isLimited(0) && t.snapshot && t.history.applySnapshot(t.snapshot);
            }), this.$editable.attr("spellcheck", this.options.spellCheck), this.$editable.attr("autocorrect", this.options.spellCheck), this.options.disableGrammar && this.$editable.attr("data-gramm", !1), this.$editable.html(pt.html(this.$note) || pt.emptyPara), this.$editable.on(m.inputEventName, g.debounce(function () {
              t.context.triggerEvent("change", t.$editable.html(), t.$editable);
            }, 10)), this.$editable.on("focusin", function (e) {
              t.context.triggerEvent("focusin", e);
            }).on("focusout", function (e) {
              t.context.triggerEvent("focusout", e);
            }), this.options.airMode ? this.options.overrideContextMenu && this.$editor.on("contextmenu", function (e) {
              return t.context.triggerEvent("contextmenu", e), !1;
            }) : (this.options.width && this.$editor.outerWidth(this.options.width), this.options.height && this.$editable.outerHeight(this.options.height), this.options.maxHeight && this.$editable.css("max-height", this.options.maxHeight), this.options.minHeight && this.$editable.css("min-height", this.options.minHeight)), this.history.recordUndo(), this.setLastRange();
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$editable.off();
          }
        }, {
          key: "handleKeyMap",
          value: function value(t) {
            var e = this.options.keyMap[m.isMac ? "mac" : "pc"],
                n = [];
            t.metaKey && n.push("CMD"), t.ctrlKey && !t.altKey && n.push("CTRL"), t.shiftKey && n.push("SHIFT");
            var o = xt.nameFromCode[t.keyCode];
            o && n.push(o);
            var i = e[n.join("+")];
            if ("TAB" !== o || this.options.tabDisable) {
              if (i) {
                if (!1 !== this.context.invoke(i)) return t.preventDefault(), !0;
              } else xt.isEdit(t.keyCode) && this.afterCommand();
            } else this.afterCommand();
            return !1;
          }
        }, {
          key: "preventDefaultEditableShortCuts",
          value: function value(t) {
            (t.ctrlKey || t.metaKey) && C.contains([66, 73, 85], t.keyCode) && t.preventDefault();
          }
        }, {
          key: "isLimited",
          value: function value(t, e) {
            return t = t || 0, (void 0 === e || !(xt.isMove(e.keyCode) || xt.isNavigation(e.keyCode) || e.ctrlKey || e.metaKey || C.contains([xt.code.BACKSPACE, xt.code.DELETE], e.keyCode))) && this.options.maxTextLength > 0 && this.$editable.text().length + t > this.options.maxTextLength;
          }
        }, {
          key: "createRange",
          value: function value() {
            return this.focus(), this.setLastRange(), this.getLastRange();
          }
        }, {
          key: "createRangeFromList",
          value: function value(t) {
            var e = wt.createFromNodeBefore(C.head(t)).getStartPoint(),
                n = wt.createFromNodeAfter(C.last(t)).getEndPoint();
            return wt.create(e.node, e.offset, n.node, n.offset);
          }
        }, {
          key: "setLastRange",
          value: function value(t) {
            t ? this.lastRange = t : (this.lastRange = wt.create(this.editable), 0 === i()(this.lastRange.sc).closest(".note-editable").length && (this.lastRange = wt.createFromBodyElement(this.editable)));
          }
        }, {
          key: "getLastRange",
          value: function value() {
            return this.lastRange || this.setLastRange(), this.lastRange;
          }
        }, {
          key: "saveRange",
          value: function value(t) {
            t && this.getLastRange().collapse().select();
          }
        }, {
          key: "restoreRange",
          value: function value() {
            this.lastRange && (this.lastRange.select(), this.focus());
          }
        }, {
          key: "saveTarget",
          value: function value(t) {
            this.$editable.data("target", t);
          }
        }, {
          key: "clearTarget",
          value: function value() {
            this.$editable.removeData("target");
          }
        }, {
          key: "restoreTarget",
          value: function value() {
            return this.$editable.data("target");
          }
        }, {
          key: "currentStyle",
          value: function value() {
            var t = wt.create();
            return t && (t = t.normalize()), t ? this.style.current(t) : this.style.fromNode(this.$editable);
          }
        }, {
          key: "styleFromNode",
          value: function value(t) {
            return this.style.fromNode(t);
          }
        }, {
          key: "undo",
          value: function value() {
            this.context.triggerEvent("before.command", this.$editable.html()), this.history.undo(), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
          }
        }, {
          key: "commit",
          value: function value() {
            this.context.triggerEvent("before.command", this.$editable.html()), this.history.commit(), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
          }
        }, {
          key: "redo",
          value: function value() {
            this.context.triggerEvent("before.command", this.$editable.html()), this.history.redo(), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
          }
        }, {
          key: "beforeCommand",
          value: function value() {
            this.context.triggerEvent("before.command", this.$editable.html()), document.execCommand("styleWithCSS", !1, this.options.styleWithCSS), this.focus();
          }
        }, {
          key: "afterCommand",
          value: function value(t) {
            this.normalizeContent(), this.history.recordUndo(), t || this.context.triggerEvent("change", this.$editable.html(), this.$editable);
          }
        }, {
          key: "tab",
          value: function value() {
            var t = this.getLastRange();
            if (t.isCollapsed() && t.isOnCell()) this.table.tab(t);else {
              if (0 === this.options.tabSize) return !1;
              this.isLimited(this.options.tabSize) || (this.beforeCommand(), this.typing.insertTab(t, this.options.tabSize), this.afterCommand());
            }
          }
        }, {
          key: "untab",
          value: function value() {
            var t = this.getLastRange();
            if (t.isCollapsed() && t.isOnCell()) this.table.tab(t, !0);else if (0 === this.options.tabSize) return !1;
          }
        }, {
          key: "wrapCommand",
          value: function value(t) {
            return function () {
              this.beforeCommand(), t.apply(this, arguments), this.afterCommand();
            };
          }
        }, {
          key: "insertImage",
          value: function value(t, e) {
            var n,
                o = this;
            return (n = t, i.a.Deferred(function (t) {
              var e = i()("<img>");
              e.one("load", function () {
                e.off("error abort"), t.resolve(e);
              }).one("error abort", function () {
                e.off("load").detach(), t.reject(e);
              }).css({
                display: "none"
              }).appendTo(document.body).attr("src", n);
            }).promise()).then(function (t) {
              o.beforeCommand(), "function" == typeof e ? e(t) : ("string" == typeof e && t.attr("data-filename", e), t.css("width", Math.min(o.$editable.width(), t.width()))), t.show(), o.getLastRange().insertNode(t[0]), o.setLastRange(wt.createFromNodeAfter(t[0]).select()), o.afterCommand();
            }).fail(function (t) {
              o.context.triggerEvent("image.upload.error", t);
            });
          }
        }, {
          key: "insertImagesAsDataURL",
          value: function value(t) {
            var e = this;
            i.a.each(t, function (t, n) {
              var o = n.name;
              e.options.maximumImageFileSize && e.options.maximumImageFileSize < n.size ? e.context.triggerEvent("image.upload.error", e.lang.image.maximumFileSizeError) : function (t) {
                return i.a.Deferred(function (e) {
                  i.a.extend(new FileReader(), {
                    onload: function onload(t) {
                      var n = t.target.result;
                      e.resolve(n);
                    },
                    onerror: function onerror(t) {
                      e.reject(t);
                    }
                  }).readAsDataURL(t);
                }).promise();
              }(n).then(function (t) {
                return e.insertImage(t, o);
              }).fail(function () {
                e.context.triggerEvent("image.upload.error");
              });
            });
          }
        }, {
          key: "insertImagesOrCallback",
          value: function value(t) {
            this.options.callbacks.onImageUpload ? this.context.triggerEvent("image.upload", t) : this.insertImagesAsDataURL(t);
          }
        }, {
          key: "getSelectedText",
          value: function value() {
            var t = this.getLastRange();
            return t.isOnAnchor() && (t = wt.createFromNode(pt.ancestor(t.sc, pt.isAnchor))), t.toString();
          }
        }, {
          key: "onFormatBlock",
          value: function value(t, e) {
            if (document.execCommand("FormatBlock", !1, m.isMSIE ? "<" + t + ">" : t), e && e.length && (e[0].tagName.toUpperCase() !== t.toUpperCase() && (e = e.find(t)), e && e.length)) {
              var n = e[0].className || "";

              if (n) {
                var o = this.createRange();
                i()([o.sc, o.ec]).closest(t).addClass(n);
              }
            }
          }
        }, {
          key: "formatPara",
          value: function value() {
            this.formatBlock("P");
          }
        }, {
          key: "fontStyling",
          value: function value(t, e) {
            var n = this.getLastRange();

            if ("" !== n) {
              var o = this.style.styleNodes(n);

              if (this.$editor.find(".note-status-output").html(""), i()(o).css(t, e), n.isCollapsed()) {
                var r = C.head(o);
                r && !pt.nodeLength(r) && (r.innerHTML = pt.ZERO_WIDTH_NBSP_CHAR, wt.createFromNode(r.firstChild).select(), this.setLastRange(), this.$editable.data("bogus", r));
              } else this.setLastRange(this.createRangeFromList(o).select());
            } else {
              var a = i.a.now();
              this.$editor.find(".note-status-output").html('<div id="note-status-output-' + a + '" class="alert alert-info">' + this.lang.output.noSelection + "</div>"), setTimeout(function () {
                i()("#note-status-output-" + a).remove();
              }, 5e3);
            }
          }
        }, {
          key: "unlink",
          value: function value() {
            var t = this.getLastRange();

            if (t.isOnAnchor()) {
              var e = pt.ancestor(t.sc, pt.isAnchor);
              (t = wt.createFromNode(e)).select(), this.setLastRange(), this.beforeCommand(), document.execCommand("unlink"), this.afterCommand();
            }
          }
        }, {
          key: "getLinkInfo",
          value: function value() {
            var t = this.getLastRange().expand(pt.isAnchor),
                e = i()(C.head(t.nodes(pt.isAnchor))),
                n = {
              range: t,
              text: t.toString(),
              url: e.length ? e.attr("href") : ""
            };
            return e.length && (n.isNewWindow = "_blank" === e.attr("target")), n;
          }
        }, {
          key: "addRow",
          value: function value(t) {
            var e = this.getLastRange(this.$editable);
            e.isCollapsed() && e.isOnCell() && (this.beforeCommand(), this.table.addRow(e, t), this.afterCommand());
          }
        }, {
          key: "addCol",
          value: function value(t) {
            var e = this.getLastRange(this.$editable);
            e.isCollapsed() && e.isOnCell() && (this.beforeCommand(), this.table.addCol(e, t), this.afterCommand());
          }
        }, {
          key: "deleteRow",
          value: function value() {
            var t = this.getLastRange(this.$editable);
            t.isCollapsed() && t.isOnCell() && (this.beforeCommand(), this.table.deleteRow(t), this.afterCommand());
          }
        }, {
          key: "deleteCol",
          value: function value() {
            var t = this.getLastRange(this.$editable);
            t.isCollapsed() && t.isOnCell() && (this.beforeCommand(), this.table.deleteCol(t), this.afterCommand());
          }
        }, {
          key: "deleteTable",
          value: function value() {
            var t = this.getLastRange(this.$editable);
            t.isCollapsed() && t.isOnCell() && (this.beforeCommand(), this.table.deleteTable(t), this.afterCommand());
          }
        }, {
          key: "resizeTo",
          value: function value(t, e, n) {
            var o;

            if (n) {
              var i = t.y / t.x,
                  r = e.data("ratio");
              o = {
                width: r > i ? t.x : t.y / r,
                height: r > i ? t.x * r : t.y
              };
            } else o = {
              width: t.x,
              height: t.y
            };

            e.css(o);
          }
        }, {
          key: "hasFocus",
          value: function value() {
            return this.$editable.is(":focus");
          }
        }, {
          key: "focus",
          value: function value() {
            this.hasFocus() || this.$editable.focus();
          }
        }, {
          key: "isEmpty",
          value: function value() {
            return pt.isEmpty(this.$editable[0]) || pt.emptyPara === this.$editable.html();
          }
        }, {
          key: "empty",
          value: function value() {
            this.context.invoke("code", pt.emptyPara);
          }
        }, {
          key: "normalizeContent",
          value: function value() {
            this.$editable[0].normalize();
          }
        }]) && Dt(e.prototype, n), o && Dt(e, o), t;
      }();

      function zt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Bt = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$editable = e.layoutInfo.editable;
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            this.$editable.on("paste", this.pasteByEvent.bind(this));
          }
        }, {
          key: "pasteByEvent",
          value: function value(t) {
            var e = this,
                n = t.originalEvent.clipboardData;

            if (n && n.items && n.items.length) {
              var o = n.items.length > 1 ? n.items[1] : C.head(n.items);
              "file" === o.kind && -1 !== o.type.indexOf("image/") ? (this.context.invoke("editor.insertImagesOrCallback", [o.getAsFile()]), t.preventDefault()) : "string" === o.kind && this.context.invoke("editor.isLimited", n.getData("Text").length) && t.preventDefault();
            } else if (window.clipboardData) {
              var i = window.clipboardData.getData("text");
              this.context.invoke("editor.isLimited", i.length) && t.preventDefault();
            }

            setTimeout(function () {
              e.context.invoke("editor.afterCommand");
            }, 10);
          }
        }]) && zt(e.prototype, n), o && zt(e, o), t;
      }();

      function Mt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Ot = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$eventListener = i()(document), this.$editor = e.layoutInfo.editor, this.$editable = e.layoutInfo.editable, this.options = e.options, this.lang = this.options.langInfo, this.documentEventHandlers = {}, this.$dropzone = i()(['<div class="note-dropzone">', '<div class="note-dropzone-message"></div>', "</div>"].join("")).prependTo(this.$editor);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            this.options.disableDragAndDrop ? (this.documentEventHandlers.onDrop = function (t) {
              t.preventDefault();
            }, this.$eventListener = this.$dropzone, this.$eventListener.on("drop", this.documentEventHandlers.onDrop)) : this.attachDragAndDropEvent();
          }
        }, {
          key: "attachDragAndDropEvent",
          value: function value() {
            var t = this,
                e = i()(),
                n = this.$dropzone.find(".note-dropzone-message");
            this.documentEventHandlers.onDragenter = function (o) {
              var i = t.context.invoke("codeview.isActivated"),
                  r = t.$editor.width() > 0 && t.$editor.height() > 0;
              i || e.length || !r || (t.$editor.addClass("dragover"), t.$dropzone.width(t.$editor.width()), t.$dropzone.height(t.$editor.height()), n.text(t.lang.image.dragImageHere)), e = e.add(o.target);
            }, this.documentEventHandlers.onDragleave = function (n) {
              (e = e.not(n.target)).length && "BODY" !== n.target.nodeName || (e = i()(), t.$editor.removeClass("dragover"));
            }, this.documentEventHandlers.onDrop = function () {
              e = i()(), t.$editor.removeClass("dragover");
            }, this.$eventListener.on("dragenter", this.documentEventHandlers.onDragenter).on("dragleave", this.documentEventHandlers.onDragleave).on("drop", this.documentEventHandlers.onDrop), this.$dropzone.on("dragenter", function () {
              t.$dropzone.addClass("hover"), n.text(t.lang.image.dropImage);
            }).on("dragleave", function () {
              t.$dropzone.removeClass("hover"), n.text(t.lang.image.dragImageHere);
            }), this.$dropzone.on("drop", function (e) {
              var n = e.originalEvent.dataTransfer;
              e.preventDefault(), n && n.files && n.files.length ? (t.$editable.focus(), t.context.invoke("editor.insertImagesOrCallback", n.files)) : i.a.each(n.types, function (e, o) {
                if (!(o.toLowerCase().indexOf("_moz_") > -1)) {
                  var r = n.getData(o);
                  o.toLowerCase().indexOf("text") > -1 ? t.context.invoke("editor.pasteHTML", r) : i()(r).each(function (e, n) {
                    t.context.invoke("editor.insertNode", n);
                  });
                }
              });
            }).on("dragover", !1);
          }
        }, {
          key: "destroy",
          value: function value() {
            var t = this;
            Object.keys(this.documentEventHandlers).forEach(function (e) {
              t.$eventListener.off(e.substr(2).toLowerCase(), t.documentEventHandlers[e]);
            }), this.documentEventHandlers = {};
          }
        }]) && Mt(e.prototype, n), o && Mt(e, o), t;
      }();

      function jt(t) {
        if ("undefined" == typeof Symbol || null == t[Symbol.iterator]) {
          if (Array.isArray(t) || (t = function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return Ut(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(n);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ut(t, e);
          }(t))) {
            var e = 0,
                n = function n() {};

            return {
              s: n,
              n: function n() {
                return e >= t.length ? {
                  done: !0
                } : {
                  done: !1,
                  value: t[e++]
                };
              },
              e: function e(t) {
                throw t;
              },
              f: n
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        var o,
            i,
            r = !0,
            a = !1;
        return {
          s: function s() {
            o = t[Symbol.iterator]();
          },
          n: function n() {
            var t = o.next();
            return r = t.done, t;
          },
          e: function e(t) {
            a = !0, i = t;
          },
          f: function f() {
            try {
              r || null == o["return"] || o["return"]();
            } finally {
              if (a) throw i;
            }
          }
        };
      }

      function Ut(t, e) {
        (null == e || e > t.length) && (e = t.length);

        for (var n = 0, o = new Array(e); n < e; n++) {
          o[n] = t[n];
        }

        return o;
      }

      function Wt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Kt = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$editor = e.layoutInfo.editor, this.$editable = e.layoutInfo.editable, this.$codable = e.layoutInfo.codable, this.options = e.options, this.CodeMirrorConstructor = window.CodeMirror, this.options.codemirror.CodeMirrorConstructor && (this.CodeMirrorConstructor = this.options.codemirror.CodeMirrorConstructor);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "sync",
          value: function value(t) {
            var e = this.isActivated(),
                n = this.CodeMirrorConstructor;
            e && (t ? n ? this.$codable.data("cmEditor").getDoc().setValue(t) : this.$codable.val(t) : n && this.$codable.data("cmEditor").save());
          }
        }, {
          key: "initialize",
          value: function value() {
            var t = this;
            this.$codable.on("keyup", function (e) {
              e.keyCode === xt.code.ESCAPE && t.deactivate();
            });
          }
        }, {
          key: "isActivated",
          value: function value() {
            return this.$editor.hasClass("codeview");
          }
        }, {
          key: "toggle",
          value: function value() {
            this.isActivated() ? this.deactivate() : this.activate(), this.context.triggerEvent("codeview.toggled");
          }
        }, {
          key: "purify",
          value: function value(t) {
            if (this.options.codeviewFilter && (t = t.replace(this.options.codeviewFilterRegex, ""), this.options.codeviewIframeFilter)) {
              var e = this.options.codeviewIframeWhitelistSrc.concat(this.options.codeviewIframeWhitelistSrcBase);
              t = t.replace(/(<iframe.*?>.*?(?:<\/iframe>)?)/gi, function (t) {
                if (/<.+src(?==?('|"|\s)?)[\s\S]+src(?=('|"|\s)?)[^>]*?>/i.test(t)) return "";
                var n,
                    o = jt(e);

                try {
                  for (o.s(); !(n = o.n()).done;) {
                    var i = n.value;
                    if (new RegExp('src="(https?:)?//' + i.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") + '/(.+)"').test(t)) return t;
                  }
                } catch (t) {
                  o.e(t);
                } finally {
                  o.f();
                }

                return "";
              });
            }

            return t;
          }
        }, {
          key: "activate",
          value: function value() {
            var t = this,
                e = this.CodeMirrorConstructor;

            if (this.$codable.val(pt.html(this.$editable, this.options.prettifyHtml)), this.$codable.height(this.$editable.height()), this.context.invoke("toolbar.updateCodeview", !0), this.context.invoke("airPopover.updateCodeview", !0), this.$editor.addClass("codeview"), this.$codable.focus(), e) {
              var n = e.fromTextArea(this.$codable[0], this.options.codemirror);

              if (this.options.codemirror.tern) {
                var o = new e.TernServer(this.options.codemirror.tern);
                n.ternServer = o, n.on("cursorActivity", function (t) {
                  o.updateArgHints(t);
                });
              }

              n.on("blur", function (e) {
                t.context.triggerEvent("blur.codeview", n.getValue(), e);
              }), n.on("change", function () {
                t.context.triggerEvent("change.codeview", n.getValue(), n);
              }), n.setSize(null, this.$editable.outerHeight()), this.$codable.data("cmEditor", n);
            } else this.$codable.on("blur", function (e) {
              t.context.triggerEvent("blur.codeview", t.$codable.val(), e);
            }), this.$codable.on("input", function () {
              t.context.triggerEvent("change.codeview", t.$codable.val(), t.$codable);
            });
          }
        }, {
          key: "deactivate",
          value: function value() {
            if (this.CodeMirrorConstructor) {
              var t = this.$codable.data("cmEditor");
              this.$codable.val(t.getValue()), t.toTextArea();
            }

            var e = this.purify(pt.value(this.$codable, this.options.prettifyHtml) || pt.emptyPara),
                n = this.$editable.html() !== e;
            this.$editable.html(e), this.$editable.height(this.options.height ? this.$codable.height() : "auto"), this.$editor.removeClass("codeview"), n && this.context.triggerEvent("change", this.$editable.html(), this.$editable), this.$editable.focus(), this.context.invoke("toolbar.updateCodeview", !1), this.context.invoke("airPopover.updateCodeview", !1);
          }
        }, {
          key: "destroy",
          value: function value() {
            this.isActivated() && this.deactivate();
          }
        }]) && Wt(e.prototype, n), o && Wt(e, o), t;
      }();

      function qt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Vt = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.$document = i()(document), this.$statusbar = e.layoutInfo.statusbar, this.$editable = e.layoutInfo.editable, this.options = e.options;
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            var t = this;
            this.options.airMode || this.options.disableResizeEditor ? this.destroy() : this.$statusbar.on("mousedown", function (e) {
              e.preventDefault(), e.stopPropagation();

              var n = t.$editable.offset().top - t.$document.scrollTop(),
                  o = function o(e) {
                var o = e.clientY - (n + 24);
                o = t.options.minheight > 0 ? Math.max(o, t.options.minheight) : o, o = t.options.maxHeight > 0 ? Math.min(o, t.options.maxHeight) : o, t.$editable.height(o);
              };

              t.$document.on("mousemove", o).one("mouseup", function () {
                t.$document.off("mousemove", o);
              });
            });
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$statusbar.off(), this.$statusbar.addClass("locked");
          }
        }]) && qt(e.prototype, n), o && qt(e, o), t;
      }();

      function _t(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Gt = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$editor = e.layoutInfo.editor, this.$toolbar = e.layoutInfo.toolbar, this.$editable = e.layoutInfo.editable, this.$codable = e.layoutInfo.codable, this.$window = i()(window), this.$scrollbar = i()("html, body"), this.onResize = function () {
            n.resizeTo({
              h: n.$window.height() - n.$toolbar.outerHeight()
            });
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "resizeTo",
          value: function value(t) {
            this.$editable.css("height", t.h), this.$codable.css("height", t.h), this.$codable.data("cmeditor") && this.$codable.data("cmeditor").setsize(null, t.h);
          }
        }, {
          key: "toggle",
          value: function value() {
            this.$editor.toggleClass("fullscreen"), this.isFullscreen() ? (this.$editable.data("orgHeight", this.$editable.css("height")), this.$editable.data("orgMaxHeight", this.$editable.css("maxHeight")), this.$editable.css("maxHeight", ""), this.$window.on("resize", this.onResize).trigger("resize"), this.$scrollbar.css("overflow", "hidden")) : (this.$window.off("resize", this.onResize), this.resizeTo({
              h: this.$editable.data("orgHeight")
            }), this.$editable.css("maxHeight", this.$editable.css("orgMaxHeight")), this.$scrollbar.css("overflow", "visible")), this.context.invoke("toolbar.updateFullscreen", this.isFullscreen());
          }
        }, {
          key: "isFullscreen",
          value: function value() {
            return this.$editor.hasClass("fullscreen");
          }
        }]) && _t(e.prototype, n), o && _t(e, o), t;
      }();

      function Yt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Zt = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$document = i()(document), this.$editingArea = e.layoutInfo.editingArea, this.options = e.options, this.lang = this.options.langInfo, this.events = {
            "summernote.mousedown": function summernoteMousedown(t, e) {
              n.update(e.target, e) && e.preventDefault();
            },
            "summernote.keyup summernote.scroll summernote.change summernote.dialog.shown": function summernoteKeyupSummernoteScrollSummernoteChangeSummernoteDialogShown() {
              n.update();
            },
            "summernote.disable summernote.blur": function summernoteDisableSummernoteBlur() {
              n.hide();
            },
            "summernote.codeview.toggled": function summernoteCodeviewToggled() {
              n.update();
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            var t = this;
            this.$handle = i()(['<div class="note-handle">', '<div class="note-control-selection">', '<div class="note-control-selection-bg"></div>', '<div class="note-control-holder note-control-nw"></div>', '<div class="note-control-holder note-control-ne"></div>', '<div class="note-control-holder note-control-sw"></div>', '<div class="', this.options.disableResizeImage ? "note-control-holder" : "note-control-sizing", ' note-control-se"></div>', this.options.disableResizeImage ? "" : '<div class="note-control-selection-info"></div>', "</div>", "</div>"].join("")).prependTo(this.$editingArea), this.$handle.on("mousedown", function (e) {
              if (pt.isControlSizing(e.target)) {
                e.preventDefault(), e.stopPropagation();

                var n = t.$handle.find(".note-control-selection").data("target"),
                    o = n.offset(),
                    i = t.$document.scrollTop(),
                    r = function r(e) {
                  t.context.invoke("editor.resizeTo", {
                    x: e.clientX - o.left,
                    y: e.clientY - (o.top - i)
                  }, n, !e.shiftKey), t.update(n[0], e);
                };

                t.$document.on("mousemove", r).one("mouseup", function (e) {
                  e.preventDefault(), t.$document.off("mousemove", r), t.context.invoke("editor.afterCommand");
                }), n.data("ratio") || n.data("ratio", n.height() / n.width());
              }
            }), this.$handle.on("wheel", function (e) {
              e.preventDefault(), t.update();
            });
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$handle.remove();
          }
        }, {
          key: "update",
          value: function value(t, e) {
            if (this.context.isDisabled()) return !1;
            var n = pt.isImg(t),
                o = this.$handle.find(".note-control-selection");

            if (this.context.invoke("imagePopover.update", t, e), n) {
              var r = i()(t),
                  a = r.position(),
                  s = {
                left: a.left + parseInt(r.css("marginLeft"), 10),
                top: a.top + parseInt(r.css("marginTop"), 10)
              },
                  l = {
                w: r.outerWidth(!1),
                h: r.outerHeight(!1)
              };
              o.css({
                display: "block",
                left: s.left,
                top: s.top,
                width: l.w,
                height: l.h
              }).data("target", r);
              var c = new Image();
              c.src = r.attr("src");
              var u = l.w + "x" + l.h + " (" + this.lang.image.original + ": " + c.width + "x" + c.height + ")";
              o.find(".note-control-selection-info").text(u), this.context.invoke("editor.saveTarget", t);
            } else this.hide();

            return n;
          }
        }, {
          key: "hide",
          value: function value() {
            this.context.invoke("editor.clearTarget"), this.$handle.children().hide();
          }
        }]) && Yt(e.prototype, n), o && Yt(e, o), t;
      }();

      function Xt(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Qt = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/]{2}|tel:|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i,
          Jt = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.options = e.options, this.events = {
            "summernote.keyup": function summernoteKeyup(t, e) {
              e.isDefaultPrevented() || n.handleKeyup(e);
            },
            "summernote.keydown": function summernoteKeydown(t, e) {
              n.handleKeydown(e);
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            this.lastWordRange = null;
          }
        }, {
          key: "destroy",
          value: function value() {
            this.lastWordRange = null;
          }
        }, {
          key: "replace",
          value: function value() {
            if (this.lastWordRange) {
              var t = this.lastWordRange.toString(),
                  e = t.match(Qt);

              if (e && (e[1] || e[2])) {
                var n = e[1] ? t : "http://" + t,
                    o = this.options.showDomainOnlyForAutolink ? t.replace(/^(?:https?:\/\/)?(?:tel?:?)?(?:mailto?:?)?(?:www\.)?/i, "").split("/")[0] : t,
                    r = i()("<a />").html(o).attr("href", n)[0];
                this.context.options.linkTargetBlank && i()(r).attr("target", "_blank"), this.lastWordRange.insertNode(r), this.lastWordRange = null, this.context.invoke("editor.focus");
              }
            }
          }
        }, {
          key: "handleKeydown",
          value: function value(t) {
            if (C.contains([xt.code.ENTER, xt.code.SPACE], t.keyCode)) {
              var e = this.context.invoke("editor.createRange").getWordRange();
              this.lastWordRange = e;
            }
          }
        }, {
          key: "handleKeyup",
          value: function value(t) {
            C.contains([xt.code.ENTER, xt.code.SPACE], t.keyCode) && this.replace();
          }
        }]) && Xt(e.prototype, n), o && Xt(e, o), t;
      }();

      function te(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var ee = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.$note = e.layoutInfo.note, this.events = {
            "summernote.change": function summernoteChange() {
              n.$note.val(e.invoke("code"));
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return pt.isTextarea(this.$note[0]);
          }
        }]) && te(e.prototype, n), o && te(e, o), t;
      }();

      function ne(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var oe = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.options = e.options.replace || {}, this.keys = [xt.code.ENTER, xt.code.SPACE, xt.code.PERIOD, xt.code.COMMA, xt.code.SEMICOLON, xt.code.SLASH], this.previousKeydownCode = null, this.events = {
            "summernote.keyup": function summernoteKeyup(t, e) {
              e.isDefaultPrevented() || n.handleKeyup(e);
            },
            "summernote.keydown": function summernoteKeydown(t, e) {
              n.handleKeydown(e);
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return !!this.options.match;
          }
        }, {
          key: "initialize",
          value: function value() {
            this.lastWord = null;
          }
        }, {
          key: "destroy",
          value: function value() {
            this.lastWord = null;
          }
        }, {
          key: "replace",
          value: function value() {
            if (this.lastWord) {
              var t = this,
                  e = this.lastWord.toString();
              this.options.match(e, function (e) {
                if (e) {
                  var n = "";
                  if ("string" == typeof e ? n = pt.createText(e) : e instanceof jQuery ? n = e[0] : e instanceof Node && (n = e), !n) return;
                  t.lastWord.insertNode(n), t.lastWord = null, t.context.invoke("editor.focus");
                }
              });
            }
          }
        }, {
          key: "handleKeydown",
          value: function value(t) {
            if (this.previousKeydownCode && C.contains(this.keys, this.previousKeydownCode)) this.previousKeydownCode = t.keyCode;else {
              if (C.contains(this.keys, t.keyCode)) {
                var e = this.context.invoke("editor.createRange").getWordRange();
                this.lastWord = e;
              }

              this.previousKeydownCode = t.keyCode;
            }
          }
        }, {
          key: "handleKeyup",
          value: function value(t) {
            C.contains(this.keys, t.keyCode) && this.replace();
          }
        }]) && ne(e.prototype, n), o && ne(e, o), t;
      }();

      function ie(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var re = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$editingArea = e.layoutInfo.editingArea, this.options = e.options, !0 === this.options.inheritPlaceholder && (this.options.placeholder = this.context.$note.attr("placeholder") || this.options.placeholder), this.events = {
            "summernote.init summernote.change": function summernoteInitSummernoteChange() {
              n.update();
            },
            "summernote.codeview.toggled": function summernoteCodeviewToggled() {
              n.update();
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return !!this.options.placeholder;
          }
        }, {
          key: "initialize",
          value: function value() {
            var t = this;
            this.$placeholder = i()('<div class="note-placeholder">'), this.$placeholder.on("click", function () {
              t.context.invoke("focus");
            }).html(this.options.placeholder).prependTo(this.$editingArea), this.update();
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$placeholder.remove();
          }
        }, {
          key: "update",
          value: function value() {
            var t = !this.context.invoke("codeview.isActivated") && this.context.invoke("editor.isEmpty");
            this.$placeholder.toggle(t);
          }
        }]) && ie(e.prototype, n), o && ie(e, o), t;
      }();

      function ae(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var se = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.ui = i.a.summernote.ui, this.context = e, this.$toolbar = e.layoutInfo.toolbar, this.options = e.options, this.lang = this.options.langInfo, this.invertedKeyMap = g.invertObject(this.options.keyMap[m.isMac ? "mac" : "pc"]);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "representShortcut",
          value: function value(t) {
            var e = this.invertedKeyMap[t];
            return this.options.shortcuts && e ? (m.isMac && (e = e.replace("CMD", "").replace("SHIFT", "")), " (" + (e = e.replace("BACKSLASH", "\\").replace("SLASH", "/").replace("LEFTBRACKET", "[").replace("RIGHTBRACKET", "]")) + ")") : "";
          }
        }, {
          key: "button",
          value: function value(t) {
            return !this.options.tooltip && t.tooltip && delete t.tooltip, t.container = this.options.container, this.ui.button(t);
          }
        }, {
          key: "initialize",
          value: function value() {
            this.addToolbarButtons(), this.addImagePopoverButtons(), this.addLinkPopoverButtons(), this.addTablePopoverButtons(), this.fontInstalledMap = {};
          }
        }, {
          key: "destroy",
          value: function value() {
            delete this.fontInstalledMap;
          }
        }, {
          key: "isFontInstalled",
          value: function value(t) {
            return Object.prototype.hasOwnProperty.call(this.fontInstalledMap, t) || (this.fontInstalledMap[t] = m.isFontInstalled(t) || C.contains(this.options.fontNamesIgnoreCheck, t)), this.fontInstalledMap[t];
          }
        }, {
          key: "isFontDeservedToAdd",
          value: function value(t) {
            return "" !== (t = t.toLowerCase()) && this.isFontInstalled(t) && -1 === m.genericFontFamilies.indexOf(t);
          }
        }, {
          key: "colorPalette",
          value: function value(t, e, n, o) {
            var r = this;
            return this.ui.buttonGroup({
              className: "note-color " + t,
              children: [this.button({
                className: "note-current-color-button",
                contents: this.ui.icon(this.options.icons.font + " note-recent-color"),
                tooltip: e,
                click: function click(t) {
                  var e = i()(t.currentTarget);
                  n && o ? r.context.invoke("editor.color", {
                    backColor: e.attr("data-backColor"),
                    foreColor: e.attr("data-foreColor")
                  }) : n ? r.context.invoke("editor.color", {
                    backColor: e.attr("data-backColor")
                  }) : o && r.context.invoke("editor.color", {
                    foreColor: e.attr("data-foreColor")
                  });
                },
                callback: function callback(t) {
                  var e = t.find(".note-recent-color");
                  n && (e.css("background-color", r.options.colorButton.backColor), t.attr("data-backColor", r.options.colorButton.backColor)), o ? (e.css("color", r.options.colorButton.foreColor), t.attr("data-foreColor", r.options.colorButton.foreColor)) : e.css("color", "transparent");
                }
              }), this.button({
                className: "dropdown-toggle",
                contents: this.ui.dropdownButtonContents("", this.options),
                tooltip: this.lang.color.more,
                data: {
                  toggle: "dropdown"
                }
              }), this.ui.dropdown({
                items: (n ? ['<div class="note-palette">', '<div class="note-palette-title">' + this.lang.color.background + "</div>", "<div>", '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="backColor" data-value="transparent">', this.lang.color.transparent, "</button>", "</div>", '<div class="note-holder" data-event="backColor">\x3c!-- back colors --\x3e</div>', "<div>", '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="backColorPicker">', this.lang.color.cpSelect, "</button>", '<input type="color" id="backColorPicker" class="note-btn note-color-select-btn" value="' + this.options.colorButton.backColor + '" data-event="backColorPalette">', "</div>", '<div class="note-holder-custom" id="backColorPalette" data-event="backColor"></div>', "</div>"].join("") : "") + (o ? ['<div class="note-palette">', '<div class="note-palette-title">' + this.lang.color.foreground + "</div>", "<div>", '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="removeFormat" data-value="foreColor">', this.lang.color.resetToDefault, "</button>", "</div>", '<div class="note-holder" data-event="foreColor">\x3c!-- fore colors --\x3e</div>', "<div>", '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="foreColorPicker">', this.lang.color.cpSelect, "</button>", '<input type="color" id="foreColorPicker" class="note-btn note-color-select-btn" value="' + this.options.colorButton.foreColor + '" data-event="foreColorPalette">', "</div>", '<div class="note-holder-custom" id="foreColorPalette" data-event="foreColor"></div>', "</div>"].join("") : ""),
                callback: function callback(t) {
                  t.find(".note-holder").each(function (t, e) {
                    var n = i()(e);
                    n.append(r.ui.palette({
                      colors: r.options.colors,
                      colorsName: r.options.colorsName,
                      eventName: n.data("event"),
                      container: r.options.container,
                      tooltip: r.options.tooltip
                    }).render());
                  });
                  var e = [["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"]];
                  t.find(".note-holder-custom").each(function (t, n) {
                    var o = i()(n);
                    o.append(r.ui.palette({
                      colors: e,
                      colorsName: e,
                      eventName: o.data("event"),
                      container: r.options.container,
                      tooltip: r.options.tooltip
                    }).render());
                  }), t.find("input[type=color]").each(function (e, n) {
                    i()(n).change(function () {
                      var e = t.find("#" + i()(this).data("event")).find(".note-color-btn").first(),
                          n = this.value.toUpperCase();
                      e.css("background-color", n).attr("aria-label", n).attr("data-value", n).attr("data-original-title", n), e.click();
                    });
                  });
                },
                click: function click(e) {
                  e.stopPropagation();
                  var n = i()("." + t).find(".note-dropdown-menu"),
                      o = i()(e.target),
                      a = o.data("event"),
                      s = o.attr("data-value");

                  if ("openPalette" === a) {
                    var l = n.find("#" + s),
                        c = i()(n.find("#" + l.data("event")).find(".note-color-row")[0]),
                        u = c.find(".note-color-btn").last().detach(),
                        d = l.val();
                    u.css("background-color", d).attr("aria-label", d).attr("data-value", d).attr("data-original-title", d), c.prepend(u), l.click();
                  } else {
                    if (C.contains(["backColor", "foreColor"], a)) {
                      var h = "backColor" === a ? "background-color" : "color",
                          f = o.closest(".note-color").find(".note-recent-color"),
                          p = o.closest(".note-color").find(".note-current-color-button");
                      f.css(h, s), p.attr("data-" + a, s);
                    }

                    r.context.invoke("editor." + a, s);
                  }
                }
              })]
            }).render();
          }
        }, {
          key: "addToolbarButtons",
          value: function value() {
            var t = this;
            this.context.memo("button.style", function () {
              return t.ui.buttonGroup([t.button({
                className: "dropdown-toggle",
                contents: t.ui.dropdownButtonContents(t.ui.icon(t.options.icons.magic), t.options),
                tooltip: t.lang.style.style,
                data: {
                  toggle: "dropdown"
                }
              }), t.ui.dropdown({
                className: "dropdown-style",
                items: t.options.styleTags,
                title: t.lang.style.style,
                template: function template(e) {
                  "string" == typeof e && (e = {
                    tag: e,
                    title: Object.prototype.hasOwnProperty.call(t.lang.style, e) ? t.lang.style[e] : e
                  });
                  var n = e.tag,
                      o = e.title;
                  return "<" + n + (e.style ? ' style="' + e.style + '" ' : "") + (e.className ? ' class="' + e.className + '"' : "") + ">" + o + "</" + n + ">";
                },
                click: t.context.createInvokeHandler("editor.formatBlock")
              })]).render();
            });

            for (var e = function e(_e2, n) {
              var o = t.options.styleTags[_e2];
              t.context.memo("button.style." + o, function () {
                return t.button({
                  className: "note-btn-style-" + o,
                  contents: '<div data-value="' + o + '">' + o.toUpperCase() + "</div>",
                  tooltip: t.lang.style[o],
                  click: t.context.createInvokeHandler("editor.formatBlock")
                }).render();
              });
            }, n = 0, o = this.options.styleTags.length; n < o; n++) {
              e(n);
            }

            this.context.memo("button.bold", function () {
              return t.button({
                className: "note-btn-bold",
                contents: t.ui.icon(t.options.icons.bold),
                tooltip: t.lang.font.bold + t.representShortcut("bold"),
                click: t.context.createInvokeHandlerAndUpdateState("editor.bold")
              }).render();
            }), this.context.memo("button.italic", function () {
              return t.button({
                className: "note-btn-italic",
                contents: t.ui.icon(t.options.icons.italic),
                tooltip: t.lang.font.italic + t.representShortcut("italic"),
                click: t.context.createInvokeHandlerAndUpdateState("editor.italic")
              }).render();
            }), this.context.memo("button.underline", function () {
              return t.button({
                className: "note-btn-underline",
                contents: t.ui.icon(t.options.icons.underline),
                tooltip: t.lang.font.underline + t.representShortcut("underline"),
                click: t.context.createInvokeHandlerAndUpdateState("editor.underline")
              }).render();
            }), this.context.memo("button.clear", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.eraser),
                tooltip: t.lang.font.clear + t.representShortcut("removeFormat"),
                click: t.context.createInvokeHandler("editor.removeFormat")
              }).render();
            }), this.context.memo("button.strikethrough", function () {
              return t.button({
                className: "note-btn-strikethrough",
                contents: t.ui.icon(t.options.icons.strikethrough),
                tooltip: t.lang.font.strikethrough + t.representShortcut("strikethrough"),
                click: t.context.createInvokeHandlerAndUpdateState("editor.strikethrough")
              }).render();
            }), this.context.memo("button.superscript", function () {
              return t.button({
                className: "note-btn-superscript",
                contents: t.ui.icon(t.options.icons.superscript),
                tooltip: t.lang.font.superscript,
                click: t.context.createInvokeHandlerAndUpdateState("editor.superscript")
              }).render();
            }), this.context.memo("button.subscript", function () {
              return t.button({
                className: "note-btn-subscript",
                contents: t.ui.icon(t.options.icons.subscript),
                tooltip: t.lang.font.subscript,
                click: t.context.createInvokeHandlerAndUpdateState("editor.subscript")
              }).render();
            }), this.context.memo("button.fontname", function () {
              var e = t.context.invoke("editor.currentStyle");
              return t.options.addDefaultFonts && i.a.each(e["font-family"].split(","), function (e, n) {
                n = n.trim().replace(/['"]+/g, ""), t.isFontDeservedToAdd(n) && -1 === t.options.fontNames.indexOf(n) && t.options.fontNames.push(n);
              }), t.ui.buttonGroup([t.button({
                className: "dropdown-toggle",
                contents: t.ui.dropdownButtonContents('<span class="note-current-fontname"></span>', t.options),
                tooltip: t.lang.font.name,
                data: {
                  toggle: "dropdown"
                }
              }), t.ui.dropdownCheck({
                className: "dropdown-fontname",
                checkClassName: t.options.icons.menuCheck,
                items: t.options.fontNames.filter(t.isFontInstalled.bind(t)),
                title: t.lang.font.name,
                template: function template(t) {
                  return '<span style="font-family: ' + m.validFontName(t) + '">' + t + "</span>";
                },
                click: t.context.createInvokeHandlerAndUpdateState("editor.fontName")
              })]).render();
            }), this.context.memo("button.fontsize", function () {
              return t.ui.buttonGroup([t.button({
                className: "dropdown-toggle",
                contents: t.ui.dropdownButtonContents('<span class="note-current-fontsize"></span>', t.options),
                tooltip: t.lang.font.size,
                data: {
                  toggle: "dropdown"
                }
              }), t.ui.dropdownCheck({
                className: "dropdown-fontsize",
                checkClassName: t.options.icons.menuCheck,
                items: t.options.fontSizes,
                title: t.lang.font.size,
                click: t.context.createInvokeHandlerAndUpdateState("editor.fontSize")
              })]).render();
            }), this.context.memo("button.fontsizeunit", function () {
              return t.ui.buttonGroup([t.button({
                className: "dropdown-toggle",
                contents: t.ui.dropdownButtonContents('<span class="note-current-fontsizeunit"></span>', t.options),
                tooltip: t.lang.font.sizeunit,
                data: {
                  toggle: "dropdown"
                }
              }), t.ui.dropdownCheck({
                className: "dropdown-fontsizeunit",
                checkClassName: t.options.icons.menuCheck,
                items: t.options.fontSizeUnits,
                title: t.lang.font.sizeunit,
                click: t.context.createInvokeHandlerAndUpdateState("editor.fontSizeUnit")
              })]).render();
            }), this.context.memo("button.color", function () {
              return t.colorPalette("note-color-all", t.lang.color.recent, !0, !0);
            }), this.context.memo("button.forecolor", function () {
              return t.colorPalette("note-color-fore", t.lang.color.foreground, !1, !0);
            }), this.context.memo("button.backcolor", function () {
              return t.colorPalette("note-color-back", t.lang.color.background, !0, !1);
            }), this.context.memo("button.ul", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.unorderedlist),
                tooltip: t.lang.lists.unordered + t.representShortcut("insertUnorderedList"),
                click: t.context.createInvokeHandler("editor.insertUnorderedList")
              }).render();
            }), this.context.memo("button.ol", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.orderedlist),
                tooltip: t.lang.lists.ordered + t.representShortcut("insertOrderedList"),
                click: t.context.createInvokeHandler("editor.insertOrderedList")
              }).render();
            });
            var r = this.button({
              contents: this.ui.icon(this.options.icons.alignLeft),
              tooltip: this.lang.paragraph.left + this.representShortcut("justifyLeft"),
              click: this.context.createInvokeHandler("editor.justifyLeft")
            }),
                a = this.button({
              contents: this.ui.icon(this.options.icons.alignCenter),
              tooltip: this.lang.paragraph.center + this.representShortcut("justifyCenter"),
              click: this.context.createInvokeHandler("editor.justifyCenter")
            }),
                s = this.button({
              contents: this.ui.icon(this.options.icons.alignRight),
              tooltip: this.lang.paragraph.right + this.representShortcut("justifyRight"),
              click: this.context.createInvokeHandler("editor.justifyRight")
            }),
                l = this.button({
              contents: this.ui.icon(this.options.icons.alignJustify),
              tooltip: this.lang.paragraph.justify + this.representShortcut("justifyFull"),
              click: this.context.createInvokeHandler("editor.justifyFull")
            }),
                c = this.button({
              contents: this.ui.icon(this.options.icons.outdent),
              tooltip: this.lang.paragraph.outdent + this.representShortcut("outdent"),
              click: this.context.createInvokeHandler("editor.outdent")
            }),
                u = this.button({
              contents: this.ui.icon(this.options.icons.indent),
              tooltip: this.lang.paragraph.indent + this.representShortcut("indent"),
              click: this.context.createInvokeHandler("editor.indent")
            });
            this.context.memo("button.justifyLeft", g.invoke(r, "render")), this.context.memo("button.justifyCenter", g.invoke(a, "render")), this.context.memo("button.justifyRight", g.invoke(s, "render")), this.context.memo("button.justifyFull", g.invoke(l, "render")), this.context.memo("button.outdent", g.invoke(c, "render")), this.context.memo("button.indent", g.invoke(u, "render")), this.context.memo("button.paragraph", function () {
              return t.ui.buttonGroup([t.button({
                className: "dropdown-toggle",
                contents: t.ui.dropdownButtonContents(t.ui.icon(t.options.icons.alignLeft), t.options),
                tooltip: t.lang.paragraph.paragraph,
                data: {
                  toggle: "dropdown"
                }
              }), t.ui.dropdown([t.ui.buttonGroup({
                className: "note-align",
                children: [r, a, s, l]
              }), t.ui.buttonGroup({
                className: "note-list",
                children: [c, u]
              })])]).render();
            }), this.context.memo("button.height", function () {
              return t.ui.buttonGroup([t.button({
                className: "dropdown-toggle",
                contents: t.ui.dropdownButtonContents(t.ui.icon(t.options.icons.textHeight), t.options),
                tooltip: t.lang.font.height,
                data: {
                  toggle: "dropdown"
                }
              }), t.ui.dropdownCheck({
                items: t.options.lineHeights,
                checkClassName: t.options.icons.menuCheck,
                className: "dropdown-line-height",
                title: t.lang.font.height,
                click: t.context.createInvokeHandler("editor.lineHeight")
              })]).render();
            }), this.context.memo("button.table", function () {
              return t.ui.buttonGroup([t.button({
                className: "dropdown-toggle",
                contents: t.ui.dropdownButtonContents(t.ui.icon(t.options.icons.table), t.options),
                tooltip: t.lang.table.table,
                data: {
                  toggle: "dropdown"
                }
              }), t.ui.dropdown({
                title: t.lang.table.table,
                className: "note-table",
                items: ['<div class="note-dimension-picker">', '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"></div>', '<div class="note-dimension-picker-highlighted"></div>', '<div class="note-dimension-picker-unhighlighted"></div>', "</div>", '<div class="note-dimension-display">1 x 1</div>'].join("")
              })], {
                callback: function callback(e) {
                  e.find(".note-dimension-picker-mousecatcher").css({
                    width: t.options.insertTableMaxSize.col + "em",
                    height: t.options.insertTableMaxSize.row + "em"
                  }).mousedown(t.context.createInvokeHandler("editor.insertTable")).on("mousemove", t.tableMoveHandler.bind(t));
                }
              }).render();
            }), this.context.memo("button.link", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.link),
                tooltip: t.lang.link.link + t.representShortcut("linkDialog.show"),
                click: t.context.createInvokeHandler("linkDialog.show")
              }).render();
            }), this.context.memo("button.picture", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.picture),
                tooltip: t.lang.image.image,
                click: t.context.createInvokeHandler("imageDialog.show")
              }).render();
            }), this.context.memo("button.video", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.video),
                tooltip: t.lang.video.video,
                click: t.context.createInvokeHandler("videoDialog.show")
              }).render();
            }), this.context.memo("button.hr", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.minus),
                tooltip: t.lang.hr.insert + t.representShortcut("insertHorizontalRule"),
                click: t.context.createInvokeHandler("editor.insertHorizontalRule")
              }).render();
            }), this.context.memo("button.fullscreen", function () {
              return t.button({
                className: "btn-fullscreen note-codeview-keep",
                contents: t.ui.icon(t.options.icons.arrowsAlt),
                tooltip: t.lang.options.fullscreen,
                click: t.context.createInvokeHandler("fullscreen.toggle")
              }).render();
            }), this.context.memo("button.codeview", function () {
              return t.button({
                className: "btn-codeview note-codeview-keep",
                contents: t.ui.icon(t.options.icons.code),
                tooltip: t.lang.options.codeview,
                click: t.context.createInvokeHandler("codeview.toggle")
              }).render();
            }), this.context.memo("button.redo", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.redo),
                tooltip: t.lang.history.redo + t.representShortcut("redo"),
                click: t.context.createInvokeHandler("editor.redo")
              }).render();
            }), this.context.memo("button.undo", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.undo),
                tooltip: t.lang.history.undo + t.representShortcut("undo"),
                click: t.context.createInvokeHandler("editor.undo")
              }).render();
            }), this.context.memo("button.help", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.question),
                tooltip: t.lang.options.help,
                click: t.context.createInvokeHandler("helpDialog.show")
              }).render();
            });
          }
        }, {
          key: "addImagePopoverButtons",
          value: function value() {
            var t = this;
            this.context.memo("button.resizeFull", function () {
              return t.button({
                contents: '<span class="note-fontsize-10">100%</span>',
                tooltip: t.lang.image.resizeFull,
                click: t.context.createInvokeHandler("editor.resize", "1")
              }).render();
            }), this.context.memo("button.resizeHalf", function () {
              return t.button({
                contents: '<span class="note-fontsize-10">50%</span>',
                tooltip: t.lang.image.resizeHalf,
                click: t.context.createInvokeHandler("editor.resize", "0.5")
              }).render();
            }), this.context.memo("button.resizeQuarter", function () {
              return t.button({
                contents: '<span class="note-fontsize-10">25%</span>',
                tooltip: t.lang.image.resizeQuarter,
                click: t.context.createInvokeHandler("editor.resize", "0.25")
              }).render();
            }), this.context.memo("button.resizeNone", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.rollback),
                tooltip: t.lang.image.resizeNone,
                click: t.context.createInvokeHandler("editor.resize", "0")
              }).render();
            }), this.context.memo("button.floatLeft", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.floatLeft),
                tooltip: t.lang.image.floatLeft,
                click: t.context.createInvokeHandler("editor.floatMe", "left")
              }).render();
            }), this.context.memo("button.floatRight", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.floatRight),
                tooltip: t.lang.image.floatRight,
                click: t.context.createInvokeHandler("editor.floatMe", "right")
              }).render();
            }), this.context.memo("button.floatNone", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.rollback),
                tooltip: t.lang.image.floatNone,
                click: t.context.createInvokeHandler("editor.floatMe", "none")
              }).render();
            }), this.context.memo("button.removeMedia", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.trash),
                tooltip: t.lang.image.remove,
                click: t.context.createInvokeHandler("editor.removeMedia")
              }).render();
            });
          }
        }, {
          key: "addLinkPopoverButtons",
          value: function value() {
            var t = this;
            this.context.memo("button.linkDialogShow", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.link),
                tooltip: t.lang.link.edit,
                click: t.context.createInvokeHandler("linkDialog.show")
              }).render();
            }), this.context.memo("button.unlink", function () {
              return t.button({
                contents: t.ui.icon(t.options.icons.unlink),
                tooltip: t.lang.link.unlink,
                click: t.context.createInvokeHandler("editor.unlink")
              }).render();
            });
          }
        }, {
          key: "addTablePopoverButtons",
          value: function value() {
            var t = this;
            this.context.memo("button.addRowUp", function () {
              return t.button({
                className: "btn-md",
                contents: t.ui.icon(t.options.icons.rowAbove),
                tooltip: t.lang.table.addRowAbove,
                click: t.context.createInvokeHandler("editor.addRow", "top")
              }).render();
            }), this.context.memo("button.addRowDown", function () {
              return t.button({
                className: "btn-md",
                contents: t.ui.icon(t.options.icons.rowBelow),
                tooltip: t.lang.table.addRowBelow,
                click: t.context.createInvokeHandler("editor.addRow", "bottom")
              }).render();
            }), this.context.memo("button.addColLeft", function () {
              return t.button({
                className: "btn-md",
                contents: t.ui.icon(t.options.icons.colBefore),
                tooltip: t.lang.table.addColLeft,
                click: t.context.createInvokeHandler("editor.addCol", "left")
              }).render();
            }), this.context.memo("button.addColRight", function () {
              return t.button({
                className: "btn-md",
                contents: t.ui.icon(t.options.icons.colAfter),
                tooltip: t.lang.table.addColRight,
                click: t.context.createInvokeHandler("editor.addCol", "right")
              }).render();
            }), this.context.memo("button.deleteRow", function () {
              return t.button({
                className: "btn-md",
                contents: t.ui.icon(t.options.icons.rowRemove),
                tooltip: t.lang.table.delRow,
                click: t.context.createInvokeHandler("editor.deleteRow")
              }).render();
            }), this.context.memo("button.deleteCol", function () {
              return t.button({
                className: "btn-md",
                contents: t.ui.icon(t.options.icons.colRemove),
                tooltip: t.lang.table.delCol,
                click: t.context.createInvokeHandler("editor.deleteCol")
              }).render();
            }), this.context.memo("button.deleteTable", function () {
              return t.button({
                className: "btn-md",
                contents: t.ui.icon(t.options.icons.trash),
                tooltip: t.lang.table.delTable,
                click: t.context.createInvokeHandler("editor.deleteTable")
              }).render();
            });
          }
        }, {
          key: "build",
          value: function value(t, e) {
            for (var n = 0, o = e.length; n < o; n++) {
              for (var i = e[n], r = Array.isArray(i) ? i[0] : i, a = Array.isArray(i) ? 1 === i.length ? [i[0]] : i[1] : [i], s = this.ui.buttonGroup({
                className: "note-" + r
              }).render(), l = 0, c = a.length; l < c; l++) {
                var u = this.context.memo("button." + a[l]);
                u && s.append("function" == typeof u ? u(this.context) : u);
              }

              s.appendTo(t);
            }
          }
        }, {
          key: "updateCurrentStyle",
          value: function value(t) {
            var e = this,
                n = t || this.$toolbar,
                o = this.context.invoke("editor.currentStyle");

            if (this.updateBtnStates(n, {
              ".note-btn-bold": function noteBtnBold() {
                return "bold" === o["font-bold"];
              },
              ".note-btn-italic": function noteBtnItalic() {
                return "italic" === o["font-italic"];
              },
              ".note-btn-underline": function noteBtnUnderline() {
                return "underline" === o["font-underline"];
              },
              ".note-btn-subscript": function noteBtnSubscript() {
                return "subscript" === o["font-subscript"];
              },
              ".note-btn-superscript": function noteBtnSuperscript() {
                return "superscript" === o["font-superscript"];
              },
              ".note-btn-strikethrough": function noteBtnStrikethrough() {
                return "strikethrough" === o["font-strikethrough"];
              }
            }), o["font-family"]) {
              var r = o["font-family"].split(",").map(function (t) {
                return t.replace(/[\'\"]/g, "").replace(/\s+$/, "").replace(/^\s+/, "");
              }),
                  a = C.find(r, this.isFontInstalled.bind(this));
              n.find(".dropdown-fontname a").each(function (t, e) {
                var n = i()(e),
                    o = n.data("value") + "" == a + "";
                n.toggleClass("checked", o);
              }), n.find(".note-current-fontname").text(a).css("font-family", a);
            }

            if (o["font-size"]) {
              var s = o["font-size"];
              n.find(".dropdown-fontsize a").each(function (t, e) {
                var n = i()(e),
                    o = n.data("value") + "" == s + "";
                n.toggleClass("checked", o);
              }), n.find(".note-current-fontsize").text(s);
              var l = o["font-size-unit"];
              n.find(".dropdown-fontsizeunit a").each(function (t, e) {
                var n = i()(e),
                    o = n.data("value") + "" == l + "";
                n.toggleClass("checked", o);
              }), n.find(".note-current-fontsizeunit").text(l);
            }

            if (o["line-height"]) {
              var c = o["line-height"];
              n.find(".dropdown-line-height li a").each(function (t, n) {
                var o = i()(n).data("value") + "" == c + "";
                e.className = o ? "checked" : "";
              });
            }
          }
        }, {
          key: "updateBtnStates",
          value: function value(t, e) {
            var n = this;
            i.a.each(e, function (e, o) {
              n.ui.toggleBtnActive(t.find(e), o());
            });
          }
        }, {
          key: "tableMoveHandler",
          value: function value(t) {
            var e,
                n = i()(t.target.parentNode),
                o = n.next(),
                r = n.find(".note-dimension-picker-mousecatcher"),
                a = n.find(".note-dimension-picker-highlighted"),
                s = n.find(".note-dimension-picker-unhighlighted");

            if (void 0 === t.offsetX) {
              var l = i()(t.target).offset();
              e = {
                x: t.pageX - l.left,
                y: t.pageY - l.top
              };
            } else e = {
              x: t.offsetX,
              y: t.offsetY
            };

            var c = Math.ceil(e.x / 18) || 1,
                u = Math.ceil(e.y / 18) || 1;
            a.css({
              width: c + "em",
              height: u + "em"
            }), r.data("value", c + "x" + u), c > 3 && c < this.options.insertTableMaxSize.col && s.css({
              width: c + 1 + "em"
            }), u > 3 && u < this.options.insertTableMaxSize.row && s.css({
              height: u + 1 + "em"
            }), o.html(c + " x " + u);
          }
        }]) && ae(e.prototype, n), o && ae(e, o), t;
      }();

      function le(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var ce = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.$window = i()(window), this.$document = i()(document), this.ui = i.a.summernote.ui, this.$note = e.layoutInfo.note, this.$editor = e.layoutInfo.editor, this.$toolbar = e.layoutInfo.toolbar, this.$editable = e.layoutInfo.editable, this.$statusbar = e.layoutInfo.statusbar, this.options = e.options, this.isFollowing = !1, this.followScroll = this.followScroll.bind(this);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return !this.options.airMode;
          }
        }, {
          key: "initialize",
          value: function value() {
            var t = this;
            this.options.toolbar = this.options.toolbar || [], this.options.toolbar.length ? this.context.invoke("buttons.build", this.$toolbar, this.options.toolbar) : this.$toolbar.hide(), this.options.toolbarContainer && this.$toolbar.appendTo(this.options.toolbarContainer), this.changeContainer(!1), this.$note.on("summernote.keyup summernote.mouseup summernote.change", function () {
              t.context.invoke("buttons.updateCurrentStyle");
            }), this.context.invoke("buttons.updateCurrentStyle"), this.options.followingToolbar && this.$window.on("scroll resize", this.followScroll);
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$toolbar.children().remove(), this.options.followingToolbar && this.$window.off("scroll resize", this.followScroll);
          }
        }, {
          key: "followScroll",
          value: function value() {
            if (this.$editor.hasClass("fullscreen")) return !1;
            var t = this.$editor.outerHeight(),
                e = this.$editor.width(),
                n = this.$toolbar.height(),
                o = this.$statusbar.height(),
                r = 0;
            this.options.otherStaticBar && (r = i()(this.options.otherStaticBar).outerHeight());
            var a = this.$document.scrollTop(),
                s = this.$editor.offset().top,
                l = s - r,
                c = s + t - r - n - o;
            !this.isFollowing && a > l && a < c - n ? (this.isFollowing = !0, this.$editable.css({
              marginTop: this.$toolbar.outerHeight()
            }), this.$toolbar.css({
              position: "fixed",
              top: r,
              width: e,
              zIndex: 1e3
            })) : this.isFollowing && (a < l || a > c) && (this.isFollowing = !1, this.$toolbar.css({
              position: "relative",
              top: 0,
              width: "100%",
              zIndex: "auto"
            }), this.$editable.css({
              marginTop: ""
            }));
          }
        }, {
          key: "changeContainer",
          value: function value(t) {
            t ? this.$toolbar.prependTo(this.$editor) : this.options.toolbarContainer && this.$toolbar.appendTo(this.options.toolbarContainer), this.options.followingToolbar && this.followScroll();
          }
        }, {
          key: "updateFullscreen",
          value: function value(t) {
            this.ui.toggleBtnActive(this.$toolbar.find(".btn-fullscreen"), t), this.changeContainer(t);
          }
        }, {
          key: "updateCodeview",
          value: function value(t) {
            this.ui.toggleBtnActive(this.$toolbar.find(".btn-codeview"), t), t ? this.deactivate() : this.activate();
          }
        }, {
          key: "activate",
          value: function value(t) {
            var e = this.$toolbar.find("button");
            t || (e = e.not(".note-codeview-keep")), this.ui.toggleBtn(e, !0);
          }
        }, {
          key: "deactivate",
          value: function value(t) {
            var e = this.$toolbar.find("button");
            t || (e = e.not(".note-codeview-keep")), this.ui.toggleBtn(e, !1);
          }
        }]) && le(e.prototype, n), o && le(e, o), t;
      }();

      function ue(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var de = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.$body = i()(document.body), this.$editor = e.layoutInfo.editor, this.options = e.options, this.lang = this.options.langInfo, e.memo("help.linkDialog.show", this.options.langInfo.help["linkDialog.show"]);
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            var t = this.options.dialogsInBody ? this.$body : this.options.container,
                e = ['<div class="form-group note-form-group">', '<label for="note-dialog-link-txt-'.concat(this.options.id, '" class="note-form-label">').concat(this.lang.link.textToDisplay, "</label>"), '<input id="note-dialog-link-txt-'.concat(this.options.id, '" class="note-link-text form-control note-form-control note-input" type="text"/>'), "</div>", '<div class="form-group note-form-group">', '<label for="note-dialog-link-url-'.concat(this.options.id, '" class="note-form-label">').concat(this.lang.link.url, "</label>"), '<input id="note-dialog-link-url-'.concat(this.options.id, '" class="note-link-url form-control note-form-control note-input" type="text" value="http://"/>'), "</div>", this.options.disableLinkTarget ? "" : i()("<div/>").append(this.ui.checkbox({
              className: "sn-checkbox-open-in-new-window",
              text: this.lang.link.openInNewWindow,
              checked: !0
            }).render()).html(), i()("<div/>").append(this.ui.checkbox({
              className: "sn-checkbox-use-protocol",
              text: this.lang.link.useProtocol,
              checked: !0
            }).render()).html()].join(""),
                n = '<input type="button" href="#" class="'.concat("btn btn-primary note-btn note-btn-primary note-link-btn", '" value="').concat(this.lang.link.insert, '" disabled>');
            this.$dialog = this.ui.dialog({
              className: "link-dialog",
              title: this.lang.link.insert,
              fade: this.options.dialogsFade,
              body: e,
              footer: n
            }).render().appendTo(t);
          }
        }, {
          key: "destroy",
          value: function value() {
            this.ui.hideDialog(this.$dialog), this.$dialog.remove();
          }
        }, {
          key: "bindEnterKey",
          value: function value(t, e) {
            t.on("keypress", function (t) {
              t.keyCode === xt.code.ENTER && (t.preventDefault(), e.trigger("click"));
            });
          }
        }, {
          key: "toggleLinkBtn",
          value: function value(t, e, n) {
            this.ui.toggleBtn(t, e.val() && n.val());
          }
        }, {
          key: "showLinkDialog",
          value: function value(t) {
            var e = this;
            return i.a.Deferred(function (n) {
              var o = e.$dialog.find(".note-link-text"),
                  i = e.$dialog.find(".note-link-url"),
                  r = e.$dialog.find(".note-link-btn"),
                  a = e.$dialog.find(".sn-checkbox-open-in-new-window input[type=checkbox]"),
                  s = e.$dialog.find(".sn-checkbox-use-protocol input[type=checkbox]");
              e.ui.onDialogShown(e.$dialog, function () {
                e.context.triggerEvent("dialog.shown"), !t.url && g.isValidUrl(t.text) && (t.url = t.text), o.on("input paste propertychange", function () {
                  t.text = o.val(), e.toggleLinkBtn(r, o, i);
                }).val(t.text), i.on("input paste propertychange", function () {
                  t.text || o.val(i.val()), e.toggleLinkBtn(r, o, i);
                }).val(t.url), m.isSupportTouch || i.trigger("focus"), e.toggleLinkBtn(r, o, i), e.bindEnterKey(i, r), e.bindEnterKey(o, r);
                var l = void 0 !== t.isNewWindow ? t.isNewWindow : e.context.options.linkTargetBlank;
                a.prop("checked", l);
                var c = !t.url && e.context.options.useProtocol;
                s.prop("checked", c), r.one("click", function (r) {
                  r.preventDefault(), n.resolve({
                    range: t.range,
                    url: i.val(),
                    text: o.val(),
                    isNewWindow: a.is(":checked"),
                    checkProtocol: s.is(":checked")
                  }), e.ui.hideDialog(e.$dialog);
                });
              }), e.ui.onDialogHidden(e.$dialog, function () {
                o.off(), i.off(), r.off(), "pending" === n.state() && n.reject();
              }), e.ui.showDialog(e.$dialog);
            }).promise();
          }
        }, {
          key: "show",
          value: function value() {
            var t = this,
                e = this.context.invoke("editor.getLinkInfo");
            this.context.invoke("editor.saveRange"), this.showLinkDialog(e).then(function (e) {
              t.context.invoke("editor.restoreRange"), t.context.invoke("editor.createLink", e);
            }).fail(function () {
              t.context.invoke("editor.restoreRange");
            });
          }
        }]) && ue(e.prototype, n), o && ue(e, o), t;
      }();

      function he(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var fe = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.options = e.options, this.events = {
            "summernote.keyup summernote.mouseup summernote.change summernote.scroll": function summernoteKeyupSummernoteMouseupSummernoteChangeSummernoteScroll() {
              n.update();
            },
            "summernote.disable summernote.dialog.shown summernote.blur": function summernoteDisableSummernoteDialogShownSummernoteBlur() {
              n.hide();
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return !C.isEmpty(this.options.popover.link);
          }
        }, {
          key: "initialize",
          value: function value() {
            this.$popover = this.ui.popover({
              className: "note-link-popover",
              callback: function callback(t) {
                t.find(".popover-content,.note-popover-content").prepend('<span><a target="_blank"></a>&nbsp;</span>');
              }
            }).render().appendTo(this.options.container);
            var t = this.$popover.find(".popover-content,.note-popover-content");
            this.context.invoke("buttons.build", t, this.options.popover.link), this.$popover.on("mousedown", function (t) {
              t.preventDefault();
            });
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$popover.remove();
          }
        }, {
          key: "update",
          value: function value() {
            if (this.context.invoke("editor.hasFocus")) {
              var t = this.context.invoke("editor.getLastRange");

              if (t.isCollapsed() && t.isOnAnchor()) {
                var e = pt.ancestor(t.sc, pt.isAnchor),
                    n = i()(e).attr("href");
                this.$popover.find("a").attr("href", n).text(n);
                var o = pt.posFromPlaceholder(e),
                    r = i()(this.options.container).offset();
                o.top -= r.top, o.left -= r.left, this.$popover.css({
                  display: "block",
                  left: o.left,
                  top: o.top
                });
              } else this.hide();
            } else this.hide();
          }
        }, {
          key: "hide",
          value: function value() {
            this.$popover.hide();
          }
        }]) && he(e.prototype, n), o && he(e, o), t;
      }();

      function pe(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var me = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.$body = i()(document.body), this.$editor = e.layoutInfo.editor, this.options = e.options, this.lang = this.options.langInfo;
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            var t = "";

            if (this.options.maximumImageFileSize) {
              var e = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024)),
                  n = 1 * (this.options.maximumImageFileSize / Math.pow(1024, e)).toFixed(2) + " " + " KMGTP"[e] + "B";
              t = "<small>".concat(this.lang.image.maximumFileSize + " : " + n, "</small>");
            }

            var o = this.options.dialogsInBody ? this.$body : this.options.container,
                i = ['<div class="form-group note-form-group note-group-select-from-files">', '<label for="note-dialog-image-file-' + this.options.id + '" class="note-form-label">' + this.lang.image.selectFromFiles + "</label>", '<input id="note-dialog-image-file-' + this.options.id + '" class="note-image-input form-control-file note-form-control note-input" ', ' type="file" name="files" accept="image/*" multiple="multiple"/>', t, "</div>", '<div class="form-group note-group-image-url">', '<label for="note-dialog-image-url-' + this.options.id + '" class="note-form-label">' + this.lang.image.url + "</label>", '<input id="note-dialog-image-url-' + this.options.id + '" class="note-image-url form-control note-form-control note-input" type="text"/>', "</div>"].join(""),
                r = '<input type="button" href="#" class="'.concat("btn btn-primary note-btn note-btn-primary note-image-btn", '" value="').concat(this.lang.image.insert, '" disabled>');
            this.$dialog = this.ui.dialog({
              title: this.lang.image.insert,
              fade: this.options.dialogsFade,
              body: i,
              footer: r
            }).render().appendTo(o);
          }
        }, {
          key: "destroy",
          value: function value() {
            this.ui.hideDialog(this.$dialog), this.$dialog.remove();
          }
        }, {
          key: "bindEnterKey",
          value: function value(t, e) {
            t.on("keypress", function (t) {
              t.keyCode === xt.code.ENTER && (t.preventDefault(), e.trigger("click"));
            });
          }
        }, {
          key: "show",
          value: function value() {
            var t = this;
            this.context.invoke("editor.saveRange"), this.showImageDialog().then(function (e) {
              t.ui.hideDialog(t.$dialog), t.context.invoke("editor.restoreRange"), "string" == typeof e ? t.options.callbacks.onImageLinkInsert ? t.context.triggerEvent("image.link.insert", e) : t.context.invoke("editor.insertImage", e) : t.context.invoke("editor.insertImagesOrCallback", e);
            }).fail(function () {
              t.context.invoke("editor.restoreRange");
            });
          }
        }, {
          key: "showImageDialog",
          value: function value() {
            var t = this;
            return i.a.Deferred(function (e) {
              var n = t.$dialog.find(".note-image-input"),
                  o = t.$dialog.find(".note-image-url"),
                  i = t.$dialog.find(".note-image-btn");
              t.ui.onDialogShown(t.$dialog, function () {
                t.context.triggerEvent("dialog.shown"), n.replaceWith(n.clone().on("change", function (t) {
                  e.resolve(t.target.files || t.target.value);
                }).val("")), o.on("input paste propertychange", function () {
                  t.ui.toggleBtn(i, o.val());
                }).val(""), m.isSupportTouch || o.trigger("focus"), i.click(function (t) {
                  t.preventDefault(), e.resolve(o.val());
                }), t.bindEnterKey(o, i);
              }), t.ui.onDialogHidden(t.$dialog, function () {
                n.off(), o.off(), i.off(), "pending" === e.state() && e.reject();
              }), t.ui.showDialog(t.$dialog);
            });
          }
        }]) && pe(e.prototype, n), o && pe(e, o), t;
      }();

      function ve(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var ge = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.editable = e.layoutInfo.editable[0], this.options = e.options, this.events = {
            "summernote.disable summernote.blur": function summernoteDisableSummernoteBlur() {
              n.hide();
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return !C.isEmpty(this.options.popover.image);
          }
        }, {
          key: "initialize",
          value: function value() {
            this.$popover = this.ui.popover({
              className: "note-image-popover"
            }).render().appendTo(this.options.container);
            var t = this.$popover.find(".popover-content,.note-popover-content");
            this.context.invoke("buttons.build", t, this.options.popover.image), this.$popover.on("mousedown", function (t) {
              t.preventDefault();
            });
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$popover.remove();
          }
        }, {
          key: "update",
          value: function value(t, e) {
            if (pt.isImg(t)) {
              var n = i()(t).offset(),
                  o = i()(this.options.container).offset(),
                  r = {};
              this.options.popatmouse ? (r.left = e.pageX - 20, r.top = e.pageY) : r = n, r.top -= o.top, r.left -= o.left, this.$popover.css({
                display: "block",
                left: r.left,
                top: r.top
              });
            } else this.hide();
          }
        }, {
          key: "hide",
          value: function value() {
            this.$popover.hide();
          }
        }]) && ve(e.prototype, n), o && ve(e, o), t;
      }();

      function be(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var ye = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.options = e.options, this.events = {
            "summernote.mousedown": function summernoteMousedown(t, e) {
              n.update(e.target);
            },
            "summernote.keyup summernote.scroll summernote.change": function summernoteKeyupSummernoteScrollSummernoteChange() {
              n.update();
            },
            "summernote.disable summernote.blur": function summernoteDisableSummernoteBlur() {
              n.hide();
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return !C.isEmpty(this.options.popover.table);
          }
        }, {
          key: "initialize",
          value: function value() {
            this.$popover = this.ui.popover({
              className: "note-table-popover"
            }).render().appendTo(this.options.container);
            var t = this.$popover.find(".popover-content,.note-popover-content");
            this.context.invoke("buttons.build", t, this.options.popover.table), m.isFF && document.execCommand("enableInlineTableEditing", !1, !1), this.$popover.on("mousedown", function (t) {
              t.preventDefault();
            });
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$popover.remove();
          }
        }, {
          key: "update",
          value: function value(t) {
            if (this.context.isDisabled()) return !1;
            var e = pt.isCell(t);

            if (e) {
              var n = pt.posFromPlaceholder(t),
                  o = i()(this.options.container).offset();
              n.top -= o.top, n.left -= o.left, this.$popover.css({
                display: "block",
                left: n.left,
                top: n.top
              });
            } else this.hide();

            return e;
          }
        }, {
          key: "hide",
          value: function value() {
            this.$popover.hide();
          }
        }]) && be(e.prototype, n), o && be(e, o), t;
      }();

      function ke(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var we = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.$body = i()(document.body), this.$editor = e.layoutInfo.editor, this.options = e.options, this.lang = this.options.langInfo;
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            var t = this.options.dialogsInBody ? this.$body : this.options.container,
                e = ['<div class="form-group note-form-group row-fluid">', '<label for="note-dialog-video-url-'.concat(this.options.id, '" class="note-form-label">').concat(this.lang.video.url, ' <small class="text-muted">').concat(this.lang.video.providers, "</small></label>"), '<input id="note-dialog-video-url-'.concat(this.options.id, '" class="note-video-url form-control note-form-control note-input" type="text"/>'), "</div>"].join(""),
                n = '<input type="button" href="#" class="'.concat("btn btn-primary note-btn note-btn-primary note-video-btn", '" value="').concat(this.lang.video.insert, '" disabled>');
            this.$dialog = this.ui.dialog({
              title: this.lang.video.insert,
              fade: this.options.dialogsFade,
              body: e,
              footer: n
            }).render().appendTo(t);
          }
        }, {
          key: "destroy",
          value: function value() {
            this.ui.hideDialog(this.$dialog), this.$dialog.remove();
          }
        }, {
          key: "bindEnterKey",
          value: function value(t, e) {
            t.on("keypress", function (t) {
              t.keyCode === xt.code.ENTER && (t.preventDefault(), e.trigger("click"));
            });
          }
        }, {
          key: "createVideoNode",
          value: function value(t) {
            var e,
                n = t.match(/\/\/(?:(?:www|m)\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))([\w|-]{11})(?:(?:[\?&]t=)(\S+))?$/),
                o = t.match(/(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/),
                r = t.match(/\/\/vine\.co\/v\/([a-zA-Z0-9]+)/),
                a = t.match(/\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/),
                s = t.match(/.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/),
                l = t.match(/\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/),
                c = t.match(/\/\/v\.qq\.com.*?vid=(.+)/),
                u = t.match(/\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/),
                d = t.match(/^.+.(mp4|m4v)$/),
                h = t.match(/^.+.(ogg|ogv)$/),
                f = t.match(/^.+.(webm)$/),
                p = t.match(/(?:www\.|\/\/)facebook\.com\/([^\/]+)\/videos\/([0-9]+)/);

            if (n && 11 === n[1].length) {
              var m = n[1],
                  v = 0;

              if (void 0 !== n[2]) {
                var g = n[2].match(/^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/);
                if (g) for (var b = [3600, 60, 1], y = 0, k = b.length; y < k; y++) {
                  v += void 0 !== g[y + 1] ? b[y] * parseInt(g[y + 1], 10) : 0;
                }
              }

              e = i()("<iframe>").attr("frameborder", 0).attr("src", "//www.youtube.com/embed/" + m + (v > 0 ? "?start=" + v : "")).attr("width", "640").attr("height", "360");
            } else if (o && o[0].length) e = i()("<iframe>").attr("frameborder", 0).attr("src", "https://instagram.com/p/" + o[1] + "/embed/").attr("width", "612").attr("height", "710").attr("scrolling", "no").attr("allowtransparency", "true");else if (r && r[0].length) e = i()("<iframe>").attr("frameborder", 0).attr("src", r[0] + "/embed/simple").attr("width", "600").attr("height", "600").attr("class", "vine-embed");else if (a && a[3].length) e = i()("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("src", "//player.vimeo.com/video/" + a[3]).attr("width", "640").attr("height", "360");else if (s && s[2].length) e = i()("<iframe>").attr("frameborder", 0).attr("src", "//www.dailymotion.com/embed/video/" + s[2]).attr("width", "640").attr("height", "360");else if (l && l[1].length) e = i()("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("height", "498").attr("width", "510").attr("src", "//player.youku.com/embed/" + l[1]);else if (c && c[1].length || u && u[2].length) {
              var w = c && c[1].length ? c[1] : u[2];
              e = i()("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("height", "310").attr("width", "500").attr("src", "https://v.qq.com/txp/iframe/player.html?vid=" + w + "&amp;auto=0");
            } else if (d || h || f) e = i()("<video controls>").attr("src", t).attr("width", "640").attr("height", "360");else {
              if (!p || !p[0].length) return !1;
              e = i()("<iframe>").attr("frameborder", 0).attr("src", "https://www.facebook.com/plugins/video.php?href=" + encodeURIComponent(p[0]) + "&show_text=0&width=560").attr("width", "560").attr("height", "301").attr("scrolling", "no").attr("allowtransparency", "true");
            }

            return e.addClass("note-video-clip"), e[0];
          }
        }, {
          key: "show",
          value: function value() {
            var t = this,
                e = this.context.invoke("editor.getSelectedText");
            this.context.invoke("editor.saveRange"), this.showVideoDialog(e).then(function (e) {
              t.ui.hideDialog(t.$dialog), t.context.invoke("editor.restoreRange");
              var n = t.createVideoNode(e);
              n && t.context.invoke("editor.insertNode", n);
            }).fail(function () {
              t.context.invoke("editor.restoreRange");
            });
          }
        }, {
          key: "showVideoDialog",
          value: function value() {
            var t = this;
            return i.a.Deferred(function (e) {
              var n = t.$dialog.find(".note-video-url"),
                  o = t.$dialog.find(".note-video-btn");
              t.ui.onDialogShown(t.$dialog, function () {
                t.context.triggerEvent("dialog.shown"), n.on("input paste propertychange", function () {
                  t.ui.toggleBtn(o, n.val());
                }), m.isSupportTouch || n.trigger("focus"), o.click(function (t) {
                  t.preventDefault(), e.resolve(n.val());
                }), t.bindEnterKey(n, o);
              }), t.ui.onDialogHidden(t.$dialog, function () {
                n.off(), o.off(), "pending" === e.state() && e.reject();
              }), t.ui.showDialog(t.$dialog);
            });
          }
        }]) && ke(e.prototype, n), o && ke(e, o), t;
      }();

      function Ce(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var xe = function () {
        function t(e) {
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.$body = i()(document.body), this.$editor = e.layoutInfo.editor, this.options = e.options, this.lang = this.options.langInfo;
        }

        var e, n, o;
        return e = t, (n = [{
          key: "initialize",
          value: function value() {
            var t = this.options.dialogsInBody ? this.$body : this.options.container,
                e = ['<p class="text-center">', '<a href="http://summernote.org/" target="_blank">Summernote 0.8.18</a>  ', '<a href="https://github.com/summernote/summernote" target="_blank">Project</a>  ', '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>', "</p>"].join("");
            this.$dialog = this.ui.dialog({
              title: this.lang.options.help,
              fade: this.options.dialogsFade,
              body: this.createShortcutList(),
              footer: e,
              callback: function callback(t) {
                t.find(".modal-body,.note-modal-body").css({
                  "max-height": 300,
                  overflow: "scroll"
                });
              }
            }).render().appendTo(t);
          }
        }, {
          key: "destroy",
          value: function value() {
            this.ui.hideDialog(this.$dialog), this.$dialog.remove();
          }
        }, {
          key: "createShortcutList",
          value: function value() {
            var t = this,
                e = this.options.keyMap[m.isMac ? "mac" : "pc"];
            return Object.keys(e).map(function (n) {
              var o = e[n],
                  r = i()('<div><div class="help-list-item"></div></div>');
              return r.append(i()("<label><kbd>" + n + "</kdb></label>").css({
                width: 180,
                "margin-right": 10
              })).append(i()("<span/>").html(t.context.memo("help." + o) || o)), r.html();
            }).join("");
          }
        }, {
          key: "showHelpDialog",
          value: function value() {
            var t = this;
            return i.a.Deferred(function (e) {
              t.ui.onDialogShown(t.$dialog, function () {
                t.context.triggerEvent("dialog.shown"), e.resolve();
              }), t.ui.showDialog(t.$dialog);
            }).promise();
          }
        }, {
          key: "show",
          value: function value() {
            var t = this;
            this.context.invoke("editor.saveRange"), this.showHelpDialog().then(function () {
              t.context.invoke("editor.restoreRange");
            });
          }
        }]) && Ce(e.prototype, n), o && Ce(e, o), t;
      }();

      function Se(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Te = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.options = e.options, this.hidable = !0, this.onContextmenu = !1, this.pageX = null, this.pageY = null, this.events = {
            "summernote.contextmenu": function summernoteContextmenu(t) {
              n.options.editing && (t.preventDefault(), t.stopPropagation(), n.onContextmenu = !0, n.update(!0));
            },
            "summernote.mousedown": function summernoteMousedown(t, e) {
              n.pageX = e.pageX, n.pageY = e.pageY;
            },
            "summernote.keyup summernote.mouseup summernote.scroll": function summernoteKeyupSummernoteMouseupSummernoteScroll(t, e) {
              n.options.editing && !n.onContextmenu && (n.pageX = e.pageX, n.pageY = e.pageY, n.update()), n.onContextmenu = !1;
            },
            "summernote.disable summernote.change summernote.dialog.shown summernote.blur": function summernoteDisableSummernoteChangeSummernoteDialogShownSummernoteBlur() {
              n.hide();
            },
            "summernote.focusout": function summernoteFocusout() {
              n.$popover.is(":active,:focus") || n.hide();
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return this.options.airMode && !C.isEmpty(this.options.popover.air);
          }
        }, {
          key: "initialize",
          value: function value() {
            var t = this;
            this.$popover = this.ui.popover({
              className: "note-air-popover"
            }).render().appendTo(this.options.container);
            var e = this.$popover.find(".popover-content");
            this.context.invoke("buttons.build", e, this.options.popover.air), this.$popover.on("mousedown", function () {
              t.hidable = !1;
            }), this.$popover.on("mouseup", function () {
              t.hidable = !0;
            });
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$popover.remove();
          }
        }, {
          key: "update",
          value: function value(t) {
            var e = this.context.invoke("editor.currentStyle");
            if (!e.range || e.range.isCollapsed() && !t) this.hide();else {
              var n = {
                left: this.pageX,
                top: this.pageY
              },
                  o = i()(this.options.container).offset();
              n.top -= o.top, n.left -= o.left, this.$popover.css({
                display: "block",
                left: Math.max(n.left, 0) + -5,
                top: n.top + 5
              }), this.context.invoke("buttons.updateCurrentStyle", this.$popover);
            }
          }
        }, {
          key: "updateCodeview",
          value: function value(t) {
            this.ui.toggleBtnActive(this.$popover.find(".btn-codeview"), t), t && this.hide();
          }
        }, {
          key: "hide",
          value: function value() {
            this.hidable && this.$popover.hide();
          }
        }]) && Se(e.prototype, n), o && Se(e, o), t;
      }();

      function Ee(t, e) {
        for (var n = 0; n < e.length; n++) {
          var o = e[n];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
        }
      }

      var Ie = function () {
        function t(e) {
          var n = this;
          !function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
          }(this, t), this.context = e, this.ui = i.a.summernote.ui, this.$editable = e.layoutInfo.editable, this.options = e.options, this.hint = this.options.hint || [], this.direction = this.options.hintDirection || "bottom", this.hints = Array.isArray(this.hint) ? this.hint : [this.hint], this.events = {
            "summernote.keyup": function summernoteKeyup(t, e) {
              e.isDefaultPrevented() || n.handleKeyup(e);
            },
            "summernote.keydown": function summernoteKeydown(t, e) {
              n.handleKeydown(e);
            },
            "summernote.disable summernote.dialog.shown summernote.blur": function summernoteDisableSummernoteDialogShownSummernoteBlur() {
              n.hide();
            }
          };
        }

        var e, n, o;
        return e = t, (n = [{
          key: "shouldInitialize",
          value: function value() {
            return this.hints.length > 0;
          }
        }, {
          key: "initialize",
          value: function value() {
            var t = this;
            this.lastWordRange = null, this.matchingWord = null, this.$popover = this.ui.popover({
              className: "note-hint-popover",
              hideArrow: !0,
              direction: ""
            }).render().appendTo(this.options.container), this.$popover.hide(), this.$content = this.$popover.find(".popover-content,.note-popover-content"), this.$content.on("click", ".note-hint-item", function (e) {
              t.$content.find(".active").removeClass("active"), i()(e.currentTarget).addClass("active"), t.replace();
            }), this.$popover.on("mousedown", function (t) {
              t.preventDefault();
            });
          }
        }, {
          key: "destroy",
          value: function value() {
            this.$popover.remove();
          }
        }, {
          key: "selectItem",
          value: function value(t) {
            this.$content.find(".active").removeClass("active"), t.addClass("active"), this.$content[0].scrollTop = t[0].offsetTop - this.$content.innerHeight() / 2;
          }
        }, {
          key: "moveDown",
          value: function value() {
            var t = this.$content.find(".note-hint-item.active"),
                e = t.next();
            if (e.length) this.selectItem(e);else {
              var n = t.parent().next();
              n.length || (n = this.$content.find(".note-hint-group").first()), this.selectItem(n.find(".note-hint-item").first());
            }
          }
        }, {
          key: "moveUp",
          value: function value() {
            var t = this.$content.find(".note-hint-item.active"),
                e = t.prev();
            if (e.length) this.selectItem(e);else {
              var n = t.parent().prev();
              n.length || (n = this.$content.find(".note-hint-group").last()), this.selectItem(n.find(".note-hint-item").last());
            }
          }
        }, {
          key: "replace",
          value: function value() {
            var t = this.$content.find(".note-hint-item.active");

            if (t.length) {
              var e = this.nodeFromItem(t);
              if (null !== this.matchingWord && 0 === this.matchingWord.length) this.lastWordRange.so = this.lastWordRange.eo;else if (null !== this.matchingWord && this.matchingWord.length > 0 && !this.lastWordRange.isCollapsed()) {
                var n = this.lastWordRange.eo - this.lastWordRange.so - this.matchingWord.length;
                n > 0 && (this.lastWordRange.so += n);
              }

              if (this.lastWordRange.insertNode(e), "next" === this.options.hintSelect) {
                var o = document.createTextNode("");
                i()(e).after(o), wt.createFromNodeBefore(o).select();
              } else wt.createFromNodeAfter(e).select();

              this.lastWordRange = null, this.hide(), this.context.invoke("editor.focus");
            }
          }
        }, {
          key: "nodeFromItem",
          value: function value(t) {
            var e = this.hints[t.data("index")],
                n = t.data("item"),
                o = e.content ? e.content(n) : n;
            return "string" == typeof o && (o = pt.createText(o)), o;
          }
        }, {
          key: "createItemTemplates",
          value: function value(t, e) {
            var n = this.hints[t];
            return e.map(function (e) {
              var o = i()('<div class="note-hint-item"/>');
              return o.append(n.template ? n.template(e) : e + ""), o.data({
                index: t,
                item: e
              }), o;
            });
          }
        }, {
          key: "handleKeydown",
          value: function value(t) {
            this.$popover.is(":visible") && (t.keyCode === xt.code.ENTER ? (t.preventDefault(), this.replace()) : t.keyCode === xt.code.UP ? (t.preventDefault(), this.moveUp()) : t.keyCode === xt.code.DOWN && (t.preventDefault(), this.moveDown()));
          }
        }, {
          key: "searchKeyword",
          value: function value(t, e, n) {
            var o = this.hints[t];

            if (o && o.match.test(e) && o.search) {
              var i = o.match.exec(e);
              this.matchingWord = i[0], o.search(i[1], n);
            } else n();
          }
        }, {
          key: "createGroup",
          value: function value(t, e) {
            var n = this,
                o = i()('<div class="note-hint-group note-hint-group-' + t + '"></div>');
            return this.searchKeyword(t, e, function (e) {
              (e = e || []).length && (o.html(n.createItemTemplates(t, e)), n.show());
            }), o;
          }
        }, {
          key: "handleKeyup",
          value: function value(t) {
            var e = this;

            if (!C.contains([xt.code.ENTER, xt.code.UP, xt.code.DOWN], t.keyCode)) {
              var n,
                  o,
                  r = this.context.invoke("editor.getLastRange");

              if ("words" === this.options.hintMode) {
                if (n = r.getWordsRange(r), o = n.toString(), this.hints.forEach(function (t) {
                  if (t.match.test(o)) return n = r.getWordsMatchRange(t.match), !1;
                }), !n) return void this.hide();
                o = n.toString();
              } else n = r.getWordRange(), o = n.toString();

              if (this.hints.length && o) {
                this.$content.empty();
                var a = g.rect2bnd(C.last(n.getClientRects())),
                    s = i()(this.options.container).offset();
                a && (a.top -= s.top, a.left -= s.left, this.$popover.hide(), this.lastWordRange = n, this.hints.forEach(function (t, n) {
                  t.match.test(o) && e.createGroup(n, o).appendTo(e.$content);
                }), this.$content.find(".note-hint-item:first").addClass("active"), "top" === this.direction ? this.$popover.css({
                  left: a.left,
                  top: a.top - this.$popover.outerHeight() - 5
                }) : this.$popover.css({
                  left: a.left,
                  top: a.top + a.height + 5
                }));
              } else this.hide();
            }
          }
        }, {
          key: "show",
          value: function value() {
            this.$popover.show();
          }
        }, {
          key: "hide",
          value: function value() {
            this.$popover.hide();
          }
        }]) && Ee(e.prototype, n), o && Ee(e, o), t;
      }();

      i.a.summernote = i.a.extend(i.a.summernote, {
        version: "0.8.18",
        plugins: {},
        dom: pt,
        range: wt,
        lists: C,
        options: {
          langInfo: i.a.summernote.lang["en-US"],
          editing: !0,
          modules: {
            editor: Ht,
            clipboard: Bt,
            dropzone: Ot,
            codeview: Kt,
            statusbar: Vt,
            fullscreen: Gt,
            handle: Zt,
            hintPopover: Ie,
            autoLink: Jt,
            autoSync: ee,
            autoReplace: oe,
            placeholder: re,
            buttons: se,
            toolbar: ce,
            linkDialog: de,
            linkPopover: fe,
            imageDialog: me,
            imagePopover: ge,
            tablePopover: ye,
            videoDialog: we,
            helpDialog: xe,
            airPopover: Te
          },
          buttons: {},
          lang: "en-US",
          followingToolbar: !1,
          toolbarPosition: "top",
          otherStaticBar: "",
          codeviewKeepButton: !1,
          toolbar: [["style", ["style"]], ["font", ["bold", "underline", "clear"]], ["fontname", ["fontname"]], ["color", ["color"]], ["para", ["ul", "ol", "paragraph"]], ["table", ["table"]], ["insert", ["link", "picture", "video"]], ["view", ["fullscreen", "codeview", "help"]]],
          popatmouse: !0,
          popover: {
            image: [["resize", ["resizeFull", "resizeHalf", "resizeQuarter", "resizeNone"]], ["float", ["floatLeft", "floatRight", "floatNone"]], ["remove", ["removeMedia"]]],
            link: [["link", ["linkDialogShow", "unlink"]]],
            table: [["add", ["addRowDown", "addRowUp", "addColLeft", "addColRight"]], ["delete", ["deleteRow", "deleteCol", "deleteTable"]]],
            air: [["color", ["color"]], ["font", ["bold", "underline", "clear"]], ["para", ["ul", "paragraph"]], ["table", ["table"]], ["insert", ["link", "picture"]], ["view", ["fullscreen", "codeview"]]]
          },
          airMode: !1,
          overrideContextMenu: !1,
          width: null,
          height: null,
          linkTargetBlank: !0,
          useProtocol: !0,
          defaultProtocol: "http://",
          focus: !1,
          tabDisabled: !1,
          tabSize: 4,
          styleWithCSS: !1,
          shortcuts: !0,
          textareaAutoSync: !0,
          tooltip: "auto",
          container: null,
          maxTextLength: 0,
          blockquoteBreakingLevel: 2,
          spellCheck: !0,
          disableGrammar: !1,
          placeholder: null,
          inheritPlaceholder: !1,
          recordEveryKeystroke: !1,
          historyLimit: 200,
          showDomainOnlyForAutolink: !1,
          hintMode: "word",
          hintSelect: "after",
          hintDirection: "bottom",
          styleTags: ["p", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6"],
          fontNames: ["Arial", "Arial Black", "Comic Sans MS", "Courier New", "Helvetica Neue", "Helvetica", "Impact", "Lucida Grande", "Tahoma", "Times New Roman", "Verdana"],
          fontNamesIgnoreCheck: [],
          addDefaultFonts: !0,
          fontSizes: ["8", "9", "10", "11", "12", "14", "18", "24", "36"],
          fontSizeUnits: ["px", "pt"],
          colors: [["#000000", "#424242", "#636363", "#9C9C94", "#CEC6CE", "#EFEFEF", "#F7F7F7", "#FFFFFF"], ["#FF0000", "#FF9C00", "#FFFF00", "#00FF00", "#00FFFF", "#0000FF", "#9C00FF", "#FF00FF"], ["#F7C6CE", "#FFE7CE", "#FFEFC6", "#D6EFD6", "#CEDEE7", "#CEE7F7", "#D6D6E7", "#E7D6DE"], ["#E79C9C", "#FFC69C", "#FFE79C", "#B5D6A5", "#A5C6CE", "#9CC6EF", "#B5A5D6", "#D6A5BD"], ["#E76363", "#F7AD6B", "#FFD663", "#94BD7B", "#73A5AD", "#6BADDE", "#8C7BC6", "#C67BA5"], ["#CE0000", "#E79439", "#EFC631", "#6BA54A", "#4A7B8C", "#3984C6", "#634AA5", "#A54A7B"], ["#9C0000", "#B56308", "#BD9400", "#397B21", "#104A5A", "#085294", "#311873", "#731842"], ["#630000", "#7B3900", "#846300", "#295218", "#083139", "#003163", "#21104A", "#4A1031"]],
          colorsName: [["Black", "Tundora", "Dove Gray", "Star Dust", "Pale Slate", "Gallery", "Alabaster", "White"], ["Red", "Orange Peel", "Yellow", "Green", "Cyan", "Blue", "Electric Violet", "Magenta"], ["Azalea", "Karry", "Egg White", "Zanah", "Botticelli", "Tropical Blue", "Mischka", "Twilight"], ["Tonys Pink", "Peach Orange", "Cream Brulee", "Sprout", "Casper", "Perano", "Cold Purple", "Careys Pink"], ["Mandy", "Rajah", "Dandelion", "Olivine", "Gulf Stream", "Viking", "Blue Marguerite", "Puce"], ["Guardsman Red", "Fire Bush", "Golden Dream", "Chelsea Cucumber", "Smalt Blue", "Boston Blue", "Butterfly Bush", "Cadillac"], ["Sangria", "Mai Tai", "Buddha Gold", "Forest Green", "Eden", "Venice Blue", "Meteorite", "Claret"], ["Rosewood", "Cinnamon", "Olive", "Parsley", "Tiber", "Midnight Blue", "Valentino", "Loulou"]],
          colorButton: {
            foreColor: "#000000",
            backColor: "#FFFF00"
          },
          lineHeights: ["1.0", "1.2", "1.4", "1.5", "1.6", "1.8", "2.0", "3.0"],
          tableClassName: "table table-bordered",
          insertTableMaxSize: {
            col: 10,
            row: 10
          },
          dialogsInBody: !1,
          dialogsFade: !1,
          maximumImageFileSize: null,
          callbacks: {
            onBeforeCommand: null,
            onBlur: null,
            onBlurCodeview: null,
            onChange: null,
            onChangeCodeview: null,
            onDialogShown: null,
            onEnter: null,
            onFocus: null,
            onImageLinkInsert: null,
            onImageUpload: null,
            onImageUploadError: null,
            onInit: null,
            onKeydown: null,
            onKeyup: null,
            onMousedown: null,
            onMouseup: null,
            onPaste: null,
            onScroll: null
          },
          codemirror: {
            mode: "text/html",
            htmlMode: !0,
            lineNumbers: !0
          },
          codeviewFilter: !1,
          codeviewFilterRegex: /<\/*(?:applet|b(?:ase|gsound|link)|embed|frame(?:set)?|ilayer|l(?:ayer|ink)|meta|object|s(?:cript|tyle)|t(?:itle|extarea)|xml)[^>]*?>/gi,
          codeviewIframeFilter: !0,
          codeviewIframeWhitelistSrc: [],
          codeviewIframeWhitelistSrcBase: ["www.youtube.com", "www.youtube-nocookie.com", "www.facebook.com", "vine.co", "instagram.com", "player.vimeo.com", "www.dailymotion.com", "player.youku.com", "v.qq.com"],
          keyMap: {
            pc: {
              ESC: "escape",
              ENTER: "insertParagraph",
              "CTRL+Z": "undo",
              "CTRL+Y": "redo",
              TAB: "tab",
              "SHIFT+TAB": "untab",
              "CTRL+B": "bold",
              "CTRL+I": "italic",
              "CTRL+U": "underline",
              "CTRL+SHIFT+S": "strikethrough",
              "CTRL+BACKSLASH": "removeFormat",
              "CTRL+SHIFT+L": "justifyLeft",
              "CTRL+SHIFT+E": "justifyCenter",
              "CTRL+SHIFT+R": "justifyRight",
              "CTRL+SHIFT+J": "justifyFull",
              "CTRL+SHIFT+NUM7": "insertUnorderedList",
              "CTRL+SHIFT+NUM8": "insertOrderedList",
              "CTRL+LEFTBRACKET": "outdent",
              "CTRL+RIGHTBRACKET": "indent",
              "CTRL+NUM0": "formatPara",
              "CTRL+NUM1": "formatH1",
              "CTRL+NUM2": "formatH2",
              "CTRL+NUM3": "formatH3",
              "CTRL+NUM4": "formatH4",
              "CTRL+NUM5": "formatH5",
              "CTRL+NUM6": "formatH6",
              "CTRL+ENTER": "insertHorizontalRule",
              "CTRL+K": "linkDialog.show"
            },
            mac: {
              ESC: "escape",
              ENTER: "insertParagraph",
              "CMD+Z": "undo",
              "CMD+SHIFT+Z": "redo",
              TAB: "tab",
              "SHIFT+TAB": "untab",
              "CMD+B": "bold",
              "CMD+I": "italic",
              "CMD+U": "underline",
              "CMD+SHIFT+S": "strikethrough",
              "CMD+BACKSLASH": "removeFormat",
              "CMD+SHIFT+L": "justifyLeft",
              "CMD+SHIFT+E": "justifyCenter",
              "CMD+SHIFT+R": "justifyRight",
              "CMD+SHIFT+J": "justifyFull",
              "CMD+SHIFT+NUM7": "insertUnorderedList",
              "CMD+SHIFT+NUM8": "insertOrderedList",
              "CMD+LEFTBRACKET": "outdent",
              "CMD+RIGHTBRACKET": "indent",
              "CMD+NUM0": "formatPara",
              "CMD+NUM1": "formatH1",
              "CMD+NUM2": "formatH2",
              "CMD+NUM3": "formatH3",
              "CMD+NUM4": "formatH4",
              "CMD+NUM5": "formatH5",
              "CMD+NUM6": "formatH6",
              "CMD+ENTER": "insertHorizontalRule",
              "CMD+K": "linkDialog.show"
            }
          },
          icons: {
            align: "note-icon-align",
            alignCenter: "note-icon-align-center",
            alignJustify: "note-icon-align-justify",
            alignLeft: "note-icon-align-left",
            alignRight: "note-icon-align-right",
            rowBelow: "note-icon-row-below",
            colBefore: "note-icon-col-before",
            colAfter: "note-icon-col-after",
            rowAbove: "note-icon-row-above",
            rowRemove: "note-icon-row-remove",
            colRemove: "note-icon-col-remove",
            indent: "note-icon-align-indent",
            outdent: "note-icon-align-outdent",
            arrowsAlt: "note-icon-arrows-alt",
            bold: "note-icon-bold",
            caret: "note-icon-caret",
            circle: "note-icon-circle",
            close: "note-icon-close",
            code: "note-icon-code",
            eraser: "note-icon-eraser",
            floatLeft: "note-icon-float-left",
            floatRight: "note-icon-float-right",
            font: "note-icon-font",
            frame: "note-icon-frame",
            italic: "note-icon-italic",
            link: "note-icon-link",
            unlink: "note-icon-chain-broken",
            magic: "note-icon-magic",
            menuCheck: "note-icon-menu-check",
            minus: "note-icon-minus",
            orderedlist: "note-icon-orderedlist",
            pencil: "note-icon-pencil",
            picture: "note-icon-picture",
            question: "note-icon-question",
            redo: "note-icon-redo",
            rollback: "note-icon-rollback",
            square: "note-icon-square",
            strikethrough: "note-icon-strikethrough",
            subscript: "note-icon-subscript",
            superscript: "note-icon-superscript",
            table: "note-icon-table",
            textHeight: "note-icon-text-height",
            trash: "note-icon-trash",
            underline: "note-icon-underline",
            undo: "note-icon-undo",
            unorderedlist: "note-icon-unorderedlist",
            video: "note-icon-video"
          }
        }
      });
    },
    5: function _(t, e, n) {},
    53: function _(t, e, n) {
      "use strict";

      n.r(e);
      var o = n(0),
          i = n.n(o),
          r = n(1);

      function a(t) {
        return (a = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
          return _typeof(t);
        } : function (t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : _typeof(t);
        })(t);
      }

      var s = r.a.create('<div class="note-editor note-frame card"/>'),
          l = r.a.create('<div class="note-toolbar card-header" role="toolbar"/>'),
          c = r.a.create('<div class="note-editing-area"/>'),
          u = r.a.create('<textarea class="note-codable" aria-multiline="true"/>'),
          d = r.a.create('<div class="note-editable card-block" contentEditable="true" role="textbox" aria-multiline="true"/>'),
          h = r.a.create(['<output class="note-status-output" role="status" aria-live="polite"></output>', '<div class="note-statusbar" role="status">', '<div class="note-resizebar" aria-label="Resize">', '<div class="note-icon-bar"></div>', '<div class="note-icon-bar"></div>', '<div class="note-icon-bar"></div>', "</div>", "</div>"].join("")),
          f = r.a.create('<div class="note-editor note-airframe"/>'),
          p = r.a.create(['<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"></div>', '<output class="note-status-output" role="status" aria-live="polite"></output>'].join("")),
          m = r.a.create('<div class="note-btn-group btn-group">'),
          v = r.a.create('<div class="note-dropdown-menu dropdown-menu" role="list">', function (t, e) {
        var n = Array.isArray(e.items) ? e.items.map(function (t) {
          var n = "string" == typeof t ? t : t.value || "",
              o = e.template ? e.template(t) : t,
              i = "object" === a(t) ? t.option : void 0;
          return '<a class="dropdown-item" href="#" ' + ('data-value="' + n + '"' + (void 0 !== i ? ' data-option="' + i + '"' : "")) + ' role="listitem" aria-label="' + n + '">' + o + "</a>";
        }).join("") : e.items;
        t.html(n).attr({
          "aria-label": e.title
        }), e && e.codeviewKeepButton && t.addClass("note-codeview-keep");
      }),
          g = function g(t) {
        return t;
      },
          b = r.a.create('<div class="note-dropdown-menu dropdown-menu note-check" role="list">', function (t, e) {
        var n = Array.isArray(e.items) ? e.items.map(function (t) {
          var n = "string" == typeof t ? t : t.value || "",
              o = e.template ? e.template(t) : t;
          return '<a class="dropdown-item" href="#" data-value="' + n + '" role="listitem" aria-label="' + t + '">' + C(e.checkClassName) + " " + o + "</a>";
        }).join("") : e.items;
        t.html(n).attr({
          "aria-label": e.title
        }), e && e.codeviewKeepButton && t.addClass("note-codeview-keep");
      }),
          y = r.a.create('<div class="modal note-modal" aria-hidden="false" tabindex="-1" role="dialog"/>', function (t, e) {
        e.fade && t.addClass("fade"), t.attr({
          "aria-label": e.title
        }), t.html(['<div class="modal-dialog">', '<div class="modal-content">', e.title ? '<div class="modal-header"><h4 class="modal-title">' + e.title + '</h4><button type="button" class="close" data-dismiss="modal" aria-label="Close" aria-hidden="true">&times;</button></div>' : "", '<div class="modal-body">' + e.body + "</div>", e.footer ? '<div class="modal-footer">' + e.footer + "</div>" : "", "</div>", "</div>"].join(""));
      }),
          k = r.a.create(['<div class="note-popover popover in">', '<div class="arrow"></div>', '<div class="popover-content note-children-container"></div>', "</div>"].join(""), function (t, e) {
        var n = void 0 !== e.direction ? e.direction : "bottom";
        t.addClass(n), e.hideArrow && t.find(".arrow").hide();
      }),
          w = r.a.create('<div class="form-check"></div>', function (t, e) {
        t.html(['<label class="form-check-label"' + (e.id ? ' for="note-' + e.id + '"' : "") + ">", '<input type="checkbox" class="form-check-input"' + (e.id ? ' id="note-' + e.id + '"' : ""), e.checked ? " checked" : "", ' aria-label="' + (e.text ? e.text : "") + '"', ' aria-checked="' + (e.checked ? "true" : "false") + '"/>', " " + (e.text ? e.text : "") + "</label>"].join(""));
      }),
          C = function C(t, e) {
        return "<" + (e = e || "i") + ' class="' + t + '"></' + e + ">";
      },
          x = function x(t) {
        return {
          editor: s,
          toolbar: l,
          editingArea: c,
          codable: u,
          editable: d,
          statusbar: h,
          airEditor: f,
          airEditable: p,
          buttonGroup: m,
          dropdown: v,
          dropdownButtonContents: g,
          dropdownCheck: b,
          dialog: y,
          popover: k,
          icon: C,
          checkbox: w,
          options: t,
          palette: function palette(e, n) {
            return r.a.create('<div class="note-color-palette"/>', function (e, n) {
              for (var o = [], i = 0, r = n.colors.length; i < r; i++) {
                for (var a = n.eventName, s = n.colors[i], l = n.colorsName[i], c = [], u = 0, d = s.length; u < d; u++) {
                  var h = s[u],
                      f = l[u];
                  c.push(['<button type="button" class="note-color-btn"', 'style="background-color:', h, '" ', 'data-event="', a, '" ', 'data-value="', h, '" ', 'title="', f, '" ', 'aria-label="', f, '" ', 'data-toggle="button" tabindex="-1"></button>'].join(""));
                }

                o.push('<div class="note-color-row">' + c.join("") + "</div>");
              }

              e.html(o.join("")), n.tooltip && e.find(".note-color-btn").tooltip({
                container: n.container || t.container,
                trigger: "hover",
                placement: "bottom"
              });
            })(e, n);
          },
          button: function button(e, n) {
            return r.a.create('<button type="button" class="note-btn btn btn-light btn-sm" tabindex="-1">', function (e, n) {
              n && n.tooltip && e.attr({
                title: n.tooltip,
                "aria-label": n.tooltip
              }).tooltip({
                container: n.container || t.container,
                trigger: "hover",
                placement: "bottom"
              }).on("click", function (t) {
                i()(t.currentTarget).tooltip("hide");
              }), n && n.codeviewButton && e.addClass("note-codeview-keep");
            })(e, n);
          },
          toggleBtn: function toggleBtn(t, e) {
            t.toggleClass("disabled", !e), t.attr("disabled", !e);
          },
          toggleBtnActive: function toggleBtnActive(t, e) {
            t.toggleClass("active", e);
          },
          onDialogShown: function onDialogShown(t, e) {
            t.one("shown.bs.modal", e);
          },
          onDialogHidden: function onDialogHidden(t, e) {
            t.one("hidden.bs.modal", e);
          },
          showDialog: function showDialog(t) {
            t.modal("show");
          },
          hideDialog: function hideDialog(t) {
            t.modal("hide");
          },
          createLayout: function createLayout(e) {
            var n = (t.airMode ? f([c([u(), p()])]) : "bottom" === t.toolbarPosition ? s([c([u(), d()]), l(), h()]) : s([l(), c([u(), d()]), h()])).render();
            return n.insertAfter(e), {
              note: e,
              editor: n,
              toolbar: n.find(".note-toolbar"),
              editingArea: n.find(".note-editing-area"),
              editable: n.find(".note-editable"),
              codable: n.find(".note-codable"),
              statusbar: n.find(".note-statusbar")
            };
          },
          removeLayout: function removeLayout(t, e) {
            t.html(e.editable.html()), e.editor.remove(), t.show();
          }
        };
      };

      n(3), n(5);
      i.a.summernote = i.a.extend(i.a.summernote, {
        ui_template: x,
        "interface": "bs4"
      }), i.a.summernote.options.styleTags = ["p", {
        title: "Blockquote",
        tag: "blockquote",
        className: "blockquote",
        value: "blockquote"
      }, "pre", "h1", "h2", "h3", "h4", "h5", "h6"];
    }
  });
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./resources/assets/libs/sweetalert2/sweetalert2.js":
/*!**********************************************************!*\
  !*** ./resources/assets/libs/sweetalert2/sweetalert2.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(window,
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "/";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 109);
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "./node_modules/sweetalert2/dist/sweetalert2.js":
  /*!******************************************************!*\
    !*** ./node_modules/sweetalert2/dist/sweetalert2.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesSweetalert2DistSweetalert2Js(module, exports, __webpack_require__) {
    /*!
    * sweetalert2 v8.18.7
    * Released under the MIT License.
    */
    (function (global, factory) {
      true ? module.exports = factory() : undefined;
    })(this, function () {
      'use strict';

      function _typeof(obj) {
        if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
          _typeof = function _typeof(obj) {
            return _typeof2(obj);
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _construct(Parent, args, Class) {
        if (isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          };
        }

        return _construct.apply(null, arguments);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      var consolePrefix = 'SweetAlert2:';
      /**
       * Filter the unique values into a new array
       * @param arr
       */

      var uniqueArray = function uniqueArray(arr) {
        var result = [];

        for (var i = 0; i < arr.length; i++) {
          if (result.indexOf(arr[i]) === -1) {
            result.push(arr[i]);
          }
        }

        return result;
      };
      /**
       * Returns the array ob object values (Object.values isn't supported in IE11)
       * @param obj
       */


      var objectValues = function objectValues(obj) {
        return Object.keys(obj).map(function (key) {
          return obj[key];
        });
      };
      /**
       * Convert NodeList to Array
       * @param nodeList
       */


      var toArray = function toArray(nodeList) {
        return Array.prototype.slice.call(nodeList);
      };
      /**
       * Standardise console warnings
       * @param message
       */


      var warn = function warn(message) {
        console.warn("".concat(consolePrefix, " ").concat(message));
      };
      /**
       * Standardise console errors
       * @param message
       */


      var error = function error(message) {
        console.error("".concat(consolePrefix, " ").concat(message));
      };
      /**
       * Private global state for `warnOnce`
       * @type {Array}
       * @private
       */


      var previousWarnOnceMessages = [];
      /**
       * Show a console warning, but only if it hasn't already been shown
       * @param message
       */

      var warnOnce = function warnOnce(message) {
        if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {
          previousWarnOnceMessages.push(message);
          warn(message);
        }
      };
      /**
       * Show a one-time console warning about deprecated params/methods
       */


      var warnAboutDepreation = function warnAboutDepreation(deprecatedParam, useInstead) {
        warnOnce("\"".concat(deprecatedParam, "\" is deprecated and will be removed in the next major release. Please use \"").concat(useInstead, "\" instead."));
      };
      /**
       * If `arg` is a function, call it (with no arguments or context) and return the result.
       * Otherwise, just pass the value through
       * @param arg
       */


      var callIfFunction = function callIfFunction(arg) {
        return typeof arg === 'function' ? arg() : arg;
      };

      var isPromise = function isPromise(arg) {
        return arg && Promise.resolve(arg) === arg;
      };

      var DismissReason = Object.freeze({
        cancel: 'cancel',
        backdrop: 'backdrop',
        close: 'close',
        esc: 'esc',
        timer: 'timer'
      });

      var argsToParams = function argsToParams(args) {
        var params = {};

        switch (_typeof(args[0])) {
          case 'object':
            _extends(params, args[0]);

            break;

          default:
            ['title', 'html', 'type'].forEach(function (name, index) {
              switch (_typeof(args[index])) {
                case 'string':
                  params[name] = args[index];
                  break;

                case 'undefined':
                  break;

                default:
                  error("Unexpected type of ".concat(name, "! Expected \"string\", got ").concat(_typeof(args[index])));
              }
            });
        }

        return params;
      };

      var swalPrefix = 'swal2-';

      var prefix = function prefix(items) {
        var result = {};

        for (var i in items) {
          result[items[i]] = swalPrefix + items[i];
        }

        return result;
      };

      var swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'toast', 'toast-shown', 'toast-column', 'fade', 'show', 'hide', 'noanimation', 'close', 'title', 'header', 'content', 'actions', 'confirm', 'cancel', 'footer', 'icon', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl']);
      var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);
      var states = {
        previousBodyPadding: null
      };

      var hasClass = function hasClass(elem, className) {
        return elem.classList.contains(className);
      };

      var removeCustomClasses = function removeCustomClasses(elem) {
        toArray(elem.classList).forEach(function (className) {
          if (!(objectValues(swalClasses).indexOf(className) !== -1) && !(objectValues(iconTypes).indexOf(className) !== -1)) {
            elem.classList.remove(className);
          }
        });
      };

      var applyCustomClass = function applyCustomClass(elem, customClass, className) {
        removeCustomClasses(elem);

        if (customClass && customClass[className]) {
          if (typeof customClass[className] !== 'string' && !customClass[className].forEach) {
            return warn("Invalid type of customClass.".concat(className, "! Expected string or iterable object, got \"").concat(_typeof(customClass[className]), "\""));
          }

          addClass(elem, customClass[className]);
        }
      };

      function getInput(content, inputType) {
        if (!inputType) {
          return null;
        }

        switch (inputType) {
          case 'select':
          case 'textarea':
          case 'file':
            return getChildByClass(content, swalClasses[inputType]);

          case 'checkbox':
            return content.querySelector(".".concat(swalClasses.checkbox, " input"));

          case 'radio':
            return content.querySelector(".".concat(swalClasses.radio, " input:checked")) || content.querySelector(".".concat(swalClasses.radio, " input:first-child"));

          case 'range':
            return content.querySelector(".".concat(swalClasses.range, " input"));

          default:
            return getChildByClass(content, swalClasses.input);
        }
      }

      var focusInput = function focusInput(input) {
        input.focus(); // place cursor at end of text in text input

        if (input.type !== 'file') {
          // http://stackoverflow.com/a/2345915
          var val = input.value;
          input.value = '';
          input.value = val;
        }
      };

      var toggleClass = function toggleClass(target, classList, condition) {
        if (!target || !classList) {
          return;
        }

        if (typeof classList === 'string') {
          classList = classList.split(/\s+/).filter(Boolean);
        }

        classList.forEach(function (className) {
          if (target.forEach) {
            target.forEach(function (elem) {
              condition ? elem.classList.add(className) : elem.classList.remove(className);
            });
          } else {
            condition ? target.classList.add(className) : target.classList.remove(className);
          }
        });
      };

      var addClass = function addClass(target, classList) {
        toggleClass(target, classList, true);
      };

      var removeClass = function removeClass(target, classList) {
        toggleClass(target, classList, false);
      };

      var getChildByClass = function getChildByClass(elem, className) {
        for (var i = 0; i < elem.childNodes.length; i++) {
          if (hasClass(elem.childNodes[i], className)) {
            return elem.childNodes[i];
          }
        }
      };

      var applyNumericalStyle = function applyNumericalStyle(elem, property, value) {
        if (value || parseInt(value) === 0) {
          elem.style[property] = typeof value === 'number' ? value + 'px' : value;
        } else {
          elem.style.removeProperty(property);
        }
      };

      var show = function show(elem) {
        var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';
        elem.style.opacity = '';
        elem.style.display = display;
      };

      var hide = function hide(elem) {
        elem.style.opacity = '';
        elem.style.display = 'none';
      };

      var toggle = function toggle(elem, condition, display) {
        condition ? show(elem, display) : hide(elem);
      }; // borrowed from jquery $(elem).is(':visible') implementation


      var isVisible = function isVisible(elem) {
        return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
      };

      var isScrollable = function isScrollable(elem) {
        return !!(elem.scrollHeight > elem.clientHeight);
      }; // borrowed from https://stackoverflow.com/a/46352119


      var hasCssAnimation = function hasCssAnimation(elem) {
        var style = window.getComputedStyle(elem);
        var animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
        var transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
        return animDuration > 0 || transDuration > 0;
      };

      var contains = function contains(haystack, needle) {
        if (typeof haystack.contains === 'function') {
          return haystack.contains(needle);
        }
      };

      var getContainer = function getContainer() {
        return document.body.querySelector('.' + swalClasses.container);
      };

      var elementBySelector = function elementBySelector(selectorString) {
        var container = getContainer();
        return container ? container.querySelector(selectorString) : null;
      };

      var elementByClass = function elementByClass(className) {
        return elementBySelector('.' + className);
      };

      var getPopup = function getPopup() {
        return elementByClass(swalClasses.popup);
      };

      var getIcons = function getIcons() {
        var popup = getPopup();
        return toArray(popup.querySelectorAll('.' + swalClasses.icon));
      };

      var getIcon = function getIcon() {
        var visibleIcon = getIcons().filter(function (icon) {
          return isVisible(icon);
        });
        return visibleIcon.length ? visibleIcon[0] : null;
      };

      var getTitle = function getTitle() {
        return elementByClass(swalClasses.title);
      };

      var getContent = function getContent() {
        return elementByClass(swalClasses.content);
      };

      var getImage = function getImage() {
        return elementByClass(swalClasses.image);
      };

      var getProgressSteps = function getProgressSteps() {
        return elementByClass(swalClasses['progress-steps']);
      };

      var getValidationMessage = function getValidationMessage() {
        return elementByClass(swalClasses['validation-message']);
      };

      var getConfirmButton = function getConfirmButton() {
        return elementBySelector('.' + swalClasses.actions + ' .' + swalClasses.confirm);
      };

      var getCancelButton = function getCancelButton() {
        return elementBySelector('.' + swalClasses.actions + ' .' + swalClasses.cancel);
      };

      var getActions = function getActions() {
        return elementByClass(swalClasses.actions);
      };

      var getHeader = function getHeader() {
        return elementByClass(swalClasses.header);
      };

      var getFooter = function getFooter() {
        return elementByClass(swalClasses.footer);
      };

      var getCloseButton = function getCloseButton() {
        return elementByClass(swalClasses.close);
      }; // https://github.com/jkup/focusable/blob/master/index.js


      var focusable = "\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n";

      var getFocusableElements = function getFocusableElements() {
        var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')) // sort according to tabindex
        .sort(function (a, b) {
          a = parseInt(a.getAttribute('tabindex'));
          b = parseInt(b.getAttribute('tabindex'));

          if (a > b) {
            return 1;
          } else if (a < b) {
            return -1;
          }

          return 0;
        });
        var otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(function (el) {
          return el.getAttribute('tabindex') !== '-1';
        });
        return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {
          return isVisible(el);
        });
      };

      var isModal = function isModal() {
        return !isToast() && !document.body.classList.contains(swalClasses['no-backdrop']);
      };

      var isToast = function isToast() {
        return document.body.classList.contains(swalClasses['toast-shown']);
      };

      var isLoading = function isLoading() {
        return getPopup().hasAttribute('data-loading');
      }; // Detect Node env


      var isNodeEnv = function isNodeEnv() {
        return typeof window === 'undefined' || typeof document === 'undefined';
      };

      var sweetHTML = "\n <div aria-labelledby=\"".concat(swalClasses.title, "\" aria-describedby=\"").concat(swalClasses.content, "\" class=\"").concat(swalClasses.popup, "\" tabindex=\"-1\">\n   <div class=\"").concat(swalClasses.header, "\">\n     <ul class=\"").concat(swalClasses['progress-steps'], "\"></ul>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.error, "\">\n       <span class=\"swal2-x-mark\"><span class=\"swal2-x-mark-line-left\"></span><span class=\"swal2-x-mark-line-right\"></span></span>\n     </div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.question, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.warning, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.info, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.success, "\">\n       <div class=\"swal2-success-circular-line-left\"></div>\n       <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n       <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n       <div class=\"swal2-success-circular-line-right\"></div>\n     </div>\n     <img class=\"").concat(swalClasses.image, "\" />\n     <h2 class=\"").concat(swalClasses.title, "\" id=\"").concat(swalClasses.title, "\"></h2>\n     <button type=\"button\" class=\"").concat(swalClasses.close, "\"></button>\n   </div>\n   <div class=\"").concat(swalClasses.content, "\">\n     <div id=\"").concat(swalClasses.content, "\"></div>\n     <input class=\"").concat(swalClasses.input, "\" />\n     <input type=\"file\" class=\"").concat(swalClasses.file, "\" />\n     <div class=\"").concat(swalClasses.range, "\">\n       <input type=\"range\" />\n       <output></output>\n     </div>\n     <select class=\"").concat(swalClasses.select, "\"></select>\n     <div class=\"").concat(swalClasses.radio, "\"></div>\n     <label for=\"").concat(swalClasses.checkbox, "\" class=\"").concat(swalClasses.checkbox, "\">\n       <input type=\"checkbox\" />\n       <span class=\"").concat(swalClasses.label, "\"></span>\n     </label>\n     <textarea class=\"").concat(swalClasses.textarea, "\"></textarea>\n     <div class=\"").concat(swalClasses['validation-message'], "\" id=\"").concat(swalClasses['validation-message'], "\"></div>\n   </div>\n   <div class=\"").concat(swalClasses.actions, "\">\n     <button type=\"button\" class=\"").concat(swalClasses.confirm, "\">OK</button>\n     <button type=\"button\" class=\"").concat(swalClasses.cancel, "\">Cancel</button>\n   </div>\n   <div class=\"").concat(swalClasses.footer, "\">\n   </div>\n </div>\n").replace(/(^|\n)\s*/g, '');

      var resetOldContainer = function resetOldContainer() {
        var oldContainer = getContainer();

        if (!oldContainer) {
          return;
        }

        oldContainer.parentNode.removeChild(oldContainer);
        removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
      };

      var oldInputVal; // IE11 workaround, see #1109 for details

      var resetValidationMessage = function resetValidationMessage(e) {
        if (Swal.isVisible() && oldInputVal !== e.target.value) {
          Swal.resetValidationMessage();
        }

        oldInputVal = e.target.value;
      };

      var addInputChangeListeners = function addInputChangeListeners() {
        var content = getContent();
        var input = getChildByClass(content, swalClasses.input);
        var file = getChildByClass(content, swalClasses.file);
        var range = content.querySelector(".".concat(swalClasses.range, " input"));
        var rangeOutput = content.querySelector(".".concat(swalClasses.range, " output"));
        var select = getChildByClass(content, swalClasses.select);
        var checkbox = content.querySelector(".".concat(swalClasses.checkbox, " input"));
        var textarea = getChildByClass(content, swalClasses.textarea);
        input.oninput = resetValidationMessage;
        file.onchange = resetValidationMessage;
        select.onchange = resetValidationMessage;
        checkbox.onchange = resetValidationMessage;
        textarea.oninput = resetValidationMessage;

        range.oninput = function (e) {
          resetValidationMessage(e);
          rangeOutput.value = range.value;
        };

        range.onchange = function (e) {
          resetValidationMessage(e);
          range.nextSibling.value = range.value;
        };
      };

      var getTarget = function getTarget(target) {
        return typeof target === 'string' ? document.querySelector(target) : target;
      };

      var setupAccessibility = function setupAccessibility(params) {
        var popup = getPopup();
        popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
        popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');

        if (!params.toast) {
          popup.setAttribute('aria-modal', 'true');
        }
      };

      var setupRTL = function setupRTL(targetElement) {
        if (window.getComputedStyle(targetElement).direction === 'rtl') {
          addClass(getContainer(), swalClasses.rtl);
        }
      };
      /*
       * Add modal + backdrop to DOM
       */


      var init = function init(params) {
        // Clean up the old popup container if it exists
        resetOldContainer();
        /* istanbul ignore if */

        if (isNodeEnv()) {
          error('SweetAlert2 requires document to initialize');
          return;
        }

        var container = document.createElement('div');
        container.className = swalClasses.container;
        container.innerHTML = sweetHTML;
        var targetElement = getTarget(params.target);
        targetElement.appendChild(container);
        setupAccessibility(params);
        setupRTL(targetElement);
        addInputChangeListeners();
      };

      var parseHtmlToContainer = function parseHtmlToContainer(param, target) {
        // DOM element
        if (param instanceof HTMLElement) {
          target.appendChild(param); // JQuery element(s)
        } else if (_typeof(param) === 'object') {
          handleJqueryElem(target, param); // Plain string
        } else if (param) {
          target.innerHTML = param;
        }
      };

      var handleJqueryElem = function handleJqueryElem(target, elem) {
        target.innerHTML = '';

        if (0 in elem) {
          for (var i = 0; (i in elem); i++) {
            target.appendChild(elem[i].cloneNode(true));
          }
        } else {
          target.appendChild(elem.cloneNode(true));
        }
      };

      var animationEndEvent = function () {
        // Prevent run in Node env

        /* istanbul ignore if */
        if (isNodeEnv()) {
          return false;
        }

        var testEl = document.createElement('div');
        var transEndEventNames = {
          WebkitAnimation: 'webkitAnimationEnd',
          OAnimation: 'oAnimationEnd oanimationend',
          animation: 'animationend'
        };

        for (var i in transEndEventNames) {
          if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== 'undefined') {
            return transEndEventNames[i];
          }
        }

        return false;
      }(); // Measure width of scrollbar
      // https://github.com/twbs/bootstrap/blob/master/js/modal.js#L279-L286


      var measureScrollbar = function measureScrollbar() {
        var supportsTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints;

        if (supportsTouch) {
          return 0;
        }

        var scrollDiv = document.createElement('div');
        scrollDiv.style.width = '50px';
        scrollDiv.style.height = '50px';
        scrollDiv.style.overflow = 'scroll';
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      };

      var renderActions = function renderActions(instance, params) {
        var actions = getActions();
        var confirmButton = getConfirmButton();
        var cancelButton = getCancelButton(); // Actions (buttons) wrapper

        if (!params.showConfirmButton && !params.showCancelButton) {
          hide(actions);
        } // Custom class


        applyCustomClass(actions, params.customClass, 'actions'); // Render confirm button

        renderButton(confirmButton, 'confirm', params); // render Cancel Button

        renderButton(cancelButton, 'cancel', params);

        if (params.buttonsStyling) {
          handleButtonsStyling(confirmButton, cancelButton, params);
        } else {
          removeClass([confirmButton, cancelButton], swalClasses.styled);
          confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';
          cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';
        }

        if (params.reverseButtons) {
          confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
        }
      };

      function handleButtonsStyling(confirmButton, cancelButton, params) {
        addClass([confirmButton, cancelButton], swalClasses.styled); // Buttons background colors

        if (params.confirmButtonColor) {
          confirmButton.style.backgroundColor = params.confirmButtonColor;
        }

        if (params.cancelButtonColor) {
          cancelButton.style.backgroundColor = params.cancelButtonColor;
        } // Loading state


        var confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue('background-color');
        confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;
        confirmButton.style.borderRightColor = confirmButtonBackgroundColor;
      }

      function renderButton(button, buttonType, params) {
        toggle(button, params['showC' + buttonType.substring(1) + 'Button'], 'inline-block');
        button.innerHTML = params[buttonType + 'ButtonText']; // Set caption text

        button.setAttribute('aria-label', params[buttonType + 'ButtonAriaLabel']); // ARIA label
        // Add buttons custom classes

        button.className = swalClasses[buttonType];
        applyCustomClass(button, params.customClass, buttonType + 'Button');
        addClass(button, params[buttonType + 'ButtonClass']);
      }

      function handleBackdropParam(container, backdrop) {
        if (typeof backdrop === 'string') {
          container.style.background = backdrop;
        } else if (!backdrop) {
          addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
        }
      }

      function handlePositionParam(container, position) {
        if (position in swalClasses) {
          addClass(container, swalClasses[position]);
        } else {
          warn('The "position" parameter is not valid, defaulting to "center"');
          addClass(container, swalClasses.center);
        }
      }

      function handleGrowParam(container, grow) {
        if (grow && typeof grow === 'string') {
          var growClass = 'grow-' + grow;

          if (growClass in swalClasses) {
            addClass(container, swalClasses[growClass]);
          }
        }
      }

      var renderContainer = function renderContainer(instance, params) {
        var container = getContainer();

        if (!container) {
          return;
        }

        handleBackdropParam(container, params.backdrop);

        if (!params.backdrop && params.allowOutsideClick) {
          warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
        }

        handlePositionParam(container, params.position);
        handleGrowParam(container, params.grow); // Custom class

        applyCustomClass(container, params.customClass, 'container');

        if (params.customContainerClass) {
          // @deprecated
          addClass(container, params.customContainerClass);
        }
      };
      /**
       * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
       * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
       * This is the approach that Babel will probably take to implement private methods/fields
       *   https://github.com/tc39/proposal-private-methods
       *   https://github.com/babel/babel/pull/7555
       * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
       *   then we can use that language feature.
       */


      var privateProps = {
        promise: new WeakMap(),
        innerParams: new WeakMap(),
        domCache: new WeakMap()
      };
      var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];

      var renderInput = function renderInput(instance, params) {
        var content = getContent();
        var innerParams = privateProps.innerParams.get(instance);
        var rerender = !innerParams || params.input !== innerParams.input;
        inputTypes.forEach(function (inputType) {
          var inputClass = swalClasses[inputType];
          var inputContainer = getChildByClass(content, inputClass); // set attributes

          setAttributes(inputType, params.inputAttributes); // set class

          inputContainer.className = inputClass;

          if (rerender) {
            hide(inputContainer);
          }
        });

        if (params.input) {
          if (rerender) {
            showInput(params);
          } // set custom class


          setCustomClass(params);
        }
      };

      var showInput = function showInput(params) {
        if (!renderInputType[params.input]) {
          return error("Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"".concat(params.input, "\""));
        }

        var inputContainer = getInputContainer(params.input);
        var input = renderInputType[params.input](inputContainer, params);
        show(input); // input autofocus

        setTimeout(function () {
          focusInput(input);
        });
      };

      var removeAttributes = function removeAttributes(input) {
        for (var i = 0; i < input.attributes.length; i++) {
          var attrName = input.attributes[i].name;

          if (!(['type', 'value', 'style'].indexOf(attrName) !== -1)) {
            input.removeAttribute(attrName);
          }
        }
      };

      var setAttributes = function setAttributes(inputType, inputAttributes) {
        var input = getInput(getContent(), inputType);

        if (!input) {
          return;
        }

        removeAttributes(input);

        for (var attr in inputAttributes) {
          // Do not set a placeholder for <input type="range">
          // it'll crash Edge, #1298
          if (inputType === 'range' && attr === 'placeholder') {
            continue;
          }

          input.setAttribute(attr, inputAttributes[attr]);
        }
      };

      var setCustomClass = function setCustomClass(params) {
        var inputContainer = getInputContainer(params.input);

        if (params.inputClass) {
          addClass(inputContainer, params.inputClass);
        }

        if (params.customClass) {
          addClass(inputContainer, params.customClass.input);
        }
      };

      var setInputPlaceholder = function setInputPlaceholder(input, params) {
        if (!input.placeholder || params.inputPlaceholder) {
          input.placeholder = params.inputPlaceholder;
        }
      };

      var getInputContainer = function getInputContainer(inputType) {
        var inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
        return getChildByClass(getContent(), inputClass);
      };

      var renderInputType = {};

      renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = function (input, params) {
        if (typeof params.inputValue === 'string' || typeof params.inputValue === 'number') {
          input.value = params.inputValue;
        } else if (!isPromise(params.inputValue)) {
          warn("Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"".concat(_typeof(params.inputValue), "\""));
        }

        setInputPlaceholder(input, params);
        input.type = params.input;
        return input;
      };

      renderInputType.file = function (input, params) {
        setInputPlaceholder(input, params);
        return input;
      };

      renderInputType.range = function (range, params) {
        var rangeInput = range.querySelector('input');
        var rangeOutput = range.querySelector('output');
        rangeInput.value = params.inputValue;
        rangeInput.type = params.input;
        rangeOutput.value = params.inputValue;
        return range;
      };

      renderInputType.select = function (select, params) {
        select.innerHTML = '';

        if (params.inputPlaceholder) {
          var placeholder = document.createElement('option');
          placeholder.innerHTML = params.inputPlaceholder;
          placeholder.value = '';
          placeholder.disabled = true;
          placeholder.selected = true;
          select.appendChild(placeholder);
        }

        return select;
      };

      renderInputType.radio = function (radio) {
        radio.innerHTML = '';
        return radio;
      };

      renderInputType.checkbox = function (checkboxContainer, params) {
        var checkbox = getInput(getContent(), 'checkbox');
        checkbox.value = 1;
        checkbox.id = swalClasses.checkbox;
        checkbox.checked = Boolean(params.inputValue);
        var label = checkboxContainer.querySelector('span');
        label.innerHTML = params.inputPlaceholder;
        return checkboxContainer;
      };

      renderInputType.textarea = function (textarea, params) {
        textarea.value = params.inputValue;
        setInputPlaceholder(textarea, params);

        if ('MutationObserver' in window) {
          // #1699
          var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
          var popupPadding = parseInt(window.getComputedStyle(getPopup()).paddingLeft) + parseInt(window.getComputedStyle(getPopup()).paddingRight);

          var outputsize = function outputsize() {
            var contentWidth = textarea.offsetWidth + popupPadding;

            if (contentWidth > initialPopupWidth) {
              getPopup().style.width = contentWidth + 'px';
            } else {
              getPopup().style.width = null;
            }
          };

          new MutationObserver(outputsize).observe(textarea, {
            attributes: true,
            attributeFilter: ['style']
          });
        }

        return textarea;
      };

      var renderContent = function renderContent(instance, params) {
        var content = getContent().querySelector('#' + swalClasses.content); // Content as HTML

        if (params.html) {
          parseHtmlToContainer(params.html, content);
          show(content, 'block'); // Content as plain text
        } else if (params.text) {
          content.textContent = params.text;
          show(content, 'block'); // No content
        } else {
          hide(content);
        }

        renderInput(instance, params); // Custom class

        applyCustomClass(getContent(), params.customClass, 'content');
      };

      var renderFooter = function renderFooter(instance, params) {
        var footer = getFooter();
        toggle(footer, params.footer);

        if (params.footer) {
          parseHtmlToContainer(params.footer, footer);
        } // Custom class


        applyCustomClass(footer, params.customClass, 'footer');
      };

      var renderCloseButton = function renderCloseButton(instance, params) {
        var closeButton = getCloseButton();
        closeButton.innerHTML = params.closeButtonHtml; // Custom class

        applyCustomClass(closeButton, params.customClass, 'closeButton');
        toggle(closeButton, params.showCloseButton);
        closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);
      };

      var renderIcon = function renderIcon(instance, params) {
        var innerParams = privateProps.innerParams.get(instance); // if the icon with the given type already rendered,
        // apply the custom class without re-rendering the icon

        if (innerParams && params.type === innerParams.type && getIcon()) {
          applyCustomClass(getIcon(), params.customClass, 'icon');
          return;
        }

        hideAllIcons();

        if (!params.type) {
          return;
        }

        adjustSuccessIconBackgoundColor();

        if (Object.keys(iconTypes).indexOf(params.type) !== -1) {
          var icon = elementBySelector(".".concat(swalClasses.icon, ".").concat(iconTypes[params.type]));
          show(icon); // Custom class

          applyCustomClass(icon, params.customClass, 'icon'); // Animate icon

          toggleClass(icon, "swal2-animate-".concat(params.type, "-icon"), params.animation);
        } else {
          error("Unknown type! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"".concat(params.type, "\""));
        }
      };

      var hideAllIcons = function hideAllIcons() {
        var icons = getIcons();

        for (var i = 0; i < icons.length; i++) {
          hide(icons[i]);
        }
      }; // Adjust success icon background color to match the popup background color


      var adjustSuccessIconBackgoundColor = function adjustSuccessIconBackgoundColor() {
        var popup = getPopup();
        var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
        var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');

        for (var i = 0; i < successIconParts.length; i++) {
          successIconParts[i].style.backgroundColor = popupBackgroundColor;
        }
      };

      var renderImage = function renderImage(instance, params) {
        var image = getImage();

        if (!params.imageUrl) {
          return hide(image);
        }

        show(image); // Src, alt

        image.setAttribute('src', params.imageUrl);
        image.setAttribute('alt', params.imageAlt); // Width, height

        applyNumericalStyle(image, 'width', params.imageWidth);
        applyNumericalStyle(image, 'height', params.imageHeight); // Class

        image.className = swalClasses.image;
        applyCustomClass(image, params.customClass, 'image');

        if (params.imageClass) {
          addClass(image, params.imageClass);
        }
      };

      var createStepElement = function createStepElement(step) {
        var stepEl = document.createElement('li');
        addClass(stepEl, swalClasses['progress-step']);
        stepEl.innerHTML = step;
        return stepEl;
      };

      var createLineElement = function createLineElement(params) {
        var lineEl = document.createElement('li');
        addClass(lineEl, swalClasses['progress-step-line']);

        if (params.progressStepsDistance) {
          lineEl.style.width = params.progressStepsDistance;
        }

        return lineEl;
      };

      var renderProgressSteps = function renderProgressSteps(instance, params) {
        var progressStepsContainer = getProgressSteps();

        if (!params.progressSteps || params.progressSteps.length === 0) {
          return hide(progressStepsContainer);
        }

        show(progressStepsContainer);
        progressStepsContainer.innerHTML = '';
        var currentProgressStep = parseInt(params.currentProgressStep === null ? Swal.getQueueStep() : params.currentProgressStep);

        if (currentProgressStep >= params.progressSteps.length) {
          warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
        }

        params.progressSteps.forEach(function (step, index) {
          var stepEl = createStepElement(step);
          progressStepsContainer.appendChild(stepEl);

          if (index === currentProgressStep) {
            addClass(stepEl, swalClasses['active-progress-step']);
          }

          if (index !== params.progressSteps.length - 1) {
            var lineEl = createLineElement(step);
            progressStepsContainer.appendChild(lineEl);
          }
        });
      };

      var renderTitle = function renderTitle(instance, params) {
        var title = getTitle();
        toggle(title, params.title || params.titleText);

        if (params.title) {
          parseHtmlToContainer(params.title, title);
        }

        if (params.titleText) {
          title.innerText = params.titleText;
        } // Custom class


        applyCustomClass(title, params.customClass, 'title');
      };

      var renderHeader = function renderHeader(instance, params) {
        var header = getHeader(); // Custom class

        applyCustomClass(header, params.customClass, 'header'); // Progress steps

        renderProgressSteps(instance, params); // Icon

        renderIcon(instance, params); // Image

        renderImage(instance, params); // Title

        renderTitle(instance, params); // Close button

        renderCloseButton(instance, params);
      };

      var renderPopup = function renderPopup(instance, params) {
        var popup = getPopup(); // Width

        applyNumericalStyle(popup, 'width', params.width); // Padding

        applyNumericalStyle(popup, 'padding', params.padding); // Background

        if (params.background) {
          popup.style.background = params.background;
        } // Default Class


        popup.className = swalClasses.popup;

        if (params.toast) {
          addClass([document.documentElement, document.body], swalClasses['toast-shown']);
          addClass(popup, swalClasses.toast);
        } else {
          addClass(popup, swalClasses.modal);
        } // Custom class


        applyCustomClass(popup, params.customClass, 'popup');

        if (typeof params.customClass === 'string') {
          addClass(popup, params.customClass);
        } // CSS animation


        toggleClass(popup, swalClasses.noanimation, !params.animation);
      };

      var render = function render(instance, params) {
        renderPopup(instance, params);
        renderContainer(instance, params);
        renderHeader(instance, params);
        renderContent(instance, params);
        renderActions(instance, params);
        renderFooter(instance, params);

        if (typeof params.onRender === 'function') {
          params.onRender(getPopup());
        }
      };
      /*
       * Global function to determine if SweetAlert2 popup is shown
       */


      var isVisible$1 = function isVisible$$1() {
        return isVisible(getPopup());
      };
      /*
       * Global function to click 'Confirm' button
       */


      var clickConfirm = function clickConfirm() {
        return getConfirmButton() && getConfirmButton().click();
      };
      /*
       * Global function to click 'Cancel' button
       */


      var clickCancel = function clickCancel() {
        return getCancelButton() && getCancelButton().click();
      };

      function fire() {
        var Swal = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _construct(Swal, args);
      }
      /**
       * Returns an extended version of `Swal` containing `params` as defaults.
       * Useful for reusing Swal configuration.
       *
       * For example:
       *
       * Before:
       * const textPromptOptions = { input: 'text', showCancelButton: true }
       * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
       * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
       *
       * After:
       * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
       * const {value: firstName} = await TextPrompt('What is your first name?')
       * const {value: lastName} = await TextPrompt('What is your last name?')
       *
       * @param mixinParams
       */


      function mixin(mixinParams) {
        var MixinSwal = /*#__PURE__*/function (_this) {
          _inherits(MixinSwal, _this);

          function MixinSwal() {
            _classCallCheck(this, MixinSwal);

            return _possibleConstructorReturn(this, _getPrototypeOf(MixinSwal).apply(this, arguments));
          }

          _createClass(MixinSwal, [{
            key: "_main",
            value: function _main(params) {
              return _get(_getPrototypeOf(MixinSwal.prototype), "_main", this).call(this, _extends({}, mixinParams, params));
            }
          }]);

          return MixinSwal;
        }(this);

        return MixinSwal;
      } // private global state for the queue feature


      var currentSteps = [];
      /*
       * Global function for chaining sweetAlert popups
       */

      var queue = function queue(steps) {
        var Swal = this;
        currentSteps = steps;

        var resetAndResolve = function resetAndResolve(resolve, value) {
          currentSteps = [];
          document.body.removeAttribute('data-swal2-queue-step');
          resolve(value);
        };

        var queueResult = [];
        return new Promise(function (resolve) {
          (function step(i, callback) {
            if (i < currentSteps.length) {
              document.body.setAttribute('data-swal2-queue-step', i);
              Swal.fire(currentSteps[i]).then(function (result) {
                if (typeof result.value !== 'undefined') {
                  queueResult.push(result.value);
                  step(i + 1, callback);
                } else {
                  resetAndResolve(resolve, {
                    dismiss: result.dismiss
                  });
                }
              });
            } else {
              resetAndResolve(resolve, {
                value: queueResult
              });
            }
          })(0);
        });
      };
      /*
       * Global function for getting the index of current popup in queue
       */


      var getQueueStep = function getQueueStep() {
        return document.body.getAttribute('data-swal2-queue-step');
      };
      /*
       * Global function for inserting a popup to the queue
       */


      var insertQueueStep = function insertQueueStep(step, index) {
        if (index && index < currentSteps.length) {
          return currentSteps.splice(index, 0, step);
        }

        return currentSteps.push(step);
      };
      /*
       * Global function for deleting a popup from the queue
       */


      var deleteQueueStep = function deleteQueueStep(index) {
        if (typeof currentSteps[index] !== 'undefined') {
          currentSteps.splice(index, 1);
        }
      };
      /**
       * Show spinner instead of Confirm button and disable Cancel button
       */


      var showLoading = function showLoading() {
        var popup = getPopup();

        if (!popup) {
          Swal.fire('');
        }

        popup = getPopup();
        var actions = getActions();
        var confirmButton = getConfirmButton();
        var cancelButton = getCancelButton();
        show(actions);
        show(confirmButton);
        addClass([popup, actions], swalClasses.loading);
        confirmButton.disabled = true;
        cancelButton.disabled = true;
        popup.setAttribute('data-loading', true);
        popup.setAttribute('aria-busy', true);
        popup.focus();
      };

      var RESTORE_FOCUS_TIMEOUT = 100;
      var globalState = {};

      var focusPreviousActiveElement = function focusPreviousActiveElement() {
        if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
          globalState.previousActiveElement.focus();
          globalState.previousActiveElement = null;
        } else if (document.body) {
          document.body.focus();
        }
      }; // Restore previous active (focused) element


      var restoreActiveElement = function restoreActiveElement() {
        return new Promise(function (resolve) {
          var x = window.scrollX;
          var y = window.scrollY;
          globalState.restoreFocusTimeout = setTimeout(function () {
            focusPreviousActiveElement();
            resolve();
          }, RESTORE_FOCUS_TIMEOUT); // issues/900

          if (typeof x !== 'undefined' && typeof y !== 'undefined') {
            // IE doesn't have scrollX/scrollY support
            window.scrollTo(x, y);
          }
        });
      };
      /**
       * If `timer` parameter is set, returns number of milliseconds of timer remained.
       * Otherwise, returns undefined.
       */


      var getTimerLeft = function getTimerLeft() {
        return globalState.timeout && globalState.timeout.getTimerLeft();
      };
      /**
       * Stop timer. Returns number of milliseconds of timer remained.
       * If `timer` parameter isn't set, returns undefined.
       */


      var stopTimer = function stopTimer() {
        return globalState.timeout && globalState.timeout.stop();
      };
      /**
       * Resume timer. Returns number of milliseconds of timer remained.
       * If `timer` parameter isn't set, returns undefined.
       */


      var resumeTimer = function resumeTimer() {
        return globalState.timeout && globalState.timeout.start();
      };
      /**
       * Resume timer. Returns number of milliseconds of timer remained.
       * If `timer` parameter isn't set, returns undefined.
       */


      var toggleTimer = function toggleTimer() {
        var timer = globalState.timeout;
        return timer && (timer.running ? timer.stop() : timer.start());
      };
      /**
       * Increase timer. Returns number of milliseconds of an updated timer.
       * If `timer` parameter isn't set, returns undefined.
       */


      var increaseTimer = function increaseTimer(n) {
        return globalState.timeout && globalState.timeout.increase(n);
      };
      /**
       * Check if timer is running. Returns true if timer is running
       * or false if timer is paused or stopped.
       * If `timer` parameter isn't set, returns undefined
       */


      var isTimerRunning = function isTimerRunning() {
        return globalState.timeout && globalState.timeout.isRunning();
      };

      var defaultParams = {
        title: '',
        titleText: '',
        text: '',
        html: '',
        footer: '',
        type: null,
        toast: false,
        customClass: '',
        customContainerClass: '',
        target: 'body',
        backdrop: true,
        animation: true,
        heightAuto: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        allowEnterKey: true,
        stopKeydownPropagation: true,
        keydownListenerCapture: false,
        showConfirmButton: true,
        showCancelButton: false,
        preConfirm: null,
        confirmButtonText: 'OK',
        confirmButtonAriaLabel: '',
        confirmButtonColor: null,
        confirmButtonClass: '',
        cancelButtonText: 'Cancel',
        cancelButtonAriaLabel: '',
        cancelButtonColor: null,
        cancelButtonClass: '',
        buttonsStyling: true,
        reverseButtons: false,
        focusConfirm: true,
        focusCancel: false,
        showCloseButton: false,
        closeButtonHtml: '&times;',
        closeButtonAriaLabel: 'Close this dialog',
        showLoaderOnConfirm: false,
        imageUrl: null,
        imageWidth: null,
        imageHeight: null,
        imageAlt: '',
        imageClass: '',
        timer: null,
        width: null,
        padding: null,
        background: null,
        input: null,
        inputPlaceholder: '',
        inputValue: '',
        inputOptions: {},
        inputAutoTrim: true,
        inputClass: '',
        inputAttributes: {},
        inputValidator: null,
        validationMessage: null,
        grow: false,
        position: 'center',
        progressSteps: [],
        currentProgressStep: null,
        progressStepsDistance: null,
        onBeforeOpen: null,
        onOpen: null,
        onRender: null,
        onClose: null,
        onAfterClose: null,
        scrollbarPadding: true
      };
      var updatableParams = ['title', 'titleText', 'text', 'html', 'type', 'customClass', 'showConfirmButton', 'showCancelButton', 'confirmButtonText', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonClass', 'cancelButtonText', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonClass', 'buttonsStyling', 'reverseButtons', 'imageUrl', 'imageWidth', 'imageHeigth', 'imageAlt', 'imageClass', 'progressSteps', 'currentProgressStep'];
      var deprecatedParams = {
        customContainerClass: 'customClass',
        confirmButtonClass: 'customClass',
        cancelButtonClass: 'customClass',
        imageClass: 'customClass',
        inputClass: 'customClass'
      };
      var toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusCancel', 'heightAuto', 'keydownListenerCapture'];
      /**
       * Is valid parameter
       * @param {String} paramName
       */

      var isValidParameter = function isValidParameter(paramName) {
        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
      };
      /**
       * Is valid parameter for Swal.update() method
       * @param {String} paramName
       */


      var isUpdatableParameter = function isUpdatableParameter(paramName) {
        return updatableParams.indexOf(paramName) !== -1;
      };
      /**
       * Is deprecated parameter
       * @param {String} paramName
       */


      var isDeprecatedParameter = function isDeprecatedParameter(paramName) {
        return deprecatedParams[paramName];
      };

      var checkIfParamIsValid = function checkIfParamIsValid(param) {
        if (!isValidParameter(param)) {
          warn("Unknown parameter \"".concat(param, "\""));
        }
      };

      var checkIfToastParamIsValid = function checkIfToastParamIsValid(param) {
        if (toastIncompatibleParams.indexOf(param) !== -1) {
          warn("The parameter \"".concat(param, "\" is incompatible with toasts"));
        }
      };

      var checkIfParamIsDeprecated = function checkIfParamIsDeprecated(param) {
        if (isDeprecatedParameter(param)) {
          warnAboutDepreation(param, isDeprecatedParameter(param));
        }
      };
      /**
       * Show relevant warnings for given params
       *
       * @param params
       */


      var showWarningsForParams = function showWarningsForParams(params) {
        for (var param in params) {
          checkIfParamIsValid(param);

          if (params.toast) {
            checkIfToastParamIsValid(param);
          }

          checkIfParamIsDeprecated();
        }
      };

      var staticMethods = Object.freeze({
        isValidParameter: isValidParameter,
        isUpdatableParameter: isUpdatableParameter,
        isDeprecatedParameter: isDeprecatedParameter,
        argsToParams: argsToParams,
        isVisible: isVisible$1,
        clickConfirm: clickConfirm,
        clickCancel: clickCancel,
        getContainer: getContainer,
        getPopup: getPopup,
        getTitle: getTitle,
        getContent: getContent,
        getImage: getImage,
        getIcon: getIcon,
        getIcons: getIcons,
        getCloseButton: getCloseButton,
        getActions: getActions,
        getConfirmButton: getConfirmButton,
        getCancelButton: getCancelButton,
        getHeader: getHeader,
        getFooter: getFooter,
        getFocusableElements: getFocusableElements,
        getValidationMessage: getValidationMessage,
        isLoading: isLoading,
        fire: fire,
        mixin: mixin,
        queue: queue,
        getQueueStep: getQueueStep,
        insertQueueStep: insertQueueStep,
        deleteQueueStep: deleteQueueStep,
        showLoading: showLoading,
        enableLoading: showLoading,
        getTimerLeft: getTimerLeft,
        stopTimer: stopTimer,
        resumeTimer: resumeTimer,
        toggleTimer: toggleTimer,
        increaseTimer: increaseTimer,
        isTimerRunning: isTimerRunning
      });
      /**
       * Enables buttons and hide loader.
       */

      function hideLoading() {
        var innerParams = privateProps.innerParams.get(this);
        var domCache = privateProps.domCache.get(this);

        if (!innerParams.showConfirmButton) {
          hide(domCache.confirmButton);

          if (!innerParams.showCancelButton) {
            hide(domCache.actions);
          }
        }

        removeClass([domCache.popup, domCache.actions], swalClasses.loading);
        domCache.popup.removeAttribute('aria-busy');
        domCache.popup.removeAttribute('data-loading');
        domCache.confirmButton.disabled = false;
        domCache.cancelButton.disabled = false;
      }

      function getInput$1(instance) {
        var innerParams = privateProps.innerParams.get(instance || this);
        var domCache = privateProps.domCache.get(instance || this);

        if (!domCache) {
          return null;
        }

        return getInput(domCache.content, innerParams.input);
      }

      var fixScrollbar = function fixScrollbar() {
        // for queues, do not do this more than once
        if (states.previousBodyPadding !== null) {
          return;
        } // if the body has overflow


        if (document.body.scrollHeight > window.innerHeight) {
          // add padding so the content doesn't shift after removal of scrollbar
          states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
          document.body.style.paddingRight = states.previousBodyPadding + measureScrollbar() + 'px';
        }
      };

      var undoScrollbar = function undoScrollbar() {
        if (states.previousBodyPadding !== null) {
          document.body.style.paddingRight = states.previousBodyPadding + 'px';
          states.previousBodyPadding = null;
        }
      };
      /* istanbul ignore next */


      var iOSfix = function iOSfix() {
        var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;

        if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
          var offset = document.body.scrollTop;
          document.body.style.top = offset * -1 + 'px';
          addClass(document.body, swalClasses.iosfix);
          lockBodyScroll();
        }
      };

      var lockBodyScroll = function lockBodyScroll() {
        // #1246
        var container = getContainer();
        var preventTouchMove;

        container.ontouchstart = function (e) {
          preventTouchMove = e.target === container || !isScrollable(container) && e.target.tagName !== 'INPUT' // #1603
          ;
        };

        container.ontouchmove = function (e) {
          if (preventTouchMove) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
      };
      /* istanbul ignore next */


      var undoIOSfix = function undoIOSfix() {
        if (hasClass(document.body, swalClasses.iosfix)) {
          var offset = parseInt(document.body.style.top, 10);
          removeClass(document.body, swalClasses.iosfix);
          document.body.style.top = '';
          document.body.scrollTop = offset * -1;
        }
      };

      var isIE11 = function isIE11() {
        return !!window.MSInputMethodContext && !!document.documentMode;
      }; // Fix IE11 centering sweetalert2/issues/933

      /* istanbul ignore next */


      var fixVerticalPositionIE = function fixVerticalPositionIE() {
        var container = getContainer();
        var popup = getPopup();
        container.style.removeProperty('align-items');

        if (popup.offsetTop < 0) {
          container.style.alignItems = 'flex-start';
        }
      };
      /* istanbul ignore next */


      var IEfix = function IEfix() {
        if (typeof window !== 'undefined' && isIE11()) {
          fixVerticalPositionIE();
          window.addEventListener('resize', fixVerticalPositionIE);
        }
      };
      /* istanbul ignore next */


      var undoIEfix = function undoIEfix() {
        if (typeof window !== 'undefined' && isIE11()) {
          window.removeEventListener('resize', fixVerticalPositionIE);
        }
      }; // Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
      // elements not within the active modal dialog will not be surfaced if a user opens a screen
      // readers list of elements (headings, form controls, landmarks, etc.) in the document.


      var setAriaHidden = function setAriaHidden() {
        var bodyChildren = toArray(document.body.children);
        bodyChildren.forEach(function (el) {
          if (el === getContainer() || contains(el, getContainer())) {
            return;
          }

          if (el.hasAttribute('aria-hidden')) {
            el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));
          }

          el.setAttribute('aria-hidden', 'true');
        });
      };

      var unsetAriaHidden = function unsetAriaHidden() {
        var bodyChildren = toArray(document.body.children);
        bodyChildren.forEach(function (el) {
          if (el.hasAttribute('data-previous-aria-hidden')) {
            el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));
            el.removeAttribute('data-previous-aria-hidden');
          } else {
            el.removeAttribute('aria-hidden');
          }
        });
      };
      /**
       * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
       * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
       * This is the approach that Babel will probably take to implement private methods/fields
       *   https://github.com/tc39/proposal-private-methods
       *   https://github.com/babel/babel/pull/7555
       * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
       *   then we can use that language feature.
       */


      var privateMethods = {
        swalPromiseResolve: new WeakMap()
      };
      /*
       * Instance method to close sweetAlert
       */

      function removePopupAndResetState(instance, container, isToast, onAfterClose) {
        if (isToast) {
          triggerOnAfterCloseAndDispose(instance, onAfterClose);
        } else {
          restoreActiveElement().then(function () {
            return triggerOnAfterCloseAndDispose(instance, onAfterClose);
          });
          globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
          });
          globalState.keydownHandlerAdded = false;
        }

        if (container.parentNode) {
          container.parentNode.removeChild(container);
        }

        if (isModal()) {
          undoScrollbar();
          undoIOSfix();
          undoIEfix();
          unsetAriaHidden();
        }

        removeBodyClasses();
      }

      function removeBodyClasses() {
        removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['toast-column']]);
      }

      function disposeSwal(instance) {
        // Unset this.params so GC will dispose it (#1569)
        delete instance.params; // Unset globalState props so GC will dispose globalState (#1569)

        delete globalState.keydownHandler;
        delete globalState.keydownTarget; // Unset WeakMaps so GC will be able to dispose them (#1569)

        unsetWeakMaps(privateProps);
        unsetWeakMaps(privateMethods);
      }

      function close(resolveValue) {
        var popup = getPopup();

        if (!popup || hasClass(popup, swalClasses.hide)) {
          return;
        }

        var innerParams = privateProps.innerParams.get(this);

        if (!innerParams) {
          return;
        }

        var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
        removeClass(popup, swalClasses.show);
        addClass(popup, swalClasses.hide);
        handlePopupAnimation(this, popup, innerParams); // Resolve Swal promise

        swalPromiseResolve(resolveValue || {});
      }

      var handlePopupAnimation = function handlePopupAnimation(instance, popup, innerParams) {
        var container = getContainer(); // If animation is supported, animate

        var animationIsSupported = animationEndEvent && hasCssAnimation(popup);
        var onClose = innerParams.onClose,
            onAfterClose = innerParams.onAfterClose;

        if (onClose !== null && typeof onClose === 'function') {
          onClose(popup);
        }

        if (animationIsSupported) {
          animatePopup(instance, popup, container, onAfterClose);
        } else {
          // Otherwise, remove immediately
          removePopupAndResetState(instance, container, isToast(), onAfterClose);
        }
      };

      var animatePopup = function animatePopup(instance, popup, container, onAfterClose) {
        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, isToast(), onAfterClose);
        popup.addEventListener(animationEndEvent, function (e) {
          if (e.target === popup) {
            globalState.swalCloseEventFinishedCallback();
            delete globalState.swalCloseEventFinishedCallback;
          }
        });
      };

      var unsetWeakMaps = function unsetWeakMaps(obj) {
        for (var i in obj) {
          obj[i] = new WeakMap();
        }
      };

      var triggerOnAfterCloseAndDispose = function triggerOnAfterCloseAndDispose(instance, onAfterClose) {
        setTimeout(function () {
          if (onAfterClose !== null && typeof onAfterClose === 'function') {
            onAfterClose();
          }

          if (!getPopup()) {
            disposeSwal(instance);
          }
        });
      };

      function setButtonsDisabled(instance, buttons, disabled) {
        var domCache = privateProps.domCache.get(instance);
        buttons.forEach(function (button) {
          domCache[button].disabled = disabled;
        });
      }

      function setInputDisabled(input, disabled) {
        if (!input) {
          return false;
        }

        if (input.type === 'radio') {
          var radiosContainer = input.parentNode.parentNode;
          var radios = radiosContainer.querySelectorAll('input');

          for (var i = 0; i < radios.length; i++) {
            radios[i].disabled = disabled;
          }
        } else {
          input.disabled = disabled;
        }
      }

      function enableButtons() {
        setButtonsDisabled(this, ['confirmButton', 'cancelButton'], false);
      }

      function disableButtons() {
        setButtonsDisabled(this, ['confirmButton', 'cancelButton'], true);
      } // @deprecated


      function enableConfirmButton() {
        warnAboutDepreation('Swal.enableConfirmButton()', "Swal.getConfirmButton().removeAttribute('disabled')");
        setButtonsDisabled(this, ['confirmButton'], false);
      } // @deprecated


      function disableConfirmButton() {
        warnAboutDepreation('Swal.disableConfirmButton()', "Swal.getConfirmButton().setAttribute('disabled', '')");
        setButtonsDisabled(this, ['confirmButton'], true);
      }

      function enableInput() {
        return setInputDisabled(this.getInput(), false);
      }

      function disableInput() {
        return setInputDisabled(this.getInput(), true);
      }

      function showValidationMessage(error) {
        var domCache = privateProps.domCache.get(this);
        domCache.validationMessage.innerHTML = error;
        var popupComputedStyle = window.getComputedStyle(domCache.popup);
        domCache.validationMessage.style.marginLeft = "-".concat(popupComputedStyle.getPropertyValue('padding-left'));
        domCache.validationMessage.style.marginRight = "-".concat(popupComputedStyle.getPropertyValue('padding-right'));
        show(domCache.validationMessage);
        var input = this.getInput();

        if (input) {
          input.setAttribute('aria-invalid', true);
          input.setAttribute('aria-describedBy', swalClasses['validation-message']);
          focusInput(input);
          addClass(input, swalClasses.inputerror);
        }
      } // Hide block with validation message


      function resetValidationMessage$1() {
        var domCache = privateProps.domCache.get(this);

        if (domCache.validationMessage) {
          hide(domCache.validationMessage);
        }

        var input = this.getInput();

        if (input) {
          input.removeAttribute('aria-invalid');
          input.removeAttribute('aria-describedBy');
          removeClass(input, swalClasses.inputerror);
        }
      }

      function getProgressSteps$1() {
        warnAboutDepreation('Swal.getProgressSteps()', "const swalInstance = Swal.fire({progressSteps: ['1', '2', '3']}); const progressSteps = swalInstance.params.progressSteps");
        var innerParams = privateProps.innerParams.get(this);
        return innerParams.progressSteps;
      }

      function setProgressSteps(progressSteps) {
        warnAboutDepreation('Swal.setProgressSteps()', 'Swal.update()');
        var innerParams = privateProps.innerParams.get(this);

        var updatedParams = _extends({}, innerParams, {
          progressSteps: progressSteps
        });

        renderProgressSteps(this, updatedParams);
        privateProps.innerParams.set(this, updatedParams);
      }

      function showProgressSteps() {
        var domCache = privateProps.domCache.get(this);
        show(domCache.progressSteps);
      }

      function hideProgressSteps() {
        var domCache = privateProps.domCache.get(this);
        hide(domCache.progressSteps);
      }

      var Timer = /*#__PURE__*/function () {
        function Timer(callback, delay) {
          _classCallCheck(this, Timer);

          this.callback = callback;
          this.remaining = delay;
          this.running = false;
          this.start();
        }

        _createClass(Timer, [{
          key: "start",
          value: function start() {
            if (!this.running) {
              this.running = true;
              this.started = new Date();
              this.id = setTimeout(this.callback, this.remaining);
            }

            return this.remaining;
          }
        }, {
          key: "stop",
          value: function stop() {
            if (this.running) {
              this.running = false;
              clearTimeout(this.id);
              this.remaining -= new Date() - this.started;
            }

            return this.remaining;
          }
        }, {
          key: "increase",
          value: function increase(n) {
            var running = this.running;

            if (running) {
              this.stop();
            }

            this.remaining += n;

            if (running) {
              this.start();
            }

            return this.remaining;
          }
        }, {
          key: "getTimerLeft",
          value: function getTimerLeft() {
            if (this.running) {
              this.stop();
              this.start();
            }

            return this.remaining;
          }
        }, {
          key: "isRunning",
          value: function isRunning() {
            return this.running;
          }
        }]);

        return Timer;
      }();

      var defaultInputValidators = {
        email: function email(string, validationMessage) {
          return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
        },
        url: function url(string, validationMessage) {
          // taken from https://stackoverflow.com/a/3809435 with a small change from #1306
          return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
        }
      };

      function setDefaultInputValidators(params) {
        // Use default `inputValidator` for supported input types if not provided
        if (!params.inputValidator) {
          Object.keys(defaultInputValidators).forEach(function (key) {
            if (params.input === key) {
              params.inputValidator = defaultInputValidators[key];
            }
          });
        }
      }

      function validateCustomTargetElement(params) {
        // Determine if the custom target element is valid
        if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
          warn('Target parameter is not valid, defaulting to "body"');
          params.target = 'body';
        }
      }
      /**
       * Set type, text and actions on popup
       *
       * @param params
       * @returns {boolean}
       */


      function setParameters(params) {
        setDefaultInputValidators(params); // showLoaderOnConfirm && preConfirm

        if (params.showLoaderOnConfirm && !params.preConfirm) {
          warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
        } // params.animation will be actually used in renderPopup.js
        // but in case when params.animation is a function, we need to call that function
        // before popup (re)initialization, so it'll be possible to check Swal.isVisible()
        // inside the params.animation function


        params.animation = callIfFunction(params.animation);
        validateCustomTargetElement(params); // Replace newlines with <br> in title

        if (typeof params.title === 'string') {
          params.title = params.title.split('\n').join('<br />');
        }

        init(params);
      }

      function swalOpenAnimationFinished(popup, container) {
        popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
        container.style.overflowY = 'auto';
      }
      /**
       * Open popup, add necessary classes and styles, fix scrollbar
       *
       * @param {Array} params
       */


      var openPopup = function openPopup(params) {
        var container = getContainer();
        var popup = getPopup();

        if (typeof params.onBeforeOpen === 'function') {
          params.onBeforeOpen(popup);
        }

        addClasses(container, popup, params); // scrolling is 'hidden' until animation is done, after that 'auto'

        setScrollingVisibility(container, popup);

        if (isModal()) {
          fixScrollContainer(container, params.scrollbarPadding);
        }

        if (!isToast() && !globalState.previousActiveElement) {
          globalState.previousActiveElement = document.activeElement;
        }

        if (typeof params.onOpen === 'function') {
          setTimeout(function () {
            return params.onOpen(popup);
          });
        }
      };

      var setScrollingVisibility = function setScrollingVisibility(container, popup) {
        if (animationEndEvent && hasCssAnimation(popup)) {
          container.style.overflowY = 'hidden';
          popup.addEventListener(animationEndEvent, swalOpenAnimationFinished.bind(null, popup, container));
        } else {
          container.style.overflowY = 'auto';
        }
      };

      var fixScrollContainer = function fixScrollContainer(container, scrollbarPadding) {
        iOSfix();
        IEfix();
        setAriaHidden();

        if (scrollbarPadding) {
          fixScrollbar();
        } // sweetalert2/issues/1247


        setTimeout(function () {
          container.scrollTop = 0;
        });
      };

      var addClasses = function addClasses(container, popup, params) {
        if (params.animation) {
          addClass(popup, swalClasses.show);
          addClass(container, swalClasses.fade);
        }

        show(popup);
        addClass([document.documentElement, document.body, container], swalClasses.shown);

        if (params.heightAuto && params.backdrop && !params.toast) {
          addClass([document.documentElement, document.body], swalClasses['height-auto']);
        }
      };

      var handleInputOptionsAndValue = function handleInputOptionsAndValue(instance, params) {
        if (params.input === 'select' || params.input === 'radio') {
          handleInputOptions(instance, params);
        } else if (['text', 'email', 'number', 'tel', 'textarea'].indexOf(params.input) !== -1 && isPromise(params.inputValue)) {
          handleInputValue(instance, params);
        }
      };

      var getInputValue = function getInputValue(instance, innerParams) {
        var input = instance.getInput();

        if (!input) {
          return null;
        }

        switch (innerParams.input) {
          case 'checkbox':
            return getCheckboxValue(input);

          case 'radio':
            return getRadioValue(input);

          case 'file':
            return getFileValue(input);

          default:
            return innerParams.inputAutoTrim ? input.value.trim() : input.value;
        }
      };

      var getCheckboxValue = function getCheckboxValue(input) {
        return input.checked ? 1 : 0;
      };

      var getRadioValue = function getRadioValue(input) {
        return input.checked ? input.value : null;
      };

      var getFileValue = function getFileValue(input) {
        return input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;
      };

      var handleInputOptions = function handleInputOptions(instance, params) {
        var content = getContent();

        var processInputOptions = function processInputOptions(inputOptions) {
          return populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);
        };

        if (isPromise(params.inputOptions)) {
          showLoading();
          params.inputOptions.then(function (inputOptions) {
            instance.hideLoading();
            processInputOptions(inputOptions);
          });
        } else if (_typeof(params.inputOptions) === 'object') {
          processInputOptions(params.inputOptions);
        } else {
          error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(params.inputOptions)));
        }
      };

      var handleInputValue = function handleInputValue(instance, params) {
        var input = instance.getInput();
        hide(input);
        params.inputValue.then(function (inputValue) {
          input.value = params.input === 'number' ? parseFloat(inputValue) || 0 : inputValue + '';
          show(input);
          input.focus();
          instance.hideLoading();
        })["catch"](function (err) {
          error('Error in inputValue promise: ' + err);
          input.value = '';
          show(input);
          input.focus();
          instance.hideLoading();
        });
      };

      var populateInputOptions = {
        select: function select(content, inputOptions, params) {
          var select = getChildByClass(content, swalClasses.select);
          inputOptions.forEach(function (inputOption) {
            var optionValue = inputOption[0];
            var optionLabel = inputOption[1];
            var option = document.createElement('option');
            option.value = optionValue;
            option.innerHTML = optionLabel;

            if (params.inputValue.toString() === optionValue.toString()) {
              option.selected = true;
            }

            select.appendChild(option);
          });
          select.focus();
        },
        radio: function radio(content, inputOptions, params) {
          var radio = getChildByClass(content, swalClasses.radio);
          inputOptions.forEach(function (inputOption) {
            var radioValue = inputOption[0];
            var radioLabel = inputOption[1];
            var radioInput = document.createElement('input');
            var radioLabelElement = document.createElement('label');
            radioInput.type = 'radio';
            radioInput.name = swalClasses.radio;
            radioInput.value = radioValue;

            if (params.inputValue.toString() === radioValue.toString()) {
              radioInput.checked = true;
            }

            var label = document.createElement('span');
            label.innerHTML = radioLabel;
            label.className = swalClasses.label;
            radioLabelElement.appendChild(radioInput);
            radioLabelElement.appendChild(label);
            radio.appendChild(radioLabelElement);
          });
          var radios = radio.querySelectorAll('input');

          if (radios.length) {
            radios[0].focus();
          }
        }
      };
      /**
       * Converts `inputOptions` into an array of `[value, label]`s
       * @param inputOptions
       */

      var formatInputOptions = function formatInputOptions(inputOptions) {
        var result = [];

        if (typeof Map !== 'undefined' && inputOptions instanceof Map) {
          inputOptions.forEach(function (value, key) {
            result.push([key, value]);
          });
        } else {
          Object.keys(inputOptions).forEach(function (key) {
            result.push([key, inputOptions[key]]);
          });
        }

        return result;
      };

      var handleConfirmButtonClick = function handleConfirmButtonClick(instance, innerParams) {
        instance.disableButtons();

        if (innerParams.input) {
          handleConfirmWithInput(instance, innerParams);
        } else {
          confirm(instance, innerParams, true);
        }
      };

      var handleCancelButtonClick = function handleCancelButtonClick(instance, dismissWith) {
        instance.disableButtons();
        dismissWith(DismissReason.cancel);
      };

      var handleConfirmWithInput = function handleConfirmWithInput(instance, innerParams) {
        var inputValue = getInputValue(instance, innerParams);

        if (innerParams.inputValidator) {
          instance.disableInput();
          var validationPromise = Promise.resolve().then(function () {
            return innerParams.inputValidator(inputValue, innerParams.validationMessage);
          });
          validationPromise.then(function (validationMessage) {
            instance.enableButtons();
            instance.enableInput();

            if (validationMessage) {
              instance.showValidationMessage(validationMessage);
            } else {
              confirm(instance, innerParams, inputValue);
            }
          });
        } else if (!instance.getInput().checkValidity()) {
          instance.enableButtons();
          instance.showValidationMessage(innerParams.validationMessage);
        } else {
          confirm(instance, innerParams, inputValue);
        }
      };

      var succeedWith = function succeedWith(instance, value) {
        instance.closePopup({
          value: value
        });
      };

      var confirm = function confirm(instance, innerParams, value) {
        if (innerParams.showLoaderOnConfirm) {
          showLoading(); // TODO: make showLoading an *instance* method
        }

        if (innerParams.preConfirm) {
          instance.resetValidationMessage();
          var preConfirmPromise = Promise.resolve().then(function () {
            return innerParams.preConfirm(value, innerParams.validationMessage);
          });
          preConfirmPromise.then(function (preConfirmValue) {
            if (isVisible(getValidationMessage()) || preConfirmValue === false) {
              instance.hideLoading();
            } else {
              succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
            }
          });
        } else {
          succeedWith(instance, value);
        }
      };

      var addKeydownHandler = function addKeydownHandler(instance, globalState, innerParams, dismissWith) {
        if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
          globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
          });
          globalState.keydownHandlerAdded = false;
        }

        if (!innerParams.toast) {
          globalState.keydownHandler = function (e) {
            return keydownHandler(instance, e, innerParams, dismissWith);
          };

          globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
          globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
          globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
          });
          globalState.keydownHandlerAdded = true;
        }
      }; // Focus handling


      var setFocus = function setFocus(innerParams, index, increment) {
        var focusableElements = getFocusableElements(); // search for visible elements and select the next possible match

        for (var i = 0; i < focusableElements.length; i++) {
          index = index + increment; // rollover to first item

          if (index === focusableElements.length) {
            index = 0; // go to last item
          } else if (index === -1) {
            index = focusableElements.length - 1;
          }

          return focusableElements[index].focus();
        } // no visible focusable elements, focus the popup


        getPopup().focus();
      };

      var arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down' // IE11
      ];
      var escKeys = ['Escape', 'Esc' // IE11
      ];

      var keydownHandler = function keydownHandler(instance, e, innerParams, dismissWith) {
        if (innerParams.stopKeydownPropagation) {
          e.stopPropagation();
        } // ENTER


        if (e.key === 'Enter') {
          handleEnter(instance, e, innerParams); // TAB
        } else if (e.key === 'Tab') {
          handleTab(e, innerParams); // ARROWS - switch focus between buttons
        } else if (arrowKeys.indexOf(e.key) !== -1) {
          handleArrows(); // ESC
        } else if (escKeys.indexOf(e.key) !== -1) {
          handleEsc(e, innerParams, dismissWith);
        }
      };

      var handleEnter = function handleEnter(instance, e, innerParams) {
        // #720 #721
        if (e.isComposing) {
          return;
        }

        if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {
          if (['textarea', 'file'].indexOf(innerParams.input) !== -1) {
            return; // do not submit
          }

          clickConfirm();
          e.preventDefault();
        }
      };

      var handleTab = function handleTab(e, innerParams) {
        var targetElement = e.target;
        var focusableElements = getFocusableElements();
        var btnIndex = -1;

        for (var i = 0; i < focusableElements.length; i++) {
          if (targetElement === focusableElements[i]) {
            btnIndex = i;
            break;
          }
        }

        if (!e.shiftKey) {
          // Cycle to the next button
          setFocus(innerParams, btnIndex, 1);
        } else {
          // Cycle to the prev button
          setFocus(innerParams, btnIndex, -1);
        }

        e.stopPropagation();
        e.preventDefault();
      };

      var handleArrows = function handleArrows() {
        var confirmButton = getConfirmButton();
        var cancelButton = getCancelButton(); // focus Cancel button if Confirm button is currently focused

        if (document.activeElement === confirmButton && isVisible(cancelButton)) {
          cancelButton.focus(); // and vice versa
        } else if (document.activeElement === cancelButton && isVisible(confirmButton)) {
          confirmButton.focus();
        }
      };

      var handleEsc = function handleEsc(e, innerParams, dismissWith) {
        if (callIfFunction(innerParams.allowEscapeKey)) {
          e.preventDefault();
          dismissWith(DismissReason.esc);
        }
      };

      var handlePopupClick = function handlePopupClick(domCache, innerParams, dismissWith) {
        if (innerParams.toast) {
          handleToastClick(domCache, innerParams, dismissWith);
        } else {
          // Ignore click events that had mousedown on the popup but mouseup on the container
          // This can happen when the user drags a slider
          handleModalMousedown(domCache); // Ignore click events that had mousedown on the container but mouseup on the popup

          handleContainerMousedown(domCache);
          handleModalClick(domCache, innerParams, dismissWith);
        }
      };

      var handleToastClick = function handleToastClick(domCache, innerParams, dismissWith) {
        // Closing toast by internal click
        domCache.popup.onclick = function () {
          if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {
            return;
          }

          dismissWith(DismissReason.close);
        };
      };

      var ignoreOutsideClick = false;

      var handleModalMousedown = function handleModalMousedown(domCache) {
        domCache.popup.onmousedown = function () {
          domCache.container.onmouseup = function (e) {
            domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't
            // have any other direct children aside of the popup

            if (e.target === domCache.container) {
              ignoreOutsideClick = true;
            }
          };
        };
      };

      var handleContainerMousedown = function handleContainerMousedown(domCache) {
        domCache.container.onmousedown = function () {
          domCache.popup.onmouseup = function (e) {
            domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup

            if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
              ignoreOutsideClick = true;
            }
          };
        };
      };

      var handleModalClick = function handleModalClick(domCache, innerParams, dismissWith) {
        domCache.container.onclick = function (e) {
          if (ignoreOutsideClick) {
            ignoreOutsideClick = false;
            return;
          }

          if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
            dismissWith(DismissReason.backdrop);
          }
        };
      };

      function _main(userParams) {
        showWarningsForParams(userParams); // Check if there is another Swal closing

        if (getPopup() && globalState.swalCloseEventFinishedCallback) {
          globalState.swalCloseEventFinishedCallback();
          delete globalState.swalCloseEventFinishedCallback;
        } // Check if there is a swal disposal defer timer


        if (globalState.deferDisposalTimer) {
          clearTimeout(globalState.deferDisposalTimer);
          delete globalState.deferDisposalTimer;
        }

        var innerParams = _extends({}, defaultParams, userParams);

        setParameters(innerParams);
        Object.freeze(innerParams); // clear the previous timer

        if (globalState.timeout) {
          globalState.timeout.stop();
          delete globalState.timeout;
        } // clear the restore focus timeout


        clearTimeout(globalState.restoreFocusTimeout);
        var domCache = populateDomCache(this);
        render(this, innerParams);
        privateProps.innerParams.set(this, innerParams);
        return swalPromise(this, domCache, innerParams);
      }

      var swalPromise = function swalPromise(instance, domCache, innerParams) {
        return new Promise(function (resolve) {
          // functions to handle all closings/dismissals
          var dismissWith = function dismissWith(dismiss) {
            instance.closePopup({
              dismiss: dismiss
            });
          };

          privateMethods.swalPromiseResolve.set(instance, resolve);
          setupTimer(globalState, innerParams, dismissWith);

          domCache.confirmButton.onclick = function () {
            return handleConfirmButtonClick(instance, innerParams);
          };

          domCache.cancelButton.onclick = function () {
            return handleCancelButtonClick(instance, dismissWith);
          };

          domCache.closeButton.onclick = function () {
            return dismissWith(DismissReason.close);
          };

          handlePopupClick(domCache, innerParams, dismissWith);
          addKeydownHandler(instance, globalState, innerParams, dismissWith);

          if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {
            addClass(document.body, swalClasses['toast-column']);
          } else {
            removeClass(document.body, swalClasses['toast-column']);
          }

          handleInputOptionsAndValue(instance, innerParams);
          openPopup(innerParams);
          initFocus(domCache, innerParams); // Scroll container to top on open (#1247)

          domCache.container.scrollTop = 0;
        });
      };

      var populateDomCache = function populateDomCache(instance) {
        var domCache = {
          popup: getPopup(),
          container: getContainer(),
          content: getContent(),
          actions: getActions(),
          confirmButton: getConfirmButton(),
          cancelButton: getCancelButton(),
          closeButton: getCloseButton(),
          validationMessage: getValidationMessage(),
          progressSteps: getProgressSteps()
        };
        privateProps.domCache.set(instance, domCache);
        return domCache;
      };

      var setupTimer = function setupTimer(globalState$$1, innerParams, dismissWith) {
        if (innerParams.timer) {
          globalState$$1.timeout = new Timer(function () {
            dismissWith('timer');
            delete globalState$$1.timeout;
          }, innerParams.timer);
        }
      };

      var initFocus = function initFocus(domCache, innerParams) {
        if (innerParams.toast) {
          return;
        }

        if (!callIfFunction(innerParams.allowEnterKey)) {
          return blurActiveElement();
        }

        if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
          return domCache.cancelButton.focus();
        }

        if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
          return domCache.confirmButton.focus();
        }

        setFocus(innerParams, -1, 1);
      };

      var blurActiveElement = function blurActiveElement() {
        if (document.activeElement && typeof document.activeElement.blur === 'function') {
          document.activeElement.blur();
        }
      };
      /**
       * Updates popup parameters.
       */


      function update(params) {
        var popup = getPopup();

        if (!popup || hasClass(popup, swalClasses.hide)) {
          return warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
        }

        var validUpdatableParams = {}; // assign valid params from `params` to `defaults`

        Object.keys(params).forEach(function (param) {
          if (Swal.isUpdatableParameter(param)) {
            validUpdatableParams[param] = params[param];
          } else {
            warn("Invalid parameter to update: \"".concat(param, "\". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js"));
          }
        });
        var innerParams = privateProps.innerParams.get(this);

        var updatedParams = _extends({}, innerParams, validUpdatableParams);

        render(this, updatedParams);
        privateProps.innerParams.set(this, updatedParams);
        Object.defineProperties(this, {
          params: {
            value: _extends({}, this.params, params),
            writable: false,
            enumerable: true
          }
        });
      }

      var instanceMethods = Object.freeze({
        hideLoading: hideLoading,
        disableLoading: hideLoading,
        getInput: getInput$1,
        close: close,
        closePopup: close,
        closeModal: close,
        closeToast: close,
        enableButtons: enableButtons,
        disableButtons: disableButtons,
        enableConfirmButton: enableConfirmButton,
        disableConfirmButton: disableConfirmButton,
        enableInput: enableInput,
        disableInput: disableInput,
        showValidationMessage: showValidationMessage,
        resetValidationMessage: resetValidationMessage$1,
        getProgressSteps: getProgressSteps$1,
        setProgressSteps: setProgressSteps,
        showProgressSteps: showProgressSteps,
        hideProgressSteps: hideProgressSteps,
        _main: _main,
        update: update
      });
      var currentInstance; // SweetAlert constructor

      function SweetAlert() {
        // Prevent run in Node env

        /* istanbul ignore if */
        if (typeof window === 'undefined') {
          return;
        } // Check for the existence of Promise

        /* istanbul ignore if */


        if (typeof Promise === 'undefined') {
          error('This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)');
        }

        currentInstance = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var outerParams = Object.freeze(this.constructor.argsToParams(args));
        Object.defineProperties(this, {
          params: {
            value: outerParams,
            writable: false,
            enumerable: true,
            configurable: true
          }
        });

        var promise = this._main(this.params);

        privateProps.promise.set(this, promise);
      } // `catch` cannot be the name of a module export, so we define our thenable methods here instead


      SweetAlert.prototype.then = function (onFulfilled) {
        var promise = privateProps.promise.get(this);
        return promise.then(onFulfilled);
      };

      SweetAlert.prototype["finally"] = function (onFinally) {
        var promise = privateProps.promise.get(this);
        return promise["finally"](onFinally);
      }; // Assign instance methods from src/instanceMethods/*.js to prototype


      _extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor


      _extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility


      Object.keys(instanceMethods).forEach(function (key) {
        SweetAlert[key] = function () {
          if (currentInstance) {
            var _currentInstance;

            return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
          }
        };
      });
      SweetAlert.DismissReason = DismissReason;
      SweetAlert.version = '8.18.7';
      var Swal = SweetAlert;
      Swal["default"] = Swal;
      return Swal;
    });

    if (typeof this !== 'undefined' && this.Sweetalert2) {
      this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2;
    }
    /***/

  },

  /***/
  "./resources/assets/vendor/libs/sweetalert2/sweetalert2.js":
  /*!*****************************************************************!*\
    !*** ./resources/assets/vendor/libs/sweetalert2/sweetalert2.js ***!
    \*****************************************************************/

  /*! exports provided: Swal */

  /***/
  function resourcesAssetsVendorLibsSweetalert2Sweetalert2Js(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Swal", function () {
      return Swal;
    });
    /* harmony import */


    var sweetalert2_dist_sweetalert2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! sweetalert2/dist/sweetalert2.js */
    "./node_modules/sweetalert2/dist/sweetalert2.js");
    /* harmony import */


    var sweetalert2_dist_sweetalert2_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sweetalert2_dist_sweetalert2_js__WEBPACK_IMPORTED_MODULE_0__);

    var Swal = sweetalert2_dist_sweetalert2_js__WEBPACK_IMPORTED_MODULE_0__["mixin"]({
      buttonsStyling: false,
      customClass: {
        confirmButton: 'btn btn-primary btn-lg',
        cancelButton: 'btn btn-default btn-lg'
      }
    });
    /***/
  },

  /***/
  109:
  /*!***********************************************************************!*\
    !*** multi ./resources/assets/vendor/libs/sweetalert2/sweetalert2.js ***!
    \***********************************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\xampp\htdocs\globalplanthire\resources\assets\vendor\libs\sweetalert2\sweetalert2.js */
    "./resources/assets/vendor/libs/sweetalert2/sweetalert2.js");
    /***/
  }
  /******/

}));

/***/ }),

/***/ "./resources/assets/libs/swiper/swiper.js":
/*!************************************************!*\
  !*** ./resources/assets/libs/swiper/swiper.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(window,
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) {
      __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
    }
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "/";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 110);
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "./node_modules/swiper/js/swiper.js":
  /*!******************************************!*\
    !*** ./node_modules/swiper/js/swiper.js ***!
    \******************************************/

  /*! no static exports found */

  /***/
  function node_modulesSwiperJsSwiperJs(module, exports, __webpack_require__) {
    /**
     * Swiper 5.1.0
     * Most modern mobile touch slider and framework with hardware accelerated transitions
     * http://swiperjs.com
     *
     * Copyright 2014-2019 Vladimir Kharlampidi
     *
     * Released under the MIT License
     *
     * Released on: October 16, 2019
     */
    (function (global, factory) {
      true ? module.exports = factory() : undefined;
    })(this, function () {
      'use strict';
      /**
       * SSR Window 1.0.1
       * Better handling for window object in SSR environment
       * https://github.com/nolimits4web/ssr-window
       *
       * Copyright 2018, Vladimir Kharlampidi
       *
       * Licensed under MIT
       *
       * Released on: July 18, 2018
       */

      var doc = typeof document === 'undefined' ? {
        body: {},
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        activeElement: {
          blur: function blur() {},
          nodeName: ''
        },
        querySelector: function querySelector() {
          return null;
        },
        querySelectorAll: function querySelectorAll() {
          return [];
        },
        getElementById: function getElementById() {
          return null;
        },
        createEvent: function createEvent() {
          return {
            initEvent: function initEvent() {}
          };
        },
        createElement: function createElement() {
          return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function setAttribute() {},
            getElementsByTagName: function getElementsByTagName() {
              return [];
            }
          };
        },
        location: {
          hash: ''
        }
      } : document; // eslint-disable-line

      var win = typeof window === 'undefined' ? {
        document: doc,
        navigator: {
          userAgent: ''
        },
        location: {},
        history: {},
        CustomEvent: function CustomEvent() {
          return this;
        },
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        getComputedStyle: function getComputedStyle() {
          return {
            getPropertyValue: function getPropertyValue() {
              return '';
            }
          };
        },
        Image: function Image() {},
        Date: function Date() {},
        screen: {},
        setTimeout: function setTimeout() {},
        clearTimeout: function clearTimeout() {}
      } : window; // eslint-disable-line

      /**
       * Dom7 2.1.3
       * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
       * http://framework7.io/docs/dom.html
       *
       * Copyright 2019, Vladimir Kharlampidi
       * The iDangero.us
       * http://www.idangero.us/
       *
       * Licensed under MIT
       *
       * Released on: February 11, 2019
       */

      var Dom7 = function Dom7(arr) {
        var self = this; // Create array-like object

        for (var i = 0; i < arr.length; i += 1) {
          self[i] = arr[i];
        }

        self.length = arr.length; // Return collection with methods

        return this;
      };

      function $(selector, context) {
        var arr = [];
        var i = 0;

        if (selector && !context) {
          if (selector instanceof Dom7) {
            return selector;
          }
        }

        if (selector) {
          // String
          if (typeof selector === 'string') {
            var els;
            var tempParent;
            var html = selector.trim();

            if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
              var toCreate = 'div';

              if (html.indexOf('<li') === 0) {
                toCreate = 'ul';
              }

              if (html.indexOf('<tr') === 0) {
                toCreate = 'tbody';
              }

              if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
                toCreate = 'tr';
              }

              if (html.indexOf('<tbody') === 0) {
                toCreate = 'table';
              }

              if (html.indexOf('<option') === 0) {
                toCreate = 'select';
              }

              tempParent = doc.createElement(toCreate);
              tempParent.innerHTML = html;

              for (i = 0; i < tempParent.childNodes.length; i += 1) {
                arr.push(tempParent.childNodes[i]);
              }
            } else {
              if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                // Pure ID selector
                els = [doc.getElementById(selector.trim().split('#')[1])];
              } else {
                // Other selectors
                els = (context || doc).querySelectorAll(selector.trim());
              }

              for (i = 0; i < els.length; i += 1) {
                if (els[i]) {
                  arr.push(els[i]);
                }
              }
            }
          } else if (selector.nodeType || selector === win || selector === doc) {
            // Node/element
            arr.push(selector);
          } else if (selector.length > 0 && selector[0].nodeType) {
            // Array of elements or instance of Dom
            for (i = 0; i < selector.length; i += 1) {
              arr.push(selector[i]);
            }
          }
        }

        return new Dom7(arr);
      }

      $.fn = Dom7.prototype;
      $.Class = Dom7;
      $.Dom7 = Dom7;

      function unique(arr) {
        var uniqueArray = [];

        for (var i = 0; i < arr.length; i += 1) {
          if (uniqueArray.indexOf(arr[i]) === -1) {
            uniqueArray.push(arr[i]);
          }
        }

        return uniqueArray;
      } // Classes and attributes


      function addClass(className) {
        if (typeof className === 'undefined') {
          return this;
        }

        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i += 1) {
          for (var j = 0; j < this.length; j += 1) {
            if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
              this[j].classList.add(classes[i]);
            }
          }
        }

        return this;
      }

      function removeClass(className) {
        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i += 1) {
          for (var j = 0; j < this.length; j += 1) {
            if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
              this[j].classList.remove(classes[i]);
            }
          }
        }

        return this;
      }

      function hasClass(className) {
        if (!this[0]) {
          return false;
        }

        return this[0].classList.contains(className);
      }

      function toggleClass(className) {
        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i += 1) {
          for (var j = 0; j < this.length; j += 1) {
            if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
              this[j].classList.toggle(classes[i]);
            }
          }
        }

        return this;
      }

      function attr(attrs, value) {
        var arguments$1 = arguments;

        if (arguments.length === 1 && typeof attrs === 'string') {
          // Get attr
          if (this[0]) {
            return this[0].getAttribute(attrs);
          }

          return undefined;
        } // Set attrs


        for (var i = 0; i < this.length; i += 1) {
          if (arguments$1.length === 2) {
            // String
            this[i].setAttribute(attrs, value);
          } else {
            // Object
            // eslint-disable-next-line
            for (var attrName in attrs) {
              this[i][attrName] = attrs[attrName];
              this[i].setAttribute(attrName, attrs[attrName]);
            }
          }
        }

        return this;
      } // eslint-disable-next-line


      function removeAttr(attr) {
        for (var i = 0; i < this.length; i += 1) {
          this[i].removeAttribute(attr);
        }

        return this;
      }

      function data(key, value) {
        var el;

        if (typeof value === 'undefined') {
          el = this[0]; // Get value

          if (el) {
            if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
              return el.dom7ElementDataStorage[key];
            }

            var dataKey = el.getAttribute("data-" + key);

            if (dataKey) {
              return dataKey;
            }

            return undefined;
          }

          return undefined;
        } // Set value


        for (var i = 0; i < this.length; i += 1) {
          el = this[i];

          if (!el.dom7ElementDataStorage) {
            el.dom7ElementDataStorage = {};
          }

          el.dom7ElementDataStorage[key] = value;
        }

        return this;
      } // Transforms
      // eslint-disable-next-line


      function transform(transform) {
        for (var i = 0; i < this.length; i += 1) {
          var elStyle = this[i].style;
          elStyle.webkitTransform = transform;
          elStyle.transform = transform;
        }

        return this;
      }

      function transition(duration) {
        if (typeof duration !== 'string') {
          duration = duration + "ms"; // eslint-disable-line
        }

        for (var i = 0; i < this.length; i += 1) {
          var elStyle = this[i].style;
          elStyle.webkitTransitionDuration = duration;
          elStyle.transitionDuration = duration;
        }

        return this;
      } // Events


      function on() {
        var assign;
        var args = [],
            len = arguments.length;

        while (len--) {
          args[len] = arguments[len];
        }

        var eventType = args[0];
        var targetSelector = args[1];
        var listener = args[2];
        var capture = args[3];

        if (typeof args[1] === 'function') {
          assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
          targetSelector = undefined;
        }

        if (!capture) {
          capture = false;
        }

        function handleLiveEvent(e) {
          var target = e.target;

          if (!target) {
            return;
          }

          var eventData = e.target.dom7EventData || [];

          if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
          }

          if ($(target).is(targetSelector)) {
            listener.apply(target, eventData);
          } else {
            var parents = $(target).parents(); // eslint-disable-line

            for (var k = 0; k < parents.length; k += 1) {
              if ($(parents[k]).is(targetSelector)) {
                listener.apply(parents[k], eventData);
              }
            }
          }
        }

        function handleEvent(e) {
          var eventData = e && e.target ? e.target.dom7EventData || [] : [];

          if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
          }

          listener.apply(this, eventData);
        }

        var events = eventType.split(' ');
        var j;

        for (var i = 0; i < this.length; i += 1) {
          var el = this[i];

          if (!targetSelector) {
            for (j = 0; j < events.length; j += 1) {
              var event = events[j];

              if (!el.dom7Listeners) {
                el.dom7Listeners = {};
              }

              if (!el.dom7Listeners[event]) {
                el.dom7Listeners[event] = [];
              }

              el.dom7Listeners[event].push({
                listener: listener,
                proxyListener: handleEvent
              });
              el.addEventListener(event, handleEvent, capture);
            }
          } else {
            // Live events
            for (j = 0; j < events.length; j += 1) {
              var event$1 = events[j];

              if (!el.dom7LiveListeners) {
                el.dom7LiveListeners = {};
              }

              if (!el.dom7LiveListeners[event$1]) {
                el.dom7LiveListeners[event$1] = [];
              }

              el.dom7LiveListeners[event$1].push({
                listener: listener,
                proxyListener: handleLiveEvent
              });
              el.addEventListener(event$1, handleLiveEvent, capture);
            }
          }
        }

        return this;
      }

      function off() {
        var assign;
        var args = [],
            len = arguments.length;

        while (len--) {
          args[len] = arguments[len];
        }

        var eventType = args[0];
        var targetSelector = args[1];
        var listener = args[2];
        var capture = args[3];

        if (typeof args[1] === 'function') {
          assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
          targetSelector = undefined;
        }

        if (!capture) {
          capture = false;
        }

        var events = eventType.split(' ');

        for (var i = 0; i < events.length; i += 1) {
          var event = events[i];

          for (var j = 0; j < this.length; j += 1) {
            var el = this[j];
            var handlers = void 0;

            if (!targetSelector && el.dom7Listeners) {
              handlers = el.dom7Listeners[event];
            } else if (targetSelector && el.dom7LiveListeners) {
              handlers = el.dom7LiveListeners[event];
            }

            if (handlers && handlers.length) {
              for (var k = handlers.length - 1; k >= 0; k -= 1) {
                var handler = handlers[k];

                if (listener && handler.listener === listener) {
                  el.removeEventListener(event, handler.proxyListener, capture);
                  handlers.splice(k, 1);
                } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                  el.removeEventListener(event, handler.proxyListener, capture);
                  handlers.splice(k, 1);
                } else if (!listener) {
                  el.removeEventListener(event, handler.proxyListener, capture);
                  handlers.splice(k, 1);
                }
              }
            }
          }
        }

        return this;
      }

      function trigger() {
        var args = [],
            len = arguments.length;

        while (len--) {
          args[len] = arguments[len];
        }

        var events = args[0].split(' ');
        var eventData = args[1];

        for (var i = 0; i < events.length; i += 1) {
          var event = events[i];

          for (var j = 0; j < this.length; j += 1) {
            var el = this[j];
            var evt = void 0;

            try {
              evt = new win.CustomEvent(event, {
                detail: eventData,
                bubbles: true,
                cancelable: true
              });
            } catch (e) {
              evt = doc.createEvent('Event');
              evt.initEvent(event, true, true);
              evt.detail = eventData;
            } // eslint-disable-next-line


            el.dom7EventData = args.filter(function (data, dataIndex) {
              return dataIndex > 0;
            });
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }

        return this;
      }

      function transitionEnd(callback) {
        var events = ['webkitTransitionEnd', 'transitionend'];
        var dom = this;
        var i;

        function fireCallBack(e) {
          /* jshint validthis:true */
          if (e.target !== this) {
            return;
          }

          callback.call(this, e);

          for (i = 0; i < events.length; i += 1) {
            dom.off(events[i], fireCallBack);
          }
        }

        if (callback) {
          for (i = 0; i < events.length; i += 1) {
            dom.on(events[i], fireCallBack);
          }
        }

        return this;
      }

      function outerWidth(includeMargins) {
        if (this.length > 0) {
          if (includeMargins) {
            // eslint-disable-next-line
            var styles = this.styles();
            return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
          }

          return this[0].offsetWidth;
        }

        return null;
      }

      function outerHeight(includeMargins) {
        if (this.length > 0) {
          if (includeMargins) {
            // eslint-disable-next-line
            var styles = this.styles();
            return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
          }

          return this[0].offsetHeight;
        }

        return null;
      }

      function offset() {
        if (this.length > 0) {
          var el = this[0];
          var box = el.getBoundingClientRect();
          var body = doc.body;
          var clientTop = el.clientTop || body.clientTop || 0;
          var clientLeft = el.clientLeft || body.clientLeft || 0;
          var scrollTop = el === win ? win.scrollY : el.scrollTop;
          var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
          return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
          };
        }

        return null;
      }

      function styles() {
        if (this[0]) {
          return win.getComputedStyle(this[0], null);
        }

        return {};
      }

      function css(props, value) {
        var i;

        if (arguments.length === 1) {
          if (typeof props === 'string') {
            if (this[0]) {
              return win.getComputedStyle(this[0], null).getPropertyValue(props);
            }
          } else {
            for (i = 0; i < this.length; i += 1) {
              // eslint-disable-next-line
              for (var prop in props) {
                this[i].style[prop] = props[prop];
              }
            }

            return this;
          }
        }

        if (arguments.length === 2 && typeof props === 'string') {
          for (i = 0; i < this.length; i += 1) {
            this[i].style[props] = value;
          }

          return this;
        }

        return this;
      } // Iterate over the collection passing elements to `callback`


      function each(callback) {
        // Don't bother continuing without a callback
        if (!callback) {
          return this;
        } // Iterate over the current collection


        for (var i = 0; i < this.length; i += 1) {
          // If the callback returns false
          if (callback.call(this[i], i, this[i]) === false) {
            // End the loop early
            return this;
          }
        } // Return `this` to allow chained DOM operations


        return this;
      }

      function filter(callback) {
        var matchedItems = [];
        var dom = this;

        for (var i = 0; i < dom.length; i += 1) {
          if (callback.call(dom[i], i, dom[i])) {
            matchedItems.push(dom[i]);
          }
        }

        return new Dom7(matchedItems);
      } // eslint-disable-next-line


      function html(html) {
        if (typeof html === 'undefined') {
          return this[0] ? this[0].innerHTML : undefined;
        }

        for (var i = 0; i < this.length; i += 1) {
          this[i].innerHTML = html;
        }

        return this;
      } // eslint-disable-next-line


      function text(text) {
        if (typeof text === 'undefined') {
          if (this[0]) {
            return this[0].textContent.trim();
          }

          return null;
        }

        for (var i = 0; i < this.length; i += 1) {
          this[i].textContent = text;
        }

        return this;
      }

      function is(selector) {
        var el = this[0];
        var compareWith;
        var i;

        if (!el || typeof selector === 'undefined') {
          return false;
        }

        if (typeof selector === 'string') {
          if (el.matches) {
            return el.matches(selector);
          } else if (el.webkitMatchesSelector) {
            return el.webkitMatchesSelector(selector);
          } else if (el.msMatchesSelector) {
            return el.msMatchesSelector(selector);
          }

          compareWith = $(selector);

          for (i = 0; i < compareWith.length; i += 1) {
            if (compareWith[i] === el) {
              return true;
            }
          }

          return false;
        } else if (selector === doc) {
          return el === doc;
        } else if (selector === win) {
          return el === win;
        }

        if (selector.nodeType || selector instanceof Dom7) {
          compareWith = selector.nodeType ? [selector] : selector;

          for (i = 0; i < compareWith.length; i += 1) {
            if (compareWith[i] === el) {
              return true;
            }
          }

          return false;
        }

        return false;
      }

      function index() {
        var child = this[0];
        var i;

        if (child) {
          i = 0; // eslint-disable-next-line

          while ((child = child.previousSibling) !== null) {
            if (child.nodeType === 1) {
              i += 1;
            }
          }

          return i;
        }

        return undefined;
      } // eslint-disable-next-line


      function eq(index) {
        if (typeof index === 'undefined') {
          return this;
        }

        var length = this.length;
        var returnIndex;

        if (index > length - 1) {
          return new Dom7([]);
        }

        if (index < 0) {
          returnIndex = length + index;

          if (returnIndex < 0) {
            return new Dom7([]);
          }

          return new Dom7([this[returnIndex]]);
        }

        return new Dom7([this[index]]);
      }

      function append() {
        var args = [],
            len = arguments.length;

        while (len--) {
          args[len] = arguments[len];
        }

        var newChild;

        for (var k = 0; k < args.length; k += 1) {
          newChild = args[k];

          for (var i = 0; i < this.length; i += 1) {
            if (typeof newChild === 'string') {
              var tempDiv = doc.createElement('div');
              tempDiv.innerHTML = newChild;

              while (tempDiv.firstChild) {
                this[i].appendChild(tempDiv.firstChild);
              }
            } else if (newChild instanceof Dom7) {
              for (var j = 0; j < newChild.length; j += 1) {
                this[i].appendChild(newChild[j]);
              }
            } else {
              this[i].appendChild(newChild);
            }
          }
        }

        return this;
      }

      function prepend(newChild) {
        var i;
        var j;

        for (i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            var tempDiv = doc.createElement('div');
            tempDiv.innerHTML = newChild;

            for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
              this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
            }
          } else if (newChild instanceof Dom7) {
            for (j = 0; j < newChild.length; j += 1) {
              this[i].insertBefore(newChild[j], this[i].childNodes[0]);
            }
          } else {
            this[i].insertBefore(newChild, this[i].childNodes[0]);
          }
        }

        return this;
      }

      function next(selector) {
        if (this.length > 0) {
          if (selector) {
            if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
              return new Dom7([this[0].nextElementSibling]);
            }

            return new Dom7([]);
          }

          if (this[0].nextElementSibling) {
            return new Dom7([this[0].nextElementSibling]);
          }

          return new Dom7([]);
        }

        return new Dom7([]);
      }

      function nextAll(selector) {
        var nextEls = [];
        var el = this[0];

        if (!el) {
          return new Dom7([]);
        }

        while (el.nextElementSibling) {
          var next = el.nextElementSibling; // eslint-disable-line

          if (selector) {
            if ($(next).is(selector)) {
              nextEls.push(next);
            }
          } else {
            nextEls.push(next);
          }

          el = next;
        }

        return new Dom7(nextEls);
      }

      function prev(selector) {
        if (this.length > 0) {
          var el = this[0];

          if (selector) {
            if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
              return new Dom7([el.previousElementSibling]);
            }

            return new Dom7([]);
          }

          if (el.previousElementSibling) {
            return new Dom7([el.previousElementSibling]);
          }

          return new Dom7([]);
        }

        return new Dom7([]);
      }

      function prevAll(selector) {
        var prevEls = [];
        var el = this[0];

        if (!el) {
          return new Dom7([]);
        }

        while (el.previousElementSibling) {
          var prev = el.previousElementSibling; // eslint-disable-line

          if (selector) {
            if ($(prev).is(selector)) {
              prevEls.push(prev);
            }
          } else {
            prevEls.push(prev);
          }

          el = prev;
        }

        return new Dom7(prevEls);
      }

      function parent(selector) {
        var parents = []; // eslint-disable-line

        for (var i = 0; i < this.length; i += 1) {
          if (this[i].parentNode !== null) {
            if (selector) {
              if ($(this[i].parentNode).is(selector)) {
                parents.push(this[i].parentNode);
              }
            } else {
              parents.push(this[i].parentNode);
            }
          }
        }

        return $(unique(parents));
      }

      function parents(selector) {
        var parents = []; // eslint-disable-line

        for (var i = 0; i < this.length; i += 1) {
          var parent = this[i].parentNode; // eslint-disable-line

          while (parent) {
            if (selector) {
              if ($(parent).is(selector)) {
                parents.push(parent);
              }
            } else {
              parents.push(parent);
            }

            parent = parent.parentNode;
          }
        }

        return $(unique(parents));
      }

      function closest(selector) {
        var closest = this; // eslint-disable-line

        if (typeof selector === 'undefined') {
          return new Dom7([]);
        }

        if (!closest.is(selector)) {
          closest = closest.parents(selector).eq(0);
        }

        return closest;
      }

      function find(selector) {
        var foundElements = [];

        for (var i = 0; i < this.length; i += 1) {
          var found = this[i].querySelectorAll(selector);

          for (var j = 0; j < found.length; j += 1) {
            foundElements.push(found[j]);
          }
        }

        return new Dom7(foundElements);
      }

      function children(selector) {
        var children = []; // eslint-disable-line

        for (var i = 0; i < this.length; i += 1) {
          var childNodes = this[i].childNodes;

          for (var j = 0; j < childNodes.length; j += 1) {
            if (!selector) {
              if (childNodes[j].nodeType === 1) {
                children.push(childNodes[j]);
              }
            } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
              children.push(childNodes[j]);
            }
          }
        }

        return new Dom7(unique(children));
      }

      function remove() {
        for (var i = 0; i < this.length; i += 1) {
          if (this[i].parentNode) {
            this[i].parentNode.removeChild(this[i]);
          }
        }

        return this;
      }

      function add() {
        var args = [],
            len = arguments.length;

        while (len--) {
          args[len] = arguments[len];
        }

        var dom = this;
        var i;
        var j;

        for (i = 0; i < args.length; i += 1) {
          var toAdd = $(args[i]);

          for (j = 0; j < toAdd.length; j += 1) {
            dom[dom.length] = toAdd[j];
            dom.length += 1;
          }
        }

        return dom;
      }

      var Methods = {
        addClass: addClass,
        removeClass: removeClass,
        hasClass: hasClass,
        toggleClass: toggleClass,
        attr: attr,
        removeAttr: removeAttr,
        data: data,
        transform: transform,
        transition: transition,
        on: on,
        off: off,
        trigger: trigger,
        transitionEnd: transitionEnd,
        outerWidth: outerWidth,
        outerHeight: outerHeight,
        offset: offset,
        css: css,
        each: each,
        html: html,
        text: text,
        is: is,
        index: index,
        eq: eq,
        append: append,
        prepend: prepend,
        next: next,
        nextAll: nextAll,
        prev: prev,
        prevAll: prevAll,
        parent: parent,
        parents: parents,
        closest: closest,
        find: find,
        children: children,
        filter: filter,
        remove: remove,
        add: add,
        styles: styles
      };
      Object.keys(Methods).forEach(function (methodName) {
        $.fn[methodName] = $.fn[methodName] || Methods[methodName];
      });
      var Utils = {
        deleteProps: function deleteProps(obj) {
          var object = obj;
          Object.keys(object).forEach(function (key) {
            try {
              object[key] = null;
            } catch (e) {// no getter for object
            }

            try {
              delete object[key];
            } catch (e) {// something got wrong
            }
          });
        },
        nextTick: function nextTick(callback, delay) {
          if (delay === void 0) delay = 0;
          return setTimeout(callback, delay);
        },
        now: function now() {
          return Date.now();
        },
        getTranslate: function getTranslate(el, axis) {
          if (axis === void 0) axis = 'x';
          var matrix;
          var curTransform;
          var transformMatrix;
          var curStyle = win.getComputedStyle(el, null);

          if (win.WebKitCSSMatrix) {
            curTransform = curStyle.transform || curStyle.webkitTransform;

            if (curTransform.split(',').length > 6) {
              curTransform = curTransform.split(', ').map(function (a) {
                return a.replace(',', '.');
              }).join(', ');
            } // Some old versions of Webkit choke when 'none' is passed; pass
            // empty string instead in this case


            transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
          } else {
            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
            matrix = transformMatrix.toString().split(',');
          }

          if (axis === 'x') {
            // Latest Chrome and webkits Fix
            if (win.WebKitCSSMatrix) {
              curTransform = transformMatrix.m41;
            } // Crazy IE10 Matrix
            else if (matrix.length === 16) {
                curTransform = parseFloat(matrix[12]);
              } // Normal Browsers
              else {
                  curTransform = parseFloat(matrix[4]);
                }
          }

          if (axis === 'y') {
            // Latest Chrome and webkits Fix
            if (win.WebKitCSSMatrix) {
              curTransform = transformMatrix.m42;
            } // Crazy IE10 Matrix
            else if (matrix.length === 16) {
                curTransform = parseFloat(matrix[13]);
              } // Normal Browsers
              else {
                  curTransform = parseFloat(matrix[5]);
                }
          }

          return curTransform || 0;
        },
        parseUrlQuery: function parseUrlQuery(url) {
          var query = {};
          var urlToParse = url || win.location.href;
          var i;
          var params;
          var param;
          var length;

          if (typeof urlToParse === 'string' && urlToParse.length) {
            urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
            params = urlToParse.split('&').filter(function (paramsPart) {
              return paramsPart !== '';
            });
            length = params.length;

            for (i = 0; i < length; i += 1) {
              param = params[i].replace(/#\S+/g, '').split('=');
              query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
            }
          }

          return query;
        },
        isObject: function isObject(o) {
          return _typeof(o) === 'object' && o !== null && o.constructor && o.constructor === Object;
        },
        extend: function extend() {
          var args = [],
              len$1 = arguments.length;

          while (len$1--) {
            args[len$1] = arguments[len$1];
          }

          var to = Object(args[0]);

          for (var i = 1; i < args.length; i += 1) {
            var nextSource = args[i];

            if (nextSource !== undefined && nextSource !== null) {
              var keysArray = Object.keys(Object(nextSource));

              for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                var nextKey = keysArray[nextIndex];
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

                if (desc !== undefined && desc.enumerable) {
                  if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                    Utils.extend(to[nextKey], nextSource[nextKey]);
                  } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                    to[nextKey] = {};
                    Utils.extend(to[nextKey], nextSource[nextKey]);
                  } else {
                    to[nextKey] = nextSource[nextKey];
                  }
                }
              }
            }
          }

          return to;
        }
      };

      var Support = function Support() {
        return {
          touch: win.Modernizr && win.Modernizr.touch === true || function checkTouch() {
            return !!(win.navigator.maxTouchPoints > 0 || 'ontouchstart' in win || win.DocumentTouch && doc instanceof win.DocumentTouch);
          }(),
          pointerEvents: !!win.PointerEvent && 'maxTouchPoints' in win.navigator && win.navigator.maxTouchPoints > 0,
          observer: function checkObserver() {
            return 'MutationObserver' in win || 'WebkitMutationObserver' in win;
          }(),
          passiveListener: function checkPassiveListener() {
            var supportsPassive = false;

            try {
              var opts = Object.defineProperty({}, 'passive', {
                // eslint-disable-next-line
                get: function get() {
                  supportsPassive = true;
                }
              });
              win.addEventListener('testPassiveListener', null, opts);
            } catch (e) {// No support
            }

            return supportsPassive;
          }(),
          gestures: function checkGestures() {
            return 'ongesturestart' in win;
          }()
        };
      }();

      var SwiperClass = function SwiperClass(params) {
        if (params === void 0) params = {};
        var self = this;
        self.params = params; // Events

        self.eventsListeners = {};

        if (self.params && self.params.on) {
          Object.keys(self.params.on).forEach(function (eventName) {
            self.on(eventName, self.params.on[eventName]);
          });
        }
      };

      var staticAccessors = {
        components: {
          configurable: true
        }
      };

      SwiperClass.prototype.on = function on(events, handler, priority) {
        var self = this;

        if (typeof handler !== 'function') {
          return self;
        }

        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) {
            self.eventsListeners[event] = [];
          }

          self.eventsListeners[event][method](handler);
        });
        return self;
      };

      SwiperClass.prototype.once = function once(events, handler, priority) {
        var self = this;

        if (typeof handler !== 'function') {
          return self;
        }

        function onceHandler() {
          var args = [],
              len = arguments.length;

          while (len--) {
            args[len] = arguments[len];
          }

          handler.apply(self, args);
          self.off(events, onceHandler);

          if (onceHandler.f7proxy) {
            delete onceHandler.f7proxy;
          }
        }

        onceHandler.f7proxy = handler;
        return self.on(events, onceHandler, priority);
      };

      SwiperClass.prototype.off = function off(events, handler) {
        var self = this;

        if (!self.eventsListeners) {
          return self;
        }

        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      };

      SwiperClass.prototype.emit = function emit() {
        var args = [],
            len = arguments.length;

        while (len--) {
          args[len] = arguments[len];
        }

        var self = this;

        if (!self.eventsListeners) {
          return self;
        }

        var events;
        var data;
        var context;

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(function (event) {
          if (self.eventsListeners && self.eventsListeners[event]) {
            var handlers = [];
            self.eventsListeners[event].forEach(function (eventHandler) {
              handlers.push(eventHandler);
            });
            handlers.forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      };

      SwiperClass.prototype.useModulesParams = function useModulesParams(instanceParams) {
        var instance = this;

        if (!instance.modules) {
          return;
        }

        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName]; // Extend params

          if (module.params) {
            Utils.extend(instanceParams, module.params);
          }
        });
      };

      SwiperClass.prototype.useModules = function useModules(modulesParams) {
        if (modulesParams === void 0) modulesParams = {};
        var instance = this;

        if (!instance.modules) {
          return;
        }

        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName];
          var moduleParams = modulesParams[moduleName] || {}; // Extend instance methods and props

          if (module.instance) {
            Object.keys(module.instance).forEach(function (modulePropName) {
              var moduleProp = module.instance[modulePropName];

              if (typeof moduleProp === 'function') {
                instance[modulePropName] = moduleProp.bind(instance);
              } else {
                instance[modulePropName] = moduleProp;
              }
            });
          } // Add event listeners


          if (module.on && instance.on) {
            Object.keys(module.on).forEach(function (moduleEventName) {
              instance.on(moduleEventName, module.on[moduleEventName]);
            });
          } // Module create callback


          if (module.create) {
            module.create.bind(instance)(moduleParams);
          }
        });
      };

      staticAccessors.components.set = function (components) {
        var Class = this;

        if (!Class.use) {
          return;
        }

        Class.use(components);
      };

      SwiperClass.installModule = function installModule(module) {
        var params = [],
            len = arguments.length - 1;

        while (len-- > 0) {
          params[len] = arguments[len + 1];
        }

        var Class = this;

        if (!Class.prototype.modules) {
          Class.prototype.modules = {};
        }

        var name = module.name || Object.keys(Class.prototype.modules).length + "_" + Utils.now();
        Class.prototype.modules[name] = module; // Prototype

        if (module.proto) {
          Object.keys(module.proto).forEach(function (key) {
            Class.prototype[key] = module.proto[key];
          });
        } // Class


        if (module["static"]) {
          Object.keys(module["static"]).forEach(function (key) {
            Class[key] = module["static"][key];
          });
        } // Callback


        if (module.install) {
          module.install.apply(Class, params);
        }

        return Class;
      };

      SwiperClass.use = function use(module) {
        var params = [],
            len = arguments.length - 1;

        while (len-- > 0) {
          params[len] = arguments[len + 1];
        }

        var Class = this;

        if (Array.isArray(module)) {
          module.forEach(function (m) {
            return Class.installModule(m);
          });
          return Class;
        }

        return Class.installModule.apply(Class, [module].concat(params));
      };

      Object.defineProperties(SwiperClass, staticAccessors);

      function updateSize() {
        var swiper = this;
        var width;
        var height;
        var $el = swiper.$el;

        if (typeof swiper.params.width !== 'undefined') {
          width = swiper.params.width;
        } else {
          width = $el[0].clientWidth;
        }

        if (typeof swiper.params.height !== 'undefined') {
          height = swiper.params.height;
        } else {
          height = $el[0].clientHeight;
        }

        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
          return;
        } // Subtract paddings


        width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
        height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);
        Utils.extend(swiper, {
          width: width,
          height: height,
          size: swiper.isHorizontal() ? width : height
        });
      }

      function updateSlides() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var swiperSize = swiper.size;
        var rtl = swiper.rtlTranslate;
        var wrongRTL = swiper.wrongRTL;
        var isVirtual = swiper.virtual && params.virtual.enabled;
        var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
        var slides = $wrapperEl.children("." + swiper.params.slideClass);
        var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        var snapGrid = [];
        var slidesGrid = [];
        var slidesSizesGrid = [];

        function slidesForMargin(slideIndex) {
          if (!params.cssMode) {
            return true;
          }

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }

        var offsetBefore = params.slidesOffsetBefore;

        if (typeof offsetBefore === 'function') {
          offsetBefore = params.slidesOffsetBefore.call(swiper);
        }

        var offsetAfter = params.slidesOffsetAfter;

        if (typeof offsetAfter === 'function') {
          offsetAfter = params.slidesOffsetAfter.call(swiper);
        }

        var previousSnapGridLength = swiper.snapGrid.length;
        var previousSlidesGridLength = swiper.snapGrid.length;
        var spaceBetween = params.spaceBetween;
        var slidePosition = -offsetBefore;
        var prevSlideSize = 0;
        var index = 0;

        if (typeof swiperSize === 'undefined') {
          return;
        }

        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
          spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
        }

        swiper.virtualSize = -spaceBetween; // reset margins

        if (rtl) {
          slides.css({
            marginLeft: '',
            marginTop: ''
          });
        } else {
          slides.css({
            marginRight: '',
            marginBottom: ''
          });
        }

        var slidesNumberEvenToRows;

        if (params.slidesPerColumn > 1) {
          if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
            slidesNumberEvenToRows = slidesLength;
          } else {
            slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
          }

          if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
            slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
          }
        } // Calc slides


        var slideSize;
        var slidesPerColumn = params.slidesPerColumn;
        var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
        var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

        for (var i = 0; i < slidesLength; i += 1) {
          slideSize = 0;
          var slide = slides.eq(i);

          if (params.slidesPerColumn > 1) {
            // Set slides order
            var newSlideOrderIndex = void 0;
            var column = void 0;
            var row = void 0;

            if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
              var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
              var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
              row = Math.floor(slideIndexInGroup / params.slidesPerGroup);
              column = slideIndexInGroup - row * params.slidesPerGroup + groupIndex * params.slidesPerGroup;
              newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
              slide.css({
                '-webkit-box-ordinal-group': newSlideOrderIndex,
                '-moz-box-ordinal-group': newSlideOrderIndex,
                '-ms-flex-order': newSlideOrderIndex,
                '-webkit-order': newSlideOrderIndex,
                order: newSlideOrderIndex
              });
            } else if (params.slidesPerColumnFill === 'column') {
              column = Math.floor(i / slidesPerColumn);
              row = i - column * slidesPerColumn;

              if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
                row += 1;

                if (row >= slidesPerColumn) {
                  row = 0;
                  column += 1;
                }
              }
            } else {
              row = Math.floor(i / slidesPerRow);
              column = i - row * slidesPerRow;
            }

            slide.css("margin-" + (swiper.isHorizontal() ? 'top' : 'left'), row !== 0 && params.spaceBetween && params.spaceBetween + "px");
          }

          if (slide.css('display') === 'none') {
            continue;
          } // eslint-disable-line


          if (params.slidesPerView === 'auto') {
            var slideStyles = win.getComputedStyle(slide[0], null);
            var currentTransform = slide[0].style.transform;
            var currentWebKitTransform = slide[0].style.webkitTransform;

            if (currentTransform) {
              slide[0].style.transform = 'none';
            }

            if (currentWebKitTransform) {
              slide[0].style.webkitTransform = 'none';
            }

            if (params.roundLengths) {
              slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
            } else {
              // eslint-disable-next-line
              if (swiper.isHorizontal()) {
                var width = parseFloat(slideStyles.getPropertyValue('width'));
                var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
                var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
                var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
                var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
                var boxSizing = slideStyles.getPropertyValue('box-sizing');

                if (boxSizing && boxSizing === 'border-box') {
                  slideSize = width + marginLeft + marginRight;
                } else {
                  slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
                }
              } else {
                var height = parseFloat(slideStyles.getPropertyValue('height'));
                var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
                var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
                var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
                var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
                var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');

                if (boxSizing$1 && boxSizing$1 === 'border-box') {
                  slideSize = height + marginTop + marginBottom;
                } else {
                  slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
                }
              }
            }

            if (currentTransform) {
              slide[0].style.transform = currentTransform;
            }

            if (currentWebKitTransform) {
              slide[0].style.webkitTransform = currentWebKitTransform;
            }

            if (params.roundLengths) {
              slideSize = Math.floor(slideSize);
            }
          } else {
            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;

            if (params.roundLengths) {
              slideSize = Math.floor(slideSize);
            }

            if (slides[i]) {
              if (swiper.isHorizontal()) {
                slides[i].style.width = slideSize + "px";
              } else {
                slides[i].style.height = slideSize + "px";
              }
            }
          }

          if (slides[i]) {
            slides[i].swiperSlideSize = slideSize;
          }

          slidesSizesGrid.push(slideSize);

          if (params.centeredSlides) {
            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;

            if (prevSlideSize === 0 && i !== 0) {
              slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            }

            if (i === 0) {
              slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            }

            if (Math.abs(slidePosition) < 1 / 1000) {
              slidePosition = 0;
            }

            if (params.roundLengths) {
              slidePosition = Math.floor(slidePosition);
            }

            if (index % params.slidesPerGroup === 0) {
              snapGrid.push(slidePosition);
            }

            slidesGrid.push(slidePosition);
          } else {
            if (params.roundLengths) {
              slidePosition = Math.floor(slidePosition);
            }

            if (index % params.slidesPerGroup === 0) {
              snapGrid.push(slidePosition);
            }

            slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
          }

          swiper.virtualSize += slideSize + spaceBetween;
          prevSlideSize = slideSize;
          index += 1;
        }

        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        var newSlidesGrid;

        if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
          $wrapperEl.css({
            width: swiper.virtualSize + params.spaceBetween + "px"
          });
        }

        if (params.setWrapperSize) {
          if (swiper.isHorizontal()) {
            $wrapperEl.css({
              width: swiper.virtualSize + params.spaceBetween + "px"
            });
          } else {
            $wrapperEl.css({
              height: swiper.virtualSize + params.spaceBetween + "px"
            });
          }
        }

        if (params.slidesPerColumn > 1) {
          swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
          swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;

          if (swiper.isHorizontal()) {
            $wrapperEl.css({
              width: swiper.virtualSize + params.spaceBetween + "px"
            });
          } else {
            $wrapperEl.css({
              height: swiper.virtualSize + params.spaceBetween + "px"
            });
          }

          if (params.centeredSlides) {
            newSlidesGrid = [];

            for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
              var slidesGridItem = snapGrid[i$1];

              if (params.roundLengths) {
                slidesGridItem = Math.floor(slidesGridItem);
              }

              if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) {
                newSlidesGrid.push(slidesGridItem);
              }
            }

            snapGrid = newSlidesGrid;
          }
        } // Remove last grid elements depending on width


        if (!params.centeredSlides) {
          newSlidesGrid = [];

          for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
            var slidesGridItem$1 = snapGrid[i$2];

            if (params.roundLengths) {
              slidesGridItem$1 = Math.floor(slidesGridItem$1);
            }

            if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
              newSlidesGrid.push(slidesGridItem$1);
            }
          }

          snapGrid = newSlidesGrid;

          if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
            snapGrid.push(swiper.virtualSize - swiperSize);
          }
        }

        if (snapGrid.length === 0) {
          snapGrid = [0];
        }

        if (params.spaceBetween !== 0) {
          if (swiper.isHorizontal()) {
            if (rtl) {
              slides.filter(slidesForMargin).css({
                marginLeft: spaceBetween + "px"
              });
            } else {
              slides.filter(slidesForMargin).css({
                marginRight: spaceBetween + "px"
              });
            }
          } else {
            slides.filter(slidesForMargin).css({
              marginBottom: spaceBetween + "px"
            });
          }
        }

        if (params.centerInsufficientSlides) {
          var allSlidesSize = 0;
          slidesSizesGrid.forEach(function (slideSizeValue) {
            allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
          });
          allSlidesSize -= params.spaceBetween;

          if (allSlidesSize < swiperSize) {
            var allSlidesOffset = (swiperSize - allSlidesSize) / 2;
            snapGrid.forEach(function (snap, snapIndex) {
              snapGrid[snapIndex] = snap - allSlidesOffset;
            });
            slidesGrid.forEach(function (snap, snapIndex) {
              slidesGrid[snapIndex] = snap + allSlidesOffset;
            });
          }
        }

        Utils.extend(swiper, {
          slides: slides,
          snapGrid: snapGrid,
          slidesGrid: slidesGrid,
          slidesSizesGrid: slidesSizesGrid
        });

        if (slidesLength !== previousSlidesLength) {
          swiper.emit('slidesLengthChange');
        }

        if (snapGrid.length !== previousSnapGridLength) {
          if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
          }

          swiper.emit('snapGridLengthChange');
        }

        if (slidesGrid.length !== previousSlidesGridLength) {
          swiper.emit('slidesGridLengthChange');
        }

        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
          swiper.updateSlidesOffset();
        }
      }

      function updateAutoHeight(speed) {
        var swiper = this;
        var activeSlides = [];
        var newHeight = 0;
        var i;

        if (typeof speed === 'number') {
          swiper.setTransition(speed);
        } else if (speed === true) {
          swiper.setTransition(swiper.params.speed);
        } // Find slides currently in view


        if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            var index = swiper.activeIndex + i;

            if (index > swiper.slides.length) {
              break;
            }

            activeSlides.push(swiper.slides.eq(index)[0]);
          }
        } else {
          activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
        } // Find new height from highest slide in view


        for (i = 0; i < activeSlides.length; i += 1) {
          if (typeof activeSlides[i] !== 'undefined') {
            var height = activeSlides[i].offsetHeight;
            newHeight = height > newHeight ? height : newHeight;
          }
        } // Update Height


        if (newHeight) {
          swiper.$wrapperEl.css('height', newHeight + "px");
        }
      }

      function updateSlidesOffset() {
        var swiper = this;
        var slides = swiper.slides;

        for (var i = 0; i < slides.length; i += 1) {
          slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
      }

      function updateSlidesProgress(translate) {
        if (translate === void 0) translate = this && this.translate || 0;
        var swiper = this;
        var params = swiper.params;
        var slides = swiper.slides;
        var rtl = swiper.rtlTranslate;

        if (slides.length === 0) {
          return;
        }

        if (typeof slides[0].swiperSlideOffset === 'undefined') {
          swiper.updateSlidesOffset();
        }

        var offsetCenter = -translate;

        if (rtl) {
          offsetCenter = translate;
        } // Visible Slides


        slides.removeClass(params.slideVisibleClass);
        swiper.visibleSlidesIndexes = [];
        swiper.visibleSlides = [];

        for (var i = 0; i < slides.length; i += 1) {
          var slide = slides[i];
          var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

          if (params.watchSlidesVisibility) {
            var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
            var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
            var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

            if (isVisible) {
              swiper.visibleSlides.push(slide);
              swiper.visibleSlidesIndexes.push(i);
              slides.eq(i).addClass(params.slideVisibleClass);
            }
          }

          slide.progress = rtl ? -slideProgress : slideProgress;
        }

        swiper.visibleSlides = $(swiper.visibleSlides);
      }

      function updateProgress(translate) {
        var swiper = this;

        if (typeof translate === 'undefined') {
          var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

          translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
        }

        var params = swiper.params;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        var progress = swiper.progress;
        var isBeginning = swiper.isBeginning;
        var isEnd = swiper.isEnd;
        var wasBeginning = isBeginning;
        var wasEnd = isEnd;

        if (translatesDiff === 0) {
          progress = 0;
          isBeginning = true;
          isEnd = true;
        } else {
          progress = (translate - swiper.minTranslate()) / translatesDiff;
          isBeginning = progress <= 0;
          isEnd = progress >= 1;
        }

        Utils.extend(swiper, {
          progress: progress,
          isBeginning: isBeginning,
          isEnd: isEnd
        });

        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
          swiper.updateSlidesProgress(translate);
        }

        if (isBeginning && !wasBeginning) {
          swiper.emit('reachBeginning toEdge');
        }

        if (isEnd && !wasEnd) {
          swiper.emit('reachEnd toEdge');
        }

        if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
          swiper.emit('fromEdge');
        }

        swiper.emit('progress', progress);
      }

      function updateSlidesClasses() {
        var swiper = this;
        var slides = swiper.slides;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;
        var realIndex = swiper.realIndex;
        var isVirtual = swiper.virtual && params.virtual.enabled;
        slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
        var activeSlide;

        if (isVirtual) {
          activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
        } else {
          activeSlide = slides.eq(activeIndex);
        } // Active classes


        activeSlide.addClass(params.slideActiveClass);

        if (params.loop) {
          // Duplicate to all looped slides
          if (activeSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
          } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
          }
        } // Next Slide


        var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

        if (params.loop && nextSlide.length === 0) {
          nextSlide = slides.eq(0);
          nextSlide.addClass(params.slideNextClass);
        } // Prev Slide


        var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

        if (params.loop && prevSlide.length === 0) {
          prevSlide = slides.eq(-1);
          prevSlide.addClass(params.slidePrevClass);
        }

        if (params.loop) {
          // Duplicate to all looped slides
          if (nextSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
          } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
          }

          if (prevSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
          } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
          }
        }
      }

      function updateActiveIndex(newActiveIndex) {
        var swiper = this;
        var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        var slidesGrid = swiper.slidesGrid;
        var snapGrid = swiper.snapGrid;
        var params = swiper.params;
        var previousIndex = swiper.activeIndex;
        var previousRealIndex = swiper.realIndex;
        var previousSnapIndex = swiper.snapIndex;
        var activeIndex = newActiveIndex;
        var snapIndex;

        if (typeof activeIndex === 'undefined') {
          for (var i = 0; i < slidesGrid.length; i += 1) {
            if (typeof slidesGrid[i + 1] !== 'undefined') {
              if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                activeIndex = i;
              } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                activeIndex = i + 1;
              }
            } else if (translate >= slidesGrid[i]) {
              activeIndex = i;
            }
          } // Normalize slideIndex


          if (params.normalizeSlideIndex) {
            if (activeIndex < 0 || typeof activeIndex === 'undefined') {
              activeIndex = 0;
            }
          }
        }

        if (snapGrid.indexOf(translate) >= 0) {
          snapIndex = snapGrid.indexOf(translate);
        } else {
          snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
        }

        if (snapIndex >= snapGrid.length) {
          snapIndex = snapGrid.length - 1;
        }

        if (activeIndex === previousIndex) {
          if (snapIndex !== previousSnapIndex) {
            swiper.snapIndex = snapIndex;
            swiper.emit('snapIndexChange');
          }

          return;
        } // Get real index


        var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
        Utils.extend(swiper, {
          snapIndex: snapIndex,
          realIndex: realIndex,
          previousIndex: previousIndex,
          activeIndex: activeIndex
        });
        swiper.emit('activeIndexChange');
        swiper.emit('snapIndexChange');

        if (previousRealIndex !== realIndex) {
          swiper.emit('realIndexChange');
        }

        if (swiper.initialized || swiper.runCallbacksOnInit) {
          swiper.emit('slideChange');
        }
      }

      function updateClickedSlide(e) {
        var swiper = this;
        var params = swiper.params;
        var slide = $(e.target).closest("." + params.slideClass)[0];
        var slideFound = false;

        if (slide) {
          for (var i = 0; i < swiper.slides.length; i += 1) {
            if (swiper.slides[i] === slide) {
              slideFound = true;
            }
          }
        }

        if (slide && slideFound) {
          swiper.clickedSlide = slide;

          if (swiper.virtual && swiper.params.virtual.enabled) {
            swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
          } else {
            swiper.clickedIndex = $(slide).index();
          }
        } else {
          swiper.clickedSlide = undefined;
          swiper.clickedIndex = undefined;
          return;
        }

        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
          swiper.slideToClickedSlide();
        }
      }

      var update = {
        updateSize: updateSize,
        updateSlides: updateSlides,
        updateAutoHeight: updateAutoHeight,
        updateSlidesOffset: updateSlidesOffset,
        updateSlidesProgress: updateSlidesProgress,
        updateProgress: updateProgress,
        updateSlidesClasses: updateSlidesClasses,
        updateActiveIndex: updateActiveIndex,
        updateClickedSlide: updateClickedSlide
      };

      function getTranslate(axis) {
        if (axis === void 0) axis = this.isHorizontal() ? 'x' : 'y';
        var swiper = this;
        var params = swiper.params;
        var rtl = swiper.rtlTranslate;
        var translate = swiper.translate;
        var $wrapperEl = swiper.$wrapperEl;

        if (params.virtualTranslate) {
          return rtl ? -translate : translate;
        }

        if (params.cssMode) {
          return translate;
        }

        var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);

        if (rtl) {
          currentTranslate = -currentTranslate;
        }

        return currentTranslate || 0;
      }

      function setTranslate(translate, byController) {
        var swiper = this;
        var rtl = swiper.rtlTranslate;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var wrapperEl = swiper.wrapperEl;
        var progress = swiper.progress;
        var x = 0;
        var y = 0;
        var z = 0;

        if (swiper.isHorizontal()) {
          x = rtl ? -translate : translate;
        } else {
          y = translate;
        }

        if (params.roundLengths) {
          x = Math.floor(x);
          y = Math.floor(y);
        }

        if (params.cssMode) {
          wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
        } else if (!params.virtualTranslate) {
          $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
        }

        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

        var newProgress;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

        if (translatesDiff === 0) {
          newProgress = 0;
        } else {
          newProgress = (translate - swiper.minTranslate()) / translatesDiff;
        }

        if (newProgress !== progress) {
          swiper.updateProgress(translate);
        }

        swiper.emit('setTranslate', swiper.translate, byController);
      }

      function minTranslate() {
        return -this.snapGrid[0];
      }

      function maxTranslate() {
        return -this.snapGrid[this.snapGrid.length - 1];
      }

      function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
        var obj;
        if (translate === void 0) translate = 0;
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        if (translateBounds === void 0) translateBounds = true;
        var swiper = this;
        var params = swiper.params;
        var wrapperEl = swiper.wrapperEl;

        if (swiper.animating && params.preventInteractionOnTransition) {
          return false;
        }

        var minTranslate = swiper.minTranslate();
        var maxTranslate = swiper.maxTranslate();
        var newTranslate;

        if (translateBounds && translate > minTranslate) {
          newTranslate = minTranslate;
        } else if (translateBounds && translate < maxTranslate) {
          newTranslate = maxTranslate;
        } else {
          newTranslate = translate;
        } // Update progress


        swiper.updateProgress(newTranslate);

        if (params.cssMode) {
          var isH = swiper.isHorizontal();

          if (speed === 0) {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
          } else {
            // eslint-disable-next-line
            if (wrapperEl.scrollTo) {
              wrapperEl.scrollTo((obj = {}, obj[isH ? 'left' : 'top'] = -newTranslate, obj.behavior = 'smooth', obj));
            } else {
              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
            }
          }

          return true;
        }

        if (speed === 0) {
          swiper.setTransition(0);
          swiper.setTranslate(newTranslate);

          if (runCallbacks) {
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.emit('transitionEnd');
          }
        } else {
          swiper.setTransition(speed);
          swiper.setTranslate(newTranslate);

          if (runCallbacks) {
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.emit('transitionStart');
          }

          if (!swiper.animating) {
            swiper.animating = true;

            if (!swiper.onTranslateToWrapperTransitionEnd) {
              swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                if (!swiper || swiper.destroyed) {
                  return;
                }

                if (e.target !== this) {
                  return;
                }

                swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
                swiper.onTranslateToWrapperTransitionEnd = null;
                delete swiper.onTranslateToWrapperTransitionEnd;

                if (runCallbacks) {
                  swiper.emit('transitionEnd');
                }
              };
            }

            swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          }
        }

        return true;
      }

      var translate = {
        getTranslate: getTranslate,
        setTranslate: setTranslate,
        minTranslate: minTranslate,
        maxTranslate: maxTranslate,
        translateTo: translateTo
      };

      function setTransition(duration, byController) {
        var swiper = this;

        if (!swiper.params.cssMode) {
          swiper.$wrapperEl.transition(duration);
        }

        swiper.emit('setTransition', duration, byController);
      }

      function transitionStart(runCallbacks, direction) {
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var params = swiper.params;
        var previousIndex = swiper.previousIndex;

        if (params.cssMode) {
          return;
        }

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        var dir = direction;

        if (!dir) {
          if (activeIndex > previousIndex) {
            dir = 'next';
          } else if (activeIndex < previousIndex) {
            dir = 'prev';
          } else {
            dir = 'reset';
          }
        }

        swiper.emit('transitionStart');

        if (runCallbacks && activeIndex !== previousIndex) {
          if (dir === 'reset') {
            swiper.emit('slideResetTransitionStart');
            return;
          }

          swiper.emit('slideChangeTransitionStart');

          if (dir === 'next') {
            swiper.emit('slideNextTransitionStart');
          } else {
            swiper.emit('slidePrevTransitionStart');
          }
        }
      }

      function transitionEnd$1(runCallbacks, direction) {
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var previousIndex = swiper.previousIndex;
        var params = swiper.params;
        swiper.animating = false;

        if (params.cssMode) {
          return;
        }

        swiper.setTransition(0);
        var dir = direction;

        if (!dir) {
          if (activeIndex > previousIndex) {
            dir = 'next';
          } else if (activeIndex < previousIndex) {
            dir = 'prev';
          } else {
            dir = 'reset';
          }
        }

        swiper.emit('transitionEnd');

        if (runCallbacks && activeIndex !== previousIndex) {
          if (dir === 'reset') {
            swiper.emit('slideResetTransitionEnd');
            return;
          }

          swiper.emit('slideChangeTransitionEnd');

          if (dir === 'next') {
            swiper.emit('slideNextTransitionEnd');
          } else {
            swiper.emit('slidePrevTransitionEnd');
          }
        }
      }

      var transition$1 = {
        setTransition: setTransition,
        transitionStart: transitionStart,
        transitionEnd: transitionEnd$1
      };

      function slideTo(index, speed, runCallbacks, internal) {
        var obj;
        if (index === void 0) index = 0;
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var slideIndex = index;

        if (slideIndex < 0) {
          slideIndex = 0;
        }

        var params = swiper.params;
        var snapGrid = swiper.snapGrid;
        var slidesGrid = swiper.slidesGrid;
        var previousIndex = swiper.previousIndex;
        var activeIndex = swiper.activeIndex;
        var rtl = swiper.rtlTranslate;
        var wrapperEl = swiper.wrapperEl;

        if (swiper.animating && params.preventInteractionOnTransition) {
          return false;
        }

        var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);

        if (snapIndex >= snapGrid.length) {
          snapIndex = snapGrid.length - 1;
        }

        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
          swiper.emit('beforeSlideChangeStart');
        }

        var translate = -snapGrid[snapIndex]; // Update progress

        swiper.updateProgress(translate); // Normalize slideIndex

        if (params.normalizeSlideIndex) {
          for (var i = 0; i < slidesGrid.length; i += 1) {
            if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
              slideIndex = i;
            }
          }
        } // Directions locks


        if (swiper.initialized && slideIndex !== activeIndex) {
          if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
            return false;
          }

          if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
            if ((activeIndex || 0) !== slideIndex) {
              return false;
            }
          }
        }

        var direction;

        if (slideIndex > activeIndex) {
          direction = 'next';
        } else if (slideIndex < activeIndex) {
          direction = 'prev';
        } else {
          direction = 'reset';
        } // Update Index


        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
          swiper.updateActiveIndex(slideIndex); // Update Height

          if (params.autoHeight) {
            swiper.updateAutoHeight();
          }

          swiper.updateSlidesClasses();

          if (params.effect !== 'slide') {
            swiper.setTranslate(translate);
          }

          if (direction !== 'reset') {
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
          }

          return false;
        }

        if (params.cssMode) {
          var isH = swiper.isHorizontal();

          if (speed === 0) {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;
          } else {
            // eslint-disable-next-line
            if (wrapperEl.scrollTo) {
              wrapperEl.scrollTo((obj = {}, obj[isH ? 'left' : 'top'] = -translate, obj.behavior = 'smooth', obj));
            } else {
              wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;
            }
          }

          return true;
        }

        if (speed === 0) {
          swiper.setTransition(0);
          swiper.setTranslate(translate);
          swiper.updateActiveIndex(slideIndex);
          swiper.updateSlidesClasses();
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        } else {
          swiper.setTransition(speed);
          swiper.setTranslate(translate);
          swiper.updateActiveIndex(slideIndex);
          swiper.updateSlidesClasses();
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.transitionStart(runCallbacks, direction);

          if (!swiper.animating) {
            swiper.animating = true;

            if (!swiper.onSlideToWrapperTransitionEnd) {
              swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                if (!swiper || swiper.destroyed) {
                  return;
                }

                if (e.target !== this) {
                  return;
                }

                swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
                swiper.onSlideToWrapperTransitionEnd = null;
                delete swiper.onSlideToWrapperTransitionEnd;
                swiper.transitionEnd(runCallbacks, direction);
              };
            }

            swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          }
        }

        return true;
      }

      function slideToLoop(index, speed, runCallbacks, internal) {
        if (index === void 0) index = 0;
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var newIndex = index;

        if (swiper.params.loop) {
          newIndex += swiper.loopedSlides;
        }

        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
      }
      /* eslint no-unused-vars: "off" */


      function slideNext(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var params = swiper.params;
        var animating = swiper.animating;

        if (params.loop) {
          if (animating) {
            return false;
          }

          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
        }

        return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
      }
      /* eslint no-unused-vars: "off" */


      function slidePrev(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var params = swiper.params;
        var animating = swiper.animating;
        var snapGrid = swiper.snapGrid;
        var slidesGrid = swiper.slidesGrid;
        var rtlTranslate = swiper.rtlTranslate;

        if (params.loop) {
          if (animating) {
            return false;
          }

          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }

        var translate = rtlTranslate ? swiper.translate : -swiper.translate;

        function normalize(val) {
          if (val < 0) {
            return -Math.floor(Math.abs(val));
          }

          return Math.floor(val);
        }

        var normalizedTranslate = normalize(translate);
        var normalizedSnapGrid = snapGrid.map(function (val) {
          return normalize(val);
        });
        var normalizedSlidesGrid = slidesGrid.map(function (val) {
          return normalize(val);
        });
        var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
        var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

        if (typeof prevSnap === 'undefined' && params.cssMode) {
          snapGrid.forEach(function (snap) {
            if (!prevSnap && normalizedTranslate >= snap) {
              prevSnap = snap;
            }
          });
        }

        var prevIndex;

        if (typeof prevSnap !== 'undefined') {
          prevIndex = slidesGrid.indexOf(prevSnap);

          if (prevIndex < 0) {
            prevIndex = swiper.activeIndex - 1;
          }
        }

        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
      }
      /* eslint no-unused-vars: "off" */


      function slideReset(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
      }
      /* eslint no-unused-vars: "off" */


      function slideToClosest(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;
        var swiper = this;
        var index = swiper.activeIndex;
        var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);

        if (snapIndex < swiper.snapGrid.length - 1) {
          var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
          var currentSnap = swiper.snapGrid[snapIndex];
          var nextSnap = swiper.snapGrid[snapIndex + 1];

          if (translate - currentSnap > (nextSnap - currentSnap) / 2) {
            index = swiper.params.slidesPerGroup;
          }
        }

        return swiper.slideTo(index, speed, runCallbacks, internal);
      }

      function slideToClickedSlide() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        var slideToIndex = swiper.clickedIndex;
        var realIndex;

        if (params.loop) {
          if (swiper.animating) {
            return;
          }

          realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

          if (params.centeredSlides) {
            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
              swiper.loopFix();
              slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
              Utils.nextTick(function () {
                swiper.slideTo(slideToIndex);
              });
            } else {
              swiper.slideTo(slideToIndex);
            }
          } else if (slideToIndex > swiper.slides.length - slidesPerView) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
            Utils.nextTick(function () {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else {
          swiper.slideTo(slideToIndex);
        }
      }

      var slide = {
        slideTo: slideTo,
        slideToLoop: slideToLoop,
        slideNext: slideNext,
        slidePrev: slidePrev,
        slideReset: slideReset,
        slideToClosest: slideToClosest,
        slideToClickedSlide: slideToClickedSlide
      };

      function loopCreate() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
        var slides = $wrapperEl.children("." + params.slideClass);

        if (params.loopFillGroupWithBlank) {
          var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

          if (blankSlidesNum !== params.slidesPerGroup) {
            for (var i = 0; i < blankSlidesNum; i += 1) {
              var blankNode = $(doc.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
              $wrapperEl.append(blankNode);
            }

            slides = $wrapperEl.children("." + params.slideClass);
          }
        }

        if (params.slidesPerView === 'auto' && !params.loopedSlides) {
          params.loopedSlides = slides.length;
        }

        swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
        swiper.loopedSlides += params.loopAdditionalSlides;

        if (swiper.loopedSlides > slides.length) {
          swiper.loopedSlides = slides.length;
        }

        var prependSlides = [];
        var appendSlides = [];
        slides.each(function (index, el) {
          var slide = $(el);

          if (index < swiper.loopedSlides) {
            appendSlides.push(el);
          }

          if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
            prependSlides.push(el);
          }

          slide.attr('data-swiper-slide-index', index);
        });

        for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
          $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
        }

        for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
          $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
      }

      function loopFix() {
        var swiper = this;
        var params = swiper.params;
        var activeIndex = swiper.activeIndex;
        var slides = swiper.slides;
        var loopedSlides = swiper.loopedSlides;
        var allowSlidePrev = swiper.allowSlidePrev;
        var allowSlideNext = swiper.allowSlideNext;
        var snapGrid = swiper.snapGrid;
        var rtl = swiper.rtlTranslate;
        var newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        var snapTranslate = -snapGrid[activeIndex];
        var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

        if (activeIndex < loopedSlides) {
          newIndex = slides.length - loopedSlides * 3 + activeIndex;
          newIndex += loopedSlides;
          var slideChanged = swiper.slideTo(newIndex, 0, false, true);

          if (slideChanged && diff !== 0) {
            swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
          }
        } else if (params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2 || activeIndex >= slides.length - loopedSlides) {
          // Fix For Positive Oversliding
          newIndex = -slides.length + activeIndex + loopedSlides;
          newIndex += loopedSlides;
          var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);

          if (slideChanged$1 && diff !== 0) {
            swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
          }
        }

        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
      }

      function loopDestroy() {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        var slides = swiper.slides;
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
        slides.removeAttr('data-swiper-slide-index');
      }

      var loop = {
        loopCreate: loopCreate,
        loopFix: loopFix,
        loopDestroy: loopDestroy
      };

      function setGrabCursor(moving) {
        var swiper = this;

        if (Support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
          return;
        }

        var el = swiper.el;
        el.style.cursor = 'move';
        el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
        el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
        el.style.cursor = moving ? 'grabbing' : 'grab';
      }

      function unsetGrabCursor() {
        var swiper = this;

        if (Support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
          return;
        }

        swiper.el.style.cursor = '';
      }

      var grabCursor = {
        setGrabCursor: setGrabCursor,
        unsetGrabCursor: unsetGrabCursor
      };

      function appendSlide(slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;

        if (params.loop) {
          swiper.loopDestroy();
        }

        if (_typeof(slides) === 'object' && 'length' in slides) {
          for (var i = 0; i < slides.length; i += 1) {
            if (slides[i]) {
              $wrapperEl.append(slides[i]);
            }
          }
        } else {
          $wrapperEl.append(slides);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && Support.observer)) {
          swiper.update();
        }
      }

      function prependSlide(slides) {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;

        if (params.loop) {
          swiper.loopDestroy();
        }

        var newActiveIndex = activeIndex + 1;

        if (_typeof(slides) === 'object' && 'length' in slides) {
          for (var i = 0; i < slides.length; i += 1) {
            if (slides[i]) {
              $wrapperEl.prepend(slides[i]);
            }
          }

          newActiveIndex = activeIndex + slides.length;
        } else {
          $wrapperEl.prepend(slides);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && Support.observer)) {
          swiper.update();
        }

        swiper.slideTo(newActiveIndex, 0, false);
      }

      function addSlide(index, slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        var activeIndex = swiper.activeIndex;
        var activeIndexBuffer = activeIndex;

        if (params.loop) {
          activeIndexBuffer -= swiper.loopedSlides;
          swiper.loopDestroy();
          swiper.slides = $wrapperEl.children("." + params.slideClass);
        }

        var baseLength = swiper.slides.length;

        if (index <= 0) {
          swiper.prependSlide(slides);
          return;
        }

        if (index >= baseLength) {
          swiper.appendSlide(slides);
          return;
        }

        var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
        var slidesBuffer = [];

        for (var i = baseLength - 1; i >= index; i -= 1) {
          var currentSlide = swiper.slides.eq(i);
          currentSlide.remove();
          slidesBuffer.unshift(currentSlide);
        }

        if (_typeof(slides) === 'object' && 'length' in slides) {
          for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
            if (slides[i$1]) {
              $wrapperEl.append(slides[i$1]);
            }
          }

          newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
        } else {
          $wrapperEl.append(slides);
        }

        for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
          $wrapperEl.append(slidesBuffer[i$2]);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && Support.observer)) {
          swiper.update();
        }

        if (params.loop) {
          swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
          swiper.slideTo(newActiveIndex, 0, false);
        }
      }

      function removeSlide(slidesIndexes) {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;
        var activeIndexBuffer = activeIndex;

        if (params.loop) {
          activeIndexBuffer -= swiper.loopedSlides;
          swiper.loopDestroy();
          swiper.slides = $wrapperEl.children("." + params.slideClass);
        }

        var newActiveIndex = activeIndexBuffer;
        var indexToRemove;

        if (_typeof(slidesIndexes) === 'object' && 'length' in slidesIndexes) {
          for (var i = 0; i < slidesIndexes.length; i += 1) {
            indexToRemove = slidesIndexes[i];

            if (swiper.slides[indexToRemove]) {
              swiper.slides.eq(indexToRemove).remove();
            }

            if (indexToRemove < newActiveIndex) {
              newActiveIndex -= 1;
            }
          }

          newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
          indexToRemove = slidesIndexes;

          if (swiper.slides[indexToRemove]) {
            swiper.slides.eq(indexToRemove).remove();
          }

          if (indexToRemove < newActiveIndex) {
            newActiveIndex -= 1;
          }

          newActiveIndex = Math.max(newActiveIndex, 0);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && Support.observer)) {
          swiper.update();
        }

        if (params.loop) {
          swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
          swiper.slideTo(newActiveIndex, 0, false);
        }
      }

      function removeAllSlides() {
        var swiper = this;
        var slidesIndexes = [];

        for (var i = 0; i < swiper.slides.length; i += 1) {
          slidesIndexes.push(i);
        }

        swiper.removeSlide(slidesIndexes);
      }

      var manipulation = {
        appendSlide: appendSlide,
        prependSlide: prependSlide,
        addSlide: addSlide,
        removeSlide: removeSlide,
        removeAllSlides: removeAllSlides
      };

      var Device = function Device() {
        var platform = win.navigator.platform;
        var ua = win.navigator.userAgent;
        var device = {
          ios: false,
          android: false,
          androidChrome: false,
          desktop: false,
          iphone: false,
          ipod: false,
          ipad: false,
          edge: false,
          ie: false,
          firefox: false,
          macos: false,
          windows: false,
          cordova: !!(win.cordova || win.phonegap),
          phonegap: !!(win.cordova || win.phonegap),
          electron: false
        };
        var screenWidth = win.screen.width;
        var screenHeight = win.screen.height;
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        var ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
        var edge = ua.indexOf('Edge/') >= 0;
        var firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
        var windows = platform === 'Win32';
        var electron = ua.toLowerCase().indexOf('electron') >= 0;
        var macos = platform === 'MacIntel'; // iPadOs 13 fix

        if (!ipad && macos && Support.touch && (screenWidth === 1024 && screenHeight === 1366 || // Pro 12.9
        screenWidth === 834 && screenHeight === 1194 // Pro 11
        || screenWidth === 834 && screenHeight === 1112 // Pro 10.5
        || screenWidth === 768 && screenHeight === 1024 // other
        )) {
          ipad = ua.match(/(Version)\/([\d.]+)/);
          macos = false;
        }

        device.ie = ie;
        device.edge = edge;
        device.firefox = firefox; // Android

        if (android && !windows) {
          device.os = 'android';
          device.osVersion = android[2];
          device.android = true;
          device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
        }

        if (ipad || iphone || ipod) {
          device.os = 'ios';
          device.ios = true;
        } // iOS


        if (iphone && !ipod) {
          device.osVersion = iphone[2].replace(/_/g, '.');
          device.iphone = true;
        }

        if (ipad) {
          device.osVersion = ipad[2].replace(/_/g, '.');
          device.ipad = true;
        }

        if (ipod) {
          device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
          device.ipod = true;
        } // iOS 8+ changed UA


        if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
          if (device.osVersion.split('.')[0] === '10') {
            device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
          }
        } // Webview


        device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone)) || win.matchMedia && win.matchMedia('(display-mode: standalone)').matches;
        device.webview = device.webView;
        device.standalone = device.webView; // Desktop

        device.desktop = !(device.ios || device.android) || electron;

        if (device.desktop) {
          device.electron = electron;
          device.macos = macos;
          device.windows = windows;

          if (device.macos) {
            device.os = 'macos';
          }

          if (device.windows) {
            device.os = 'windows';
          }
        } // Pixel Ratio


        device.pixelRatio = win.devicePixelRatio || 1; // Export object

        return device;
      }();

      function onTouchStart(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;

        if (swiper.animating && params.preventInteractionOnTransition) {
          return;
        }

        var e = event;

        if (e.originalEvent) {
          e = e.originalEvent;
        }

        var $targetEl = $(e.target);

        if (params.touchEventsTarget === 'wrapper') {
          if (!$targetEl.closest(swiper.wrapperEl).length) {
            return;
          }
        }

        data.isTouchEvent = e.type === 'touchstart';

        if (!data.isTouchEvent && 'which' in e && e.which === 3) {
          return;
        }

        if (!data.isTouchEvent && 'button' in e && e.button > 0) {
          return;
        }

        if (data.isTouched && data.isMoved) {
          return;
        }

        if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
          swiper.allowClick = true;
          return;
        }

        if (params.swipeHandler) {
          if (!$targetEl.closest(params.swipeHandler)[0]) {
            return;
          }
        }

        touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        var startX = touches.currentX;
        var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

        var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= win.screen.width - edgeSwipeThreshold)) {
          return;
        }

        Utils.extend(data, {
          isTouched: true,
          isMoved: false,
          allowTouchCallbacks: true,
          isScrolling: undefined,
          startMoving: undefined
        });
        touches.startX = startX;
        touches.startY = startY;
        data.touchStartTime = Utils.now();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;

        if (params.threshold > 0) {
          data.allowThresholdMove = false;
        }

        if (e.type !== 'touchstart') {
          var preventDefault = true;

          if ($targetEl.is(data.formElements)) {
            preventDefault = false;
          }

          if (doc.activeElement && $(doc.activeElement).is(data.formElements) && doc.activeElement !== $targetEl[0]) {
            doc.activeElement.blur();
          }

          var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

          if (params.touchStartForcePreventDefault || shouldPreventDefault) {
            e.preventDefault();
          }
        }

        swiper.emit('touchStart', e);
      }

      function onTouchMove(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;
        var rtl = swiper.rtlTranslate;
        var e = event;

        if (e.originalEvent) {
          e = e.originalEvent;
        }

        if (!data.isTouched) {
          if (data.startMoving && data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
          }

          return;
        }

        if (data.isTouchEvent && e.type === 'mousemove') {
          return;
        }

        var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
        var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
        var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

        if (e.preventedByNestedSwiper) {
          touches.startX = pageX;
          touches.startY = pageY;
          return;
        }

        if (!swiper.allowTouchMove) {
          // isMoved = true;
          swiper.allowClick = false;

          if (data.isTouched) {
            Utils.extend(touches, {
              startX: pageX,
              startY: pageY,
              currentX: pageX,
              currentY: pageY
            });
            data.touchStartTime = Utils.now();
          }

          return;
        }

        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
          if (swiper.isVertical()) {
            // Vertical
            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
              data.isTouched = false;
              data.isMoved = false;
              return;
            }
          } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
            return;
          }
        }

        if (data.isTouchEvent && doc.activeElement) {
          if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
            data.isMoved = true;
            swiper.allowClick = false;
            return;
          }
        }

        if (data.allowTouchCallbacks) {
          swiper.emit('touchMove', e);
        }

        if (e.targetTouches && e.targetTouches.length > 1) {
          return;
        }

        touches.currentX = pageX;
        touches.currentY = pageY;
        var diffX = touches.currentX - touches.startX;
        var diffY = touches.currentY - touches.startY;

        if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) {
          return;
        }

        if (typeof data.isScrolling === 'undefined') {
          var touchAngle;

          if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
            data.isScrolling = false;
          } else {
            // eslint-disable-next-line
            if (diffX * diffX + diffY * diffY >= 25) {
              touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
              data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
            }
          }
        }

        if (data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        if (typeof data.startMoving === 'undefined') {
          if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
            data.startMoving = true;
          }
        }

        if (data.isScrolling) {
          data.isTouched = false;
          return;
        }

        if (!data.startMoving) {
          return;
        }

        swiper.allowClick = false;

        if (!params.cssMode) {
          e.preventDefault();
        }

        if (params.touchMoveStopPropagation && !params.nested) {
          e.stopPropagation();
        }

        if (!data.isMoved) {
          if (params.loop) {
            swiper.loopFix();
          }

          data.startTranslate = swiper.getTranslate();
          swiper.setTransition(0);

          if (swiper.animating) {
            swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
          }

          data.allowMomentumBounce = false; // Grab Cursor

          if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(true);
          }

          swiper.emit('sliderFirstMove', e);
        }

        swiper.emit('sliderMove', e);
        data.isMoved = true;
        var diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;
        diff *= params.touchRatio;

        if (rtl) {
          diff = -diff;
        }

        swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
        data.currentTranslate = diff + data.startTranslate;
        var disableParentSwiper = true;
        var resistanceRatio = params.resistanceRatio;

        if (params.touchReleaseOnEdges) {
          resistanceRatio = 0;
        }

        if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
          disableParentSwiper = false;

          if (params.resistance) {
            data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
          }
        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
          disableParentSwiper = false;

          if (params.resistance) {
            data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
          }
        }

        if (disableParentSwiper) {
          e.preventedByNestedSwiper = true;
        } // Directions locks


        if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
          data.currentTranslate = data.startTranslate;
        }

        if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
          data.currentTranslate = data.startTranslate;
        } // Threshold


        if (params.threshold > 0) {
          if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
            if (!data.allowThresholdMove) {
              data.allowThresholdMove = true;
              touches.startX = touches.currentX;
              touches.startY = touches.currentY;
              data.currentTranslate = data.startTranslate;
              touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
              return;
            }
          } else {
            data.currentTranslate = data.startTranslate;
            return;
          }
        }

        if (!params.followFinger || params.cssMode) {
          return;
        } // Update active index in free mode


        if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        if (params.freeMode) {
          // Velocity
          if (data.velocities.length === 0) {
            data.velocities.push({
              position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
              time: data.touchStartTime
            });
          }

          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
            time: Utils.now()
          });
        } // Update progress


        swiper.updateProgress(data.currentTranslate); // Update translate

        swiper.setTranslate(data.currentTranslate);
      }

      function onTouchEnd(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;
        var rtl = swiper.rtlTranslate;
        var $wrapperEl = swiper.$wrapperEl;
        var slidesGrid = swiper.slidesGrid;
        var snapGrid = swiper.snapGrid;
        var e = event;

        if (e.originalEvent) {
          e = e.originalEvent;
        }

        if (data.allowTouchCallbacks) {
          swiper.emit('touchEnd', e);
        }

        data.allowTouchCallbacks = false;

        if (!data.isTouched) {
          if (data.isMoved && params.grabCursor) {
            swiper.setGrabCursor(false);
          }

          data.isMoved = false;
          data.startMoving = false;
          return;
        } // Return Grab Cursor


        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(false);
        } // Time diff


        var touchEndTime = Utils.now();
        var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

        if (swiper.allowClick) {
          swiper.updateClickedSlide(e);
          swiper.emit('tap click', e);

          if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
            swiper.emit('doubleTap doubleClick', e);
          }
        }

        data.lastClickTime = Utils.now();
        Utils.nextTick(function () {
          if (!swiper.destroyed) {
            swiper.allowClick = true;
          }
        });

        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
          data.isTouched = false;
          data.isMoved = false;
          data.startMoving = false;
          return;
        }

        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        var currentPos;

        if (params.followFinger) {
          currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
          currentPos = -data.currentTranslate;
        }

        if (params.cssMode) {
          return;
        }

        if (params.freeMode) {
          if (currentPos < -swiper.minTranslate()) {
            swiper.slideTo(swiper.activeIndex);
            return;
          }

          if (currentPos > -swiper.maxTranslate()) {
            if (swiper.slides.length < snapGrid.length) {
              swiper.slideTo(snapGrid.length - 1);
            } else {
              swiper.slideTo(swiper.slides.length - 1);
            }

            return;
          }

          if (params.freeModeMomentum) {
            if (data.velocities.length > 1) {
              var lastMoveEvent = data.velocities.pop();
              var velocityEvent = data.velocities.pop();
              var distance = lastMoveEvent.position - velocityEvent.position;
              var time = lastMoveEvent.time - velocityEvent.time;
              swiper.velocity = distance / time;
              swiper.velocity /= 2;

              if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                swiper.velocity = 0;
              } // this implies that the user stopped moving a finger then released.
              // There would be no events with distance zero, so the last event is stale.


              if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {
                swiper.velocity = 0;
              }
            } else {
              swiper.velocity = 0;
            }

            swiper.velocity *= params.freeModeMomentumVelocityRatio;
            data.velocities.length = 0;
            var momentumDuration = 1000 * params.freeModeMomentumRatio;
            var momentumDistance = swiper.velocity * momentumDuration;
            var newPosition = swiper.translate + momentumDistance;

            if (rtl) {
              newPosition = -newPosition;
            }

            var doBounce = false;
            var afterBouncePosition;
            var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
            var needsLoopFix;

            if (newPosition < swiper.maxTranslate()) {
              if (params.freeModeMomentumBounce) {
                if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                  newPosition = swiper.maxTranslate() - bounceAmount;
                }

                afterBouncePosition = swiper.maxTranslate();
                doBounce = true;
                data.allowMomentumBounce = true;
              } else {
                newPosition = swiper.maxTranslate();
              }

              if (params.loop && params.centeredSlides) {
                needsLoopFix = true;
              }
            } else if (newPosition > swiper.minTranslate()) {
              if (params.freeModeMomentumBounce) {
                if (newPosition - swiper.minTranslate() > bounceAmount) {
                  newPosition = swiper.minTranslate() + bounceAmount;
                }

                afterBouncePosition = swiper.minTranslate();
                doBounce = true;
                data.allowMomentumBounce = true;
              } else {
                newPosition = swiper.minTranslate();
              }

              if (params.loop && params.centeredSlides) {
                needsLoopFix = true;
              }
            } else if (params.freeModeSticky) {
              var nextSlide;

              for (var j = 0; j < snapGrid.length; j += 1) {
                if (snapGrid[j] > -newPosition) {
                  nextSlide = j;
                  break;
                }
              }

              if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                newPosition = snapGrid[nextSlide];
              } else {
                newPosition = snapGrid[nextSlide - 1];
              }

              newPosition = -newPosition;
            }

            if (needsLoopFix) {
              swiper.once('transitionEnd', function () {
                swiper.loopFix();
              });
            } // Fix duration


            if (swiper.velocity !== 0) {
              if (rtl) {
                momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
              } else {
                momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
              }
            } else if (params.freeModeSticky) {
              swiper.slideToClosest();
              return;
            }

            if (params.freeModeMomentumBounce && doBounce) {
              swiper.updateProgress(afterBouncePosition);
              swiper.setTransition(momentumDuration);
              swiper.setTranslate(newPosition);
              swiper.transitionStart(true, swiper.swipeDirection);
              swiper.animating = true;
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed || !data.allowMomentumBounce) {
                  return;
                }

                swiper.emit('momentumBounce');
                swiper.setTransition(params.speed);
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) {
                    return;
                  }

                  swiper.transitionEnd();
                });
              });
            } else if (swiper.velocity) {
              swiper.updateProgress(newPosition);
              swiper.setTransition(momentumDuration);
              swiper.setTranslate(newPosition);
              swiper.transitionStart(true, swiper.swipeDirection);

              if (!swiper.animating) {
                swiper.animating = true;
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) {
                    return;
                  }

                  swiper.transitionEnd();
                });
              }
            } else {
              swiper.updateProgress(newPosition);
            }

            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
          }

          if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }

          return;
        } // Find current slide


        var stopIndex = 0;
        var groupSize = swiper.slidesSizesGrid[0];

        for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
          if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
            if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
              stopIndex = i;
              groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
            }
          } else if (currentPos >= slidesGrid[i]) {
            stopIndex = i;
            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
          }
        } // Find current slide size


        var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

        if (timeDiff > params.longSwipesMs) {
          // Long touches
          if (!params.longSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
          }

          if (swiper.swipeDirection === 'next') {
            if (ratio >= params.longSwipesRatio) {
              swiper.slideTo(stopIndex + params.slidesPerGroup);
            } else {
              swiper.slideTo(stopIndex);
            }
          }

          if (swiper.swipeDirection === 'prev') {
            if (ratio > 1 - params.longSwipesRatio) {
              swiper.slideTo(stopIndex + params.slidesPerGroup);
            } else {
              swiper.slideTo(stopIndex);
            }
          }
        } else {
          // Short swipes
          if (!params.shortSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
          }

          var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

          if (!isNavButtonTarget) {
            if (swiper.swipeDirection === 'next') {
              swiper.slideTo(stopIndex + params.slidesPerGroup);
            }

            if (swiper.swipeDirection === 'prev') {
              swiper.slideTo(stopIndex);
            }
          } else if (e.target === swiper.navigation.nextEl) {
            swiper.slideTo(stopIndex + params.slidesPerGroup);
          } else {
            swiper.slideTo(stopIndex);
          }
        }
      }

      function onResize() {
        var swiper = this;
        var params = swiper.params;
        var el = swiper.el;

        if (el && el.offsetWidth === 0) {
          return;
        } // Breakpoints


        if (params.breakpoints) {
          swiper.setBreakpoint();
        } // Save locks


        var allowSlideNext = swiper.allowSlideNext;
        var allowSlidePrev = swiper.allowSlidePrev;
        var snapGrid = swiper.snapGrid; // Disable locks on resize

        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;
        swiper.updateSize();
        swiper.updateSlides();

        if (params.freeMode) {
          var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();

          if (params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          swiper.updateSlidesClasses();

          if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            swiper.slideTo(swiper.activeIndex, 0, false, true);
          }
        }

        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
          swiper.autoplay.run();
        } // Return locks after resize


        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;

        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }
      }

      function onClick(e) {
        var swiper = this;

        if (!swiper.allowClick) {
          if (swiper.params.preventClicks) {
            e.preventDefault();
          }

          if (swiper.params.preventClicksPropagation && swiper.animating) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }
        }
      }

      function onScroll() {
        var swiper = this;
        var wrapperEl = swiper.wrapperEl;
        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? -wrapperEl.scrollLeft : -wrapperEl.scrollTop; // eslint-disable-next-line

        if (swiper.translate === -0) {
          swiper.translate = 0;
        }

        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        var newProgress;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

        if (translatesDiff === 0) {
          newProgress = 0;
        } else {
          newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
        }

        if (newProgress !== swiper.progress) {
          swiper.updateProgress(swiper.translate);
        }

        swiper.emit('setTranslate', swiper.translate, false);
      }

      var dummyEventAttached = false;

      function dummyEventListener() {}

      function attachEvents() {
        var swiper = this;
        var params = swiper.params;
        var touchEvents = swiper.touchEvents;
        var el = swiper.el;
        var wrapperEl = swiper.wrapperEl;
        swiper.onTouchStart = onTouchStart.bind(swiper);
        swiper.onTouchMove = onTouchMove.bind(swiper);
        swiper.onTouchEnd = onTouchEnd.bind(swiper);

        if (params.cssMode) {
          swiper.onScroll = onScroll.bind(swiper);
        }

        swiper.onClick = onClick.bind(swiper);
        var capture = !!params.nested; // Touch Events

        if (!Support.touch && Support.pointerEvents) {
          el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
          doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
          doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
        } else {
          if (Support.touch) {
            var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? {
              passive: true,
              capture: false
            } : false;
            el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
            el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? {
              passive: false,
              capture: capture
            } : capture);
            el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

            if (touchEvents.cancel) {
              el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }

            if (!dummyEventAttached) {
              doc.addEventListener('touchstart', dummyEventListener);
              dummyEventAttached = true;
            }
          }

          if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
            el.addEventListener('mousedown', swiper.onTouchStart, false);
            doc.addEventListener('mousemove', swiper.onTouchMove, capture);
            doc.addEventListener('mouseup', swiper.onTouchEnd, false);
          }
        } // Prevent Links Clicks


        if (params.preventClicks || params.preventClicksPropagation) {
          el.addEventListener('click', swiper.onClick, true);
        }

        if (params.cssMode) {
          wrapperEl.addEventListener('scroll', swiper.onScroll);
        } // Resize handler


        swiper.on(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      }

      function detachEvents() {
        var swiper = this;
        var params = swiper.params;
        var touchEvents = swiper.touchEvents;
        var el = swiper.el;
        var wrapperEl = swiper.wrapperEl;
        var capture = !!params.nested; // Touch Events

        if (!Support.touch && Support.pointerEvents) {
          el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
          doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
          doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
        } else {
          if (Support.touch) {
            var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? {
              passive: true,
              capture: false
            } : false;
            el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
            el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
            el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

            if (touchEvents.cancel) {
              el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
          }

          if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
            el.removeEventListener('mousedown', swiper.onTouchStart, false);
            doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
            doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
          }
        } // Prevent Links Clicks


        if (params.preventClicks || params.preventClicksPropagation) {
          el.removeEventListener('click', swiper.onClick, true);
        }

        if (params.cssMode) {
          wrapperEl.removeEventListener('scroll', swiper.onScroll);
        } // Resize handler


        swiper.off(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
      }

      var events = {
        attachEvents: attachEvents,
        detachEvents: detachEvents
      };

      function setBreakpoint() {
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var initialized = swiper.initialized;
        var loopedSlides = swiper.loopedSlides;
        if (loopedSlides === void 0) loopedSlides = 0;
        var params = swiper.params;
        var $el = swiper.$el;
        var breakpoints = params.breakpoints;

        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) {
          return;
        } // Get breakpoint for window width and update parameters


        var breakpoint = swiper.getBreakpoint(breakpoints);

        if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
          var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

          if (breakpointOnlyParams) {
            ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerColumn'].forEach(function (param) {
              var paramValue = breakpointOnlyParams[param];

              if (typeof paramValue === 'undefined') {
                return;
              }

              if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
                breakpointOnlyParams[param] = 'auto';
              } else if (param === 'slidesPerView') {
                breakpointOnlyParams[param] = parseFloat(paramValue);
              } else {
                breakpointOnlyParams[param] = parseInt(paramValue, 10);
              }
            });
          }

          var breakpointParams = breakpointOnlyParams || swiper.originalParams;
          var wasMultiRow = params.slidesPerColumn > 1;
          var isMultiRow = breakpointParams.slidesPerColumn > 1;

          if (wasMultiRow && !isMultiRow) {
            $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
          } else if (!wasMultiRow && isMultiRow) {
            $el.addClass(params.containerModifierClass + "multirow");

            if (breakpointParams.slidesPerColumnFill === 'column') {
              $el.addClass(params.containerModifierClass + "multirow-column");
            }
          }

          var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
          var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

          if (directionChanged && initialized) {
            swiper.changeDirection();
          }

          Utils.extend(swiper.params, breakpointParams);
          Utils.extend(swiper, {
            allowTouchMove: swiper.params.allowTouchMove,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev
          });
          swiper.currentBreakpoint = breakpoint;

          if (needsReLoop && initialized) {
            swiper.loopDestroy();
            swiper.loopCreate();
            swiper.updateSlides();
            swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
          }

          swiper.emit('breakpoint', breakpointParams);
        }
      }

      function getBreakpoint(breakpoints) {
        // Get breakpoint for window width
        if (!breakpoints) {
          return undefined;
        }

        var breakpoint = false;
        var points = [];
        Object.keys(breakpoints).forEach(function (point) {
          points.push(point);
        });
        points.sort(function (a, b) {
          return parseInt(a, 10) - parseInt(b, 10);
        });

        for (var i = 0; i < points.length; i += 1) {
          var point = points[i];

          if (point <= win.innerWidth) {
            breakpoint = point;
          }
        }

        return breakpoint || 'max';
      }

      var breakpoints = {
        setBreakpoint: setBreakpoint,
        getBreakpoint: getBreakpoint
      };

      function addClasses() {
        var swiper = this;
        var classNames = swiper.classNames;
        var params = swiper.params;
        var rtl = swiper.rtl;
        var $el = swiper.$el;
        var suffixes = [];
        suffixes.push('initialized');
        suffixes.push(params.direction);

        if (params.freeMode) {
          suffixes.push('free-mode');
        }

        if (params.autoHeight) {
          suffixes.push('autoheight');
        }

        if (rtl) {
          suffixes.push('rtl');
        }

        if (params.slidesPerColumn > 1) {
          suffixes.push('multirow');

          if (params.slidesPerColumnFill === 'column') {
            suffixes.push('multirow-column');
          }
        }

        if (Device.android) {
          suffixes.push('android');
        }

        if (Device.ios) {
          suffixes.push('ios');
        }

        if (params.cssMode) {
          suffixes.push('css-mode');
        }

        suffixes.forEach(function (suffix) {
          classNames.push(params.containerModifierClass + suffix);
        });
        $el.addClass(classNames.join(' '));
      }

      function removeClasses() {
        var swiper = this;
        var $el = swiper.$el;
        var classNames = swiper.classNames;
        $el.removeClass(classNames.join(' '));
      }

      var classes = {
        addClasses: addClasses,
        removeClasses: removeClasses
      };

      function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        var image;

        function onReady() {
          if (callback) {
            callback();
          }
        }

        if (!imageEl.complete || !checkForComplete) {
          if (src) {
            image = new win.Image();
            image.onload = onReady;
            image.onerror = onReady;

            if (sizes) {
              image.sizes = sizes;
            }

            if (srcset) {
              image.srcset = srcset;
            }

            if (src) {
              image.src = src;
            }
          } else {
            onReady();
          }
        } else {
          // image already loaded...
          onReady();
        }
      }

      function preloadImages() {
        var swiper = this;
        swiper.imagesToLoad = swiper.$el.find('img');

        function onReady() {
          if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) {
            return;
          }

          if (swiper.imagesLoaded !== undefined) {
            swiper.imagesLoaded += 1;
          }

          if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
            if (swiper.params.updateOnImagesReady) {
              swiper.update();
            }

            swiper.emit('imagesReady');
          }
        }

        for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
          var imageEl = swiper.imagesToLoad[i];
          swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
        }
      }

      var images = {
        loadImage: loadImage,
        preloadImages: preloadImages
      };

      function checkOverflow() {
        var swiper = this;
        var wasLocked = swiper.isLocked;
        swiper.isLocked = swiper.snapGrid.length === 1;
        swiper.allowSlideNext = !swiper.isLocked;
        swiper.allowSlidePrev = !swiper.isLocked; // events

        if (wasLocked !== swiper.isLocked) {
          swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
        }

        if (wasLocked && wasLocked !== swiper.isLocked) {
          swiper.isEnd = false;
          swiper.navigation.update();
        }
      }

      var checkOverflow$1 = {
        checkOverflow: checkOverflow
      };
      var defaults = {
        init: true,
        direction: 'horizontal',
        touchEventsTarget: 'container',
        initialSlide: 0,
        speed: 300,
        cssMode: false,
        //
        preventInteractionOnTransition: false,
        // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,
        // Free mode
        freeMode: false,
        freeModeMomentum: true,
        freeModeMomentumRatio: 1,
        freeModeMomentumBounce: true,
        freeModeMomentumBounceRatio: 1,
        freeModeMomentumVelocityRatio: 1,
        freeModeSticky: false,
        freeModeMinimumVelocity: 0.02,
        // Autoheight
        autoHeight: false,
        // Set wrapper width
        setWrapperSize: false,
        // Virtual Translate
        virtualTranslate: false,
        // Effects
        effect: 'slide',
        // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
        // Breakpoints
        breakpoints: undefined,
        // Slides grid
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerColumnFill: 'column',
        slidesPerGroup: 1,
        centeredSlides: false,
        slidesOffsetBefore: 0,
        // in px
        slidesOffsetAfter: 0,
        // in px
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,
        // Disable swiper and hide navigation when container not overflow
        watchOverflow: false,
        // Round length
        roundLengths: false,
        // Touches
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: false,
        touchStartPreventDefault: true,
        touchStartForcePreventDefault: false,
        touchReleaseOnEdges: false,
        // Unique Navigation Elements
        uniqueNavElements: true,
        // Resistance
        resistance: true,
        resistanceRatio: 0.85,
        // Progress
        watchSlidesProgress: false,
        watchSlidesVisibility: false,
        // Cursor
        grabCursor: false,
        // Clicks
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,
        // Images
        preloadImages: true,
        updateOnImagesReady: true,
        // loop
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,
        // Swiping/no swiping
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        // '.swipe-handler',
        noSwiping: true,
        noSwipingClass: 'swiper-no-swiping',
        noSwipingSelector: null,
        // Passive Listeners
        passiveListeners: true,
        // NS
        containerModifierClass: 'swiper-container-',
        // NEW
        slideClass: 'swiper-slide',
        slideBlankClass: 'swiper-slide-invisible-blank',
        slideActiveClass: 'swiper-slide-active',
        slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
        slideVisibleClass: 'swiper-slide-visible',
        slideDuplicateClass: 'swiper-slide-duplicate',
        slideNextClass: 'swiper-slide-next',
        slideDuplicateNextClass: 'swiper-slide-duplicate-next',
        slidePrevClass: 'swiper-slide-prev',
        slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
        wrapperClass: 'swiper-wrapper',
        // Callbacks
        runCallbacksOnInit: true
      };
      /* eslint no-param-reassign: "off" */

      var prototypes = {
        update: update,
        translate: translate,
        transition: transition$1,
        slide: slide,
        loop: loop,
        grabCursor: grabCursor,
        manipulation: manipulation,
        events: events,
        breakpoints: breakpoints,
        checkOverflow: checkOverflow$1,
        classes: classes,
        images: images
      };
      var extendedDefaults = {};

      var Swiper = /*@__PURE__*/function (SwiperClass) {
        function Swiper() {
          var assign;
          var args = [],
              len = arguments.length;

          while (len--) {
            args[len] = arguments[len];
          }

          var el;
          var params;

          if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
            params = args[0];
          } else {
            assign = args, el = assign[0], params = assign[1];
          }

          if (!params) {
            params = {};
          }

          params = Utils.extend({}, params);

          if (el && !params.el) {
            params.el = el;
          }

          SwiperClass.call(this, params);
          Object.keys(prototypes).forEach(function (prototypeGroup) {
            Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
              if (!Swiper.prototype[protoMethod]) {
                Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
              }
            });
          }); // Swiper Instance

          var swiper = this;

          if (typeof swiper.modules === 'undefined') {
            swiper.modules = {};
          }

          Object.keys(swiper.modules).forEach(function (moduleName) {
            var module = swiper.modules[moduleName];

            if (module.params) {
              var moduleParamName = Object.keys(module.params)[0];
              var moduleParams = module.params[moduleParamName];

              if (_typeof(moduleParams) !== 'object' || moduleParams === null) {
                return;
              }

              if (!(moduleParamName in params && 'enabled' in moduleParams)) {
                return;
              }

              if (params[moduleParamName] === true) {
                params[moduleParamName] = {
                  enabled: true
                };
              }

              if (_typeof(params[moduleParamName]) === 'object' && !('enabled' in params[moduleParamName])) {
                params[moduleParamName].enabled = true;
              }

              if (!params[moduleParamName]) {
                params[moduleParamName] = {
                  enabled: false
                };
              }
            }
          }); // Extend defaults with modules params

          var swiperParams = Utils.extend({}, defaults);
          swiper.useModulesParams(swiperParams); // Extend defaults with passed params

          swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
          swiper.originalParams = Utils.extend({}, swiper.params);
          swiper.passedParams = Utils.extend({}, params); // Save Dom lib

          swiper.$ = $; // Find el

          var $el = $(swiper.params.el);
          el = $el[0];

          if (!el) {
            return undefined;
          }

          if ($el.length > 1) {
            var swipers = [];
            $el.each(function (index, containerEl) {
              var newParams = Utils.extend({}, params, {
                el: containerEl
              });
              swipers.push(new Swiper(newParams));
            });
            return swipers;
          }

          el.swiper = swiper;
          $el.data('swiper', swiper); // Find Wrapper

          var $wrapperEl;

          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            $wrapperEl = $(el.shadowRoot.querySelector("." + swiper.params.wrapperClass)); // Children needs to return slot items

            $wrapperEl.children = function (options) {
              return $el.children(options);
            };
          } else {
            $wrapperEl = $el.children("." + swiper.params.wrapperClass);
          } // Extend Swiper


          Utils.extend(swiper, {
            $el: $el,
            el: el,
            $wrapperEl: $wrapperEl,
            wrapperEl: $wrapperEl[0],
            // Classes
            classNames: [],
            // Slides
            slides: $(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            // isDirection
            isHorizontal: function isHorizontal() {
              return swiper.params.direction === 'horizontal';
            },
            isVertical: function isVertical() {
              return swiper.params.direction === 'vertical';
            },
            // RTL
            rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
            rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
            wrongRTL: $wrapperEl.css('display') === '-webkit-box',
            // Indexes
            activeIndex: 0,
            realIndex: 0,
            //
            isBeginning: true,
            isEnd: false,
            // Props
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: false,
            // Locks
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
            // Touch Events
            touchEvents: function touchEvents() {
              var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
              var desktop = ['mousedown', 'mousemove', 'mouseup'];

              if (Support.pointerEvents) {
                desktop = ['pointerdown', 'pointermove', 'pointerup'];
              }

              swiper.touchEventsTouch = {
                start: touch[0],
                move: touch[1],
                end: touch[2],
                cancel: touch[3]
              };
              swiper.touchEventsDesktop = {
                start: desktop[0],
                move: desktop[1],
                end: desktop[2]
              };
              return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
            }(),
            touchEventsData: {
              isTouched: undefined,
              isMoved: undefined,
              allowTouchCallbacks: undefined,
              touchStartTime: undefined,
              isScrolling: undefined,
              currentTranslate: undefined,
              startTranslate: undefined,
              allowThresholdMove: undefined,
              // Form elements to match
              formElements: 'input, select, option, textarea, button, video',
              // Last click time
              lastClickTime: Utils.now(),
              clickTimeout: undefined,
              // Velocities
              velocities: [],
              allowMomentumBounce: undefined,
              isTouchEvent: undefined,
              startMoving: undefined
            },
            // Clicks
            allowClick: true,
            // Touches
            allowTouchMove: swiper.params.allowTouchMove,
            touches: {
              startX: 0,
              startY: 0,
              currentX: 0,
              currentY: 0,
              diff: 0
            },
            // Images
            imagesToLoad: [],
            imagesLoaded: 0
          }); // Install Modules

          swiper.useModules(); // Init

          if (swiper.params.init) {
            swiper.init();
          } // Return app instance


          return swiper;
        }

        if (SwiperClass) Swiper.__proto__ = SwiperClass;
        Swiper.prototype = Object.create(SwiperClass && SwiperClass.prototype);
        Swiper.prototype.constructor = Swiper;
        var staticAccessors = {
          extendedDefaults: {
            configurable: true
          },
          defaults: {
            configurable: true
          },
          Class: {
            configurable: true
          },
          $: {
            configurable: true
          }
        };

        Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic() {
          var swiper = this;
          var params = swiper.params;
          var slides = swiper.slides;
          var slidesGrid = swiper.slidesGrid;
          var swiperSize = swiper.size;
          var activeIndex = swiper.activeIndex;
          var spv = 1;

          if (params.centeredSlides) {
            var slideSize = slides[activeIndex].swiperSlideSize;
            var breakLoop;

            for (var i = activeIndex + 1; i < slides.length; i += 1) {
              if (slides[i] && !breakLoop) {
                slideSize += slides[i].swiperSlideSize;
                spv += 1;

                if (slideSize > swiperSize) {
                  breakLoop = true;
                }
              }
            }

            for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
              if (slides[i$1] && !breakLoop) {
                slideSize += slides[i$1].swiperSlideSize;
                spv += 1;

                if (slideSize > swiperSize) {
                  breakLoop = true;
                }
              }
            }
          } else {
            for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
              if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
                spv += 1;
              }
            }
          }

          return spv;
        };

        Swiper.prototype.update = function update() {
          var swiper = this;

          if (!swiper || swiper.destroyed) {
            return;
          }

          var snapGrid = swiper.snapGrid;
          var params = swiper.params; // Breakpoints

          if (params.breakpoints) {
            swiper.setBreakpoint();
          }

          swiper.updateSize();
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();

          function setTranslate() {
            var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
            var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }

          var translated;

          if (swiper.params.freeMode) {
            setTranslate();

            if (swiper.params.autoHeight) {
              swiper.updateAutoHeight();
            }
          } else {
            if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
              translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
              translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            }

            if (!translated) {
              setTranslate();
            }
          }

          if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
          }

          swiper.emit('update');
        };

        Swiper.prototype.changeDirection = function changeDirection(newDirection, needUpdate) {
          if (needUpdate === void 0) needUpdate = true;
          var swiper = this;
          var currentDirection = swiper.params.direction;

          if (!newDirection) {
            // eslint-disable-next-line
            newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
          }

          if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
            return swiper;
          }

          swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
          swiper.params.direction = newDirection;
          swiper.slides.each(function (slideIndex, slideEl) {
            if (newDirection === 'vertical') {
              slideEl.style.width = '';
            } else {
              slideEl.style.height = '';
            }
          });
          swiper.emit('changeDirection');

          if (needUpdate) {
            swiper.update();
          }

          return swiper;
        };

        Swiper.prototype.init = function init() {
          var swiper = this;

          if (swiper.initialized) {
            return;
          }

          swiper.emit('beforeInit'); // Set breakpoint

          if (swiper.params.breakpoints) {
            swiper.setBreakpoint();
          } // Add Classes


          swiper.addClasses(); // Create loop

          if (swiper.params.loop) {
            swiper.loopCreate();
          } // Update size


          swiper.updateSize(); // Update slides

          swiper.updateSlides();

          if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
          } // Set Grab Cursor


          if (swiper.params.grabCursor) {
            swiper.setGrabCursor();
          }

          if (swiper.params.preloadImages) {
            swiper.preloadImages();
          } // Slide To Initial Slide


          if (swiper.params.loop) {
            swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
          } else {
            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
          } // Attach events


          swiper.attachEvents(); // Init Flag

          swiper.initialized = true; // Emit

          swiper.emit('init');
        };

        Swiper.prototype.destroy = function destroy(deleteInstance, cleanStyles) {
          if (deleteInstance === void 0) deleteInstance = true;
          if (cleanStyles === void 0) cleanStyles = true;
          var swiper = this;
          var params = swiper.params;
          var $el = swiper.$el;
          var $wrapperEl = swiper.$wrapperEl;
          var slides = swiper.slides;

          if (typeof swiper.params === 'undefined' || swiper.destroyed) {
            return null;
          }

          swiper.emit('beforeDestroy'); // Init Flag

          swiper.initialized = false; // Detach events

          swiper.detachEvents(); // Destroy loop

          if (params.loop) {
            swiper.loopDestroy();
          } // Cleanup styles


          if (cleanStyles) {
            swiper.removeClasses();
            $el.removeAttr('style');
            $wrapperEl.removeAttr('style');

            if (slides && slides.length) {
              slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
            }
          }

          swiper.emit('destroy'); // Detach emitter events

          Object.keys(swiper.eventsListeners).forEach(function (eventName) {
            swiper.off(eventName);
          });

          if (deleteInstance !== false) {
            swiper.$el[0].swiper = null;
            swiper.$el.data('swiper', null);
            Utils.deleteProps(swiper);
          }

          swiper.destroyed = true;
          return null;
        };

        Swiper.extendDefaults = function extendDefaults(newDefaults) {
          Utils.extend(extendedDefaults, newDefaults);
        };

        staticAccessors.extendedDefaults.get = function () {
          return extendedDefaults;
        };

        staticAccessors.defaults.get = function () {
          return defaults;
        };

        staticAccessors.Class.get = function () {
          return SwiperClass;
        };

        staticAccessors.$.get = function () {
          return $;
        };

        Object.defineProperties(Swiper, staticAccessors);
        return Swiper;
      }(SwiperClass);

      var Device$1 = {
        name: 'device',
        proto: {
          device: Device
        },
        "static": {
          device: Device
        }
      };
      var Support$1 = {
        name: 'support',
        proto: {
          support: Support
        },
        "static": {
          support: Support
        }
      };

      var Browser = function Browser() {
        function isSafari() {
          var ua = win.navigator.userAgent.toLowerCase();
          return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
        }

        return {
          isEdge: !!win.navigator.userAgent.match(/Edge/g),
          isSafari: isSafari(),
          isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent)
        };
      }();

      var Browser$1 = {
        name: 'browser',
        proto: {
          browser: Browser
        },
        "static": {
          browser: Browser
        }
      };
      var Resize = {
        name: 'resize',
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            resize: {
              resizeHandler: function resizeHandler() {
                if (!swiper || swiper.destroyed || !swiper.initialized) {
                  return;
                }

                swiper.emit('beforeResize');
                swiper.emit('resize');
              },
              orientationChangeHandler: function orientationChangeHandler() {
                if (!swiper || swiper.destroyed || !swiper.initialized) {
                  return;
                }

                swiper.emit('orientationchange');
              }
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this; // Emit resize

            win.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

            win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
          },
          destroy: function destroy() {
            var swiper = this;
            win.removeEventListener('resize', swiper.resize.resizeHandler);
            win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
          }
        }
      };
      var Observer = {
        func: win.MutationObserver || win.WebkitMutationObserver,
        attach: function attach(target, options) {
          if (options === void 0) options = {};
          var swiper = this;
          var ObserverFunc = Observer.func;
          var observer = new ObserverFunc(function (mutations) {
            // The observerUpdate event should only be triggered
            // once despite the number of mutations.  Additional
            // triggers are redundant and are very costly
            if (mutations.length === 1) {
              swiper.emit('observerUpdate', mutations[0]);
              return;
            }

            var observerUpdate = function observerUpdate() {
              swiper.emit('observerUpdate', mutations[0]);
            };

            if (win.requestAnimationFrame) {
              win.requestAnimationFrame(observerUpdate);
            } else {
              win.setTimeout(observerUpdate, 0);
            }
          });
          observer.observe(target, {
            attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
            childList: typeof options.childList === 'undefined' ? true : options.childList,
            characterData: typeof options.characterData === 'undefined' ? true : options.characterData
          });
          swiper.observer.observers.push(observer);
        },
        init: function init() {
          var swiper = this;

          if (!Support.observer || !swiper.params.observer) {
            return;
          }

          if (swiper.params.observeParents) {
            var containerParents = swiper.$el.parents();

            for (var i = 0; i < containerParents.length; i += 1) {
              swiper.observer.attach(containerParents[i]);
            }
          } // Observe container


          swiper.observer.attach(swiper.$el[0], {
            childList: swiper.params.observeSlideChildren
          }); // Observe wrapper

          swiper.observer.attach(swiper.$wrapperEl[0], {
            attributes: false
          });
        },
        destroy: function destroy() {
          var swiper = this;
          swiper.observer.observers.forEach(function (observer) {
            observer.disconnect();
          });
          swiper.observer.observers = [];
        }
      };
      var Observer$1 = {
        name: 'observer',
        params: {
          observer: false,
          observeParents: false,
          observeSlideChildren: false
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            observer: {
              init: Observer.init.bind(swiper),
              attach: Observer.attach.bind(swiper),
              destroy: Observer.destroy.bind(swiper),
              observers: []
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;
            swiper.observer.init();
          },
          destroy: function destroy() {
            var swiper = this;
            swiper.observer.destroy();
          }
        }
      };
      var Virtual = {
        update: function update(force) {
          var swiper = this;
          var ref = swiper.params;
          var slidesPerView = ref.slidesPerView;
          var slidesPerGroup = ref.slidesPerGroup;
          var centeredSlides = ref.centeredSlides;
          var ref$1 = swiper.params.virtual;
          var addSlidesBefore = ref$1.addSlidesBefore;
          var addSlidesAfter = ref$1.addSlidesAfter;
          var ref$2 = swiper.virtual;
          var previousFrom = ref$2.from;
          var previousTo = ref$2.to;
          var slides = ref$2.slides;
          var previousSlidesGrid = ref$2.slidesGrid;
          var renderSlide = ref$2.renderSlide;
          var previousOffset = ref$2.offset;
          swiper.updateActiveIndex();
          var activeIndex = swiper.activeIndex || 0;
          var offsetProp;

          if (swiper.rtlTranslate) {
            offsetProp = 'right';
          } else {
            offsetProp = swiper.isHorizontal() ? 'left' : 'top';
          }

          var slidesAfter;
          var slidesBefore;

          if (centeredSlides) {
            slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
            slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
          } else {
            slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
            slidesBefore = slidesPerGroup + addSlidesAfter;
          }

          var from = Math.max((activeIndex || 0) - slidesBefore, 0);
          var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
          var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
          Utils.extend(swiper.virtual, {
            from: from,
            to: to,
            offset: offset,
            slidesGrid: swiper.slidesGrid
          });

          function onRendered() {
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();

            if (swiper.lazy && swiper.params.lazy.enabled) {
              swiper.lazy.load();
            }
          }

          if (previousFrom === from && previousTo === to && !force) {
            if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
              swiper.slides.css(offsetProp, offset + "px");
            }

            swiper.updateProgress();
            return;
          }

          if (swiper.params.virtual.renderExternal) {
            swiper.params.virtual.renderExternal.call(swiper, {
              offset: offset,
              from: from,
              to: to,
              slides: function getSlides() {
                var slidesToRender = [];

                for (var i = from; i <= to; i += 1) {
                  slidesToRender.push(slides[i]);
                }

                return slidesToRender;
              }()
            });
            onRendered();
            return;
          }

          var prependIndexes = [];
          var appendIndexes = [];

          if (force) {
            swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
          } else {
            for (var i = previousFrom; i <= previousTo; i += 1) {
              if (i < from || i > to) {
                swiper.$wrapperEl.find("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + i + "\"]").remove();
              }
            }
          }

          for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
            if (i$1 >= from && i$1 <= to) {
              if (typeof previousTo === 'undefined' || force) {
                appendIndexes.push(i$1);
              } else {
                if (i$1 > previousTo) {
                  appendIndexes.push(i$1);
                }

                if (i$1 < previousFrom) {
                  prependIndexes.push(i$1);
                }
              }
            }
          }

          appendIndexes.forEach(function (index) {
            swiper.$wrapperEl.append(renderSlide(slides[index], index));
          });
          prependIndexes.sort(function (a, b) {
            return b - a;
          }).forEach(function (index) {
            swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
          });
          swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, offset + "px");
          onRendered();
        },
        renderSlide: function renderSlide(slide, index) {
          var swiper = this;
          var params = swiper.params.virtual;

          if (params.cache && swiper.virtual.cache[index]) {
            return swiper.virtual.cache[index];
          }

          var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $("<div class=\"" + swiper.params.slideClass + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>");

          if (!$slideEl.attr('data-swiper-slide-index')) {
            $slideEl.attr('data-swiper-slide-index', index);
          }

          if (params.cache) {
            swiper.virtual.cache[index] = $slideEl;
          }

          return $slideEl;
        },
        appendSlide: function appendSlide(slides) {
          var swiper = this;

          if (_typeof(slides) === 'object' && 'length' in slides) {
            for (var i = 0; i < slides.length; i += 1) {
              if (slides[i]) {
                swiper.virtual.slides.push(slides[i]);
              }
            }
          } else {
            swiper.virtual.slides.push(slides);
          }

          swiper.virtual.update(true);
        },
        prependSlide: function prependSlide(slides) {
          var swiper = this;
          var activeIndex = swiper.activeIndex;
          var newActiveIndex = activeIndex + 1;
          var numberOfNewSlides = 1;

          if (Array.isArray(slides)) {
            for (var i = 0; i < slides.length; i += 1) {
              if (slides[i]) {
                swiper.virtual.slides.unshift(slides[i]);
              }
            }

            newActiveIndex = activeIndex + slides.length;
            numberOfNewSlides = slides.length;
          } else {
            swiper.virtual.slides.unshift(slides);
          }

          if (swiper.params.virtual.cache) {
            var cache = swiper.virtual.cache;
            var newCache = {};
            Object.keys(cache).forEach(function (cachedIndex) {
              var $cachedEl = cache[cachedIndex];
              var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

              if (cachedElIndex) {
                $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
              }

              newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
            });
            swiper.virtual.cache = newCache;
          }

          swiper.virtual.update(true);
          swiper.slideTo(newActiveIndex, 0);
        },
        removeSlide: function removeSlide(slidesIndexes) {
          var swiper = this;

          if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) {
            return;
          }

          var activeIndex = swiper.activeIndex;

          if (Array.isArray(slidesIndexes)) {
            for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
              swiper.virtual.slides.splice(slidesIndexes[i], 1);

              if (swiper.params.virtual.cache) {
                delete swiper.virtual.cache[slidesIndexes[i]];
              }

              if (slidesIndexes[i] < activeIndex) {
                activeIndex -= 1;
              }

              activeIndex = Math.max(activeIndex, 0);
            }
          } else {
            swiper.virtual.slides.splice(slidesIndexes, 1);

            if (swiper.params.virtual.cache) {
              delete swiper.virtual.cache[slidesIndexes];
            }

            if (slidesIndexes < activeIndex) {
              activeIndex -= 1;
            }

            activeIndex = Math.max(activeIndex, 0);
          }

          swiper.virtual.update(true);
          swiper.slideTo(activeIndex, 0);
        },
        removeAllSlides: function removeAllSlides() {
          var swiper = this;
          swiper.virtual.slides = [];

          if (swiper.params.virtual.cache) {
            swiper.virtual.cache = {};
          }

          swiper.virtual.update(true);
          swiper.slideTo(0, 0);
        }
      };
      var Virtual$1 = {
        name: 'virtual',
        params: {
          virtual: {
            enabled: false,
            slides: [],
            cache: true,
            renderSlide: null,
            renderExternal: null,
            addSlidesBefore: 0,
            addSlidesAfter: 0
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            virtual: {
              update: Virtual.update.bind(swiper),
              appendSlide: Virtual.appendSlide.bind(swiper),
              prependSlide: Virtual.prependSlide.bind(swiper),
              removeSlide: Virtual.removeSlide.bind(swiper),
              removeAllSlides: Virtual.removeAllSlides.bind(swiper),
              renderSlide: Virtual.renderSlide.bind(swiper),
              slides: swiper.params.virtual.slides,
              cache: {}
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;

            if (!swiper.params.virtual.enabled) {
              return;
            }

            swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
            var overwriteParams = {
              watchSlidesProgress: true
            };
            Utils.extend(swiper.params, overwriteParams);
            Utils.extend(swiper.originalParams, overwriteParams);

            if (!swiper.params.initialSlide) {
              swiper.virtual.update();
            }
          },
          setTranslate: function setTranslate() {
            var swiper = this;

            if (!swiper.params.virtual.enabled) {
              return;
            }

            swiper.virtual.update();
          }
        }
      };
      var Keyboard = {
        handle: function handle(event) {
          var swiper = this;
          var rtl = swiper.rtlTranslate;
          var e = event;

          if (e.originalEvent) {
            e = e.originalEvent;
          } // jquery fix


          var kc = e.keyCode || e.charCode; // Directions locks

          if (!swiper.allowSlideNext && (swiper.isHorizontal() && kc === 39 || swiper.isVertical() && kc === 40 || kc === 34)) {
            return false;
          }

          if (!swiper.allowSlidePrev && (swiper.isHorizontal() && kc === 37 || swiper.isVertical() && kc === 38 || kc === 33)) {
            return false;
          }

          if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return undefined;
          }

          if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
            return undefined;
          }

          if (swiper.params.keyboard.onlyInViewport && (kc === 33 || kc === 34 || kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
            var inView = false; // Check that swiper should be inside of visible area of window

            if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
              return undefined;
            }

            var windowWidth = win.innerWidth;
            var windowHeight = win.innerHeight;
            var swiperOffset = swiper.$el.offset();

            if (rtl) {
              swiperOffset.left -= swiper.$el[0].scrollLeft;
            }

            var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

            for (var i = 0; i < swiperCoord.length; i += 1) {
              var point = swiperCoord[i];

              if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                inView = true;
              }
            }

            if (!inView) {
              return undefined;
            }
          }

          if (swiper.isHorizontal()) {
            if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
              if (e.preventDefault) {
                e.preventDefault();
              } else {
                e.returnValue = false;
              }
            }

            if ((kc === 34 || kc === 39) && !rtl || (kc === 33 || kc === 37) && rtl) {
              swiper.slideNext();
            }

            if ((kc === 33 || kc === 37) && !rtl || (kc === 34 || kc === 39) && rtl) {
              swiper.slidePrev();
            }
          } else {
            if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
              if (e.preventDefault) {
                e.preventDefault();
              } else {
                e.returnValue = false;
              }
            }

            if (kc === 34 || kc === 40) {
              swiper.slideNext();
            }

            if (kc === 33 || kc === 38) {
              swiper.slidePrev();
            }
          }

          swiper.emit('keyPress', kc);
          return undefined;
        },
        enable: function enable() {
          var swiper = this;

          if (swiper.keyboard.enabled) {
            return;
          }

          $(doc).on('keydown', swiper.keyboard.handle);
          swiper.keyboard.enabled = true;
        },
        disable: function disable() {
          var swiper = this;

          if (!swiper.keyboard.enabled) {
            return;
          }

          $(doc).off('keydown', swiper.keyboard.handle);
          swiper.keyboard.enabled = false;
        }
      };
      var Keyboard$1 = {
        name: 'keyboard',
        params: {
          keyboard: {
            enabled: false,
            onlyInViewport: true
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            keyboard: {
              enabled: false,
              enable: Keyboard.enable.bind(swiper),
              disable: Keyboard.disable.bind(swiper),
              handle: Keyboard.handle.bind(swiper)
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;

            if (swiper.params.keyboard.enabled) {
              swiper.keyboard.enable();
            }
          },
          destroy: function destroy() {
            var swiper = this;

            if (swiper.keyboard.enabled) {
              swiper.keyboard.disable();
            }
          }
        }
      };

      function isEventSupported() {
        var eventName = 'onwheel';
        var isSupported = (eventName in doc);

        if (!isSupported) {
          var element = doc.createElement('div');
          element.setAttribute(eventName, 'return;');
          isSupported = typeof element[eventName] === 'function';
        }

        if (!isSupported && doc.implementation && doc.implementation.hasFeature // always returns true in newer browsers as per the standard.
        // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
        && doc.implementation.hasFeature('', '') !== true) {
          // This is the only way to test support for the `wheel` event in IE9+.
          isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
        }

        return isSupported;
      }

      var Mousewheel = {
        lastScrollTime: Utils.now(),
        event: function event() {
          if (win.navigator.userAgent.indexOf('firefox') > -1) {
            return 'DOMMouseScroll';
          }

          return isEventSupported() ? 'wheel' : 'mousewheel';
        },
        normalize: function normalize(e) {
          // Reasonable defaults
          var PIXEL_STEP = 10;
          var LINE_HEIGHT = 40;
          var PAGE_HEIGHT = 800;
          var sX = 0;
          var sY = 0; // spinX, spinY

          var pX = 0;
          var pY = 0; // pixelX, pixelY
          // Legacy

          if ('detail' in e) {
            sY = e.detail;
          }

          if ('wheelDelta' in e) {
            sY = -e.wheelDelta / 120;
          }

          if ('wheelDeltaY' in e) {
            sY = -e.wheelDeltaY / 120;
          }

          if ('wheelDeltaX' in e) {
            sX = -e.wheelDeltaX / 120;
          } // side scrolling on FF with DOMMouseScroll


          if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
            sX = sY;
            sY = 0;
          }

          pX = sX * PIXEL_STEP;
          pY = sY * PIXEL_STEP;

          if ('deltaY' in e) {
            pY = e.deltaY;
          }

          if ('deltaX' in e) {
            pX = e.deltaX;
          }

          if (e.shiftKey && !pX) {
            // if user scrolls with shift he wants horizontal scroll
            pX = pY;
            pY = 0;
          }

          if ((pX || pY) && e.deltaMode) {
            if (e.deltaMode === 1) {
              // delta in LINE units
              pX *= LINE_HEIGHT;
              pY *= LINE_HEIGHT;
            } else {
              // delta in PAGE units
              pX *= PAGE_HEIGHT;
              pY *= PAGE_HEIGHT;
            }
          } // Fall-back if spin cannot be determined


          if (pX && !sX) {
            sX = pX < 1 ? -1 : 1;
          }

          if (pY && !sY) {
            sY = pY < 1 ? -1 : 1;
          }

          return {
            spinX: sX,
            spinY: sY,
            pixelX: pX,
            pixelY: pY
          };
        },
        handleMouseEnter: function handleMouseEnter() {
          var swiper = this;
          swiper.mouseEntered = true;
        },
        handleMouseLeave: function handleMouseLeave() {
          var swiper = this;
          swiper.mouseEntered = false;
        },
        handle: function handle(event) {
          var e = event;
          var swiper = this;
          var params = swiper.params.mousewheel;

          if (swiper.params.cssMode) {
            e.preventDefault();
          }

          if (!swiper.mouseEntered && !params.releaseOnEdges) {
            return true;
          }

          if (e.originalEvent) {
            e = e.originalEvent;
          } // jquery fix


          var delta = 0;
          var rtlFactor = swiper.rtlTranslate ? -1 : 1;
          var data = Mousewheel.normalize(e);

          if (params.forceToAxis) {
            if (swiper.isHorizontal()) {
              if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) {
                delta = data.pixelX * rtlFactor;
              } else {
                return true;
              }
            } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) {
              delta = data.pixelY;
            } else {
              return true;
            }
          } else {
            delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
          }

          if (delta === 0) {
            return true;
          }

          if (params.invert) {
            delta = -delta;
          }

          if (!swiper.params.freeMode) {
            if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
              if (delta < 0) {
                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                  swiper.slideNext();
                  swiper.emit('scroll', e);
                } else if (params.releaseOnEdges) {
                  return true;
                }
              } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                swiper.slidePrev();
                swiper.emit('scroll', e);
              } else if (params.releaseOnEdges) {
                return true;
              }
            }

            swiper.mousewheel.lastScrollTime = new win.Date().getTime();
          } else {
            // Freemode or scrollContainer:
            if (swiper.params.loop) {
              swiper.loopFix();
            }

            var position = swiper.getTranslate() + delta * params.sensitivity;
            var wasBeginning = swiper.isBeginning;
            var wasEnd = swiper.isEnd;

            if (position >= swiper.minTranslate()) {
              position = swiper.minTranslate();
            }

            if (position <= swiper.maxTranslate()) {
              position = swiper.maxTranslate();
            }

            swiper.setTransition(0);
            swiper.setTranslate(position);
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();

            if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
              swiper.updateSlidesClasses();
            }

            if (swiper.params.freeModeSticky) {
              clearTimeout(swiper.mousewheel.timeout);
              swiper.mousewheel.timeout = Utils.nextTick(function () {
                swiper.slideToClosest();
              }, 300);
            } // Emit event


            swiper.emit('scroll', e); // Stop autoplay

            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) {
              swiper.autoplay.stop();
            } // Return page scroll on edge positions


            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) {
              return true;
            }
          }

          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }

          return false;
        },
        enable: function enable() {
          var swiper = this;
          var event = Mousewheel.event();

          if (swiper.params.cssMode) {
            swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
            return true;
          }

          if (!event) {
            return false;
          }

          if (swiper.mousewheel.enabled) {
            return false;
          }

          var target = swiper.$el;

          if (swiper.params.mousewheel.eventsTarged !== 'container') {
            target = $(swiper.params.mousewheel.eventsTarged);
          }

          target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
          target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
          target.on(event, swiper.mousewheel.handle);
          swiper.mousewheel.enabled = true;
          return true;
        },
        disable: function disable() {
          var swiper = this;
          var event = Mousewheel.event();

          if (swiper.params.cssMode) {
            swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
            return true;
          }

          if (!event) {
            return false;
          }

          if (!swiper.mousewheel.enabled) {
            return false;
          }

          var target = swiper.$el;

          if (swiper.params.mousewheel.eventsTarged !== 'container') {
            target = $(swiper.params.mousewheel.eventsTarged);
          }

          target.off(event, swiper.mousewheel.handle);
          swiper.mousewheel.enabled = false;
          return true;
        }
      };
      var Mousewheel$1 = {
        name: 'mousewheel',
        params: {
          mousewheel: {
            enabled: false,
            releaseOnEdges: false,
            invert: false,
            forceToAxis: false,
            sensitivity: 1,
            eventsTarged: 'container'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            mousewheel: {
              enabled: false,
              enable: Mousewheel.enable.bind(swiper),
              disable: Mousewheel.disable.bind(swiper),
              handle: Mousewheel.handle.bind(swiper),
              handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
              handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
              lastScrollTime: Utils.now()
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;

            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
              swiper.mousewheel.disable();
            }

            if (swiper.params.mousewheel.enabled) {
              swiper.mousewheel.enable();
            }
          },
          destroy: function destroy() {
            var swiper = this;

            if (swiper.params.cssMode) {
              swiper.mousewheel.enable();
            }

            if (swiper.mousewheel.enabled) {
              swiper.mousewheel.disable();
            }
          }
        }
      };
      var Navigation = {
        update: function update() {
          // Update Navigation Buttons
          var swiper = this;
          var params = swiper.params.navigation;

          if (swiper.params.loop) {
            return;
          }

          var ref = swiper.navigation;
          var $nextEl = ref.$nextEl;
          var $prevEl = ref.$prevEl;

          if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
              $prevEl.addClass(params.disabledClass);
            } else {
              $prevEl.removeClass(params.disabledClass);
            }

            $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }

          if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
              $nextEl.addClass(params.disabledClass);
            } else {
              $nextEl.removeClass(params.disabledClass);
            }

            $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        },
        onPrevClick: function onPrevClick(e) {
          var swiper = this;
          e.preventDefault();

          if (swiper.isBeginning && !swiper.params.loop) {
            return;
          }

          swiper.slidePrev();
        },
        onNextClick: function onNextClick(e) {
          var swiper = this;
          e.preventDefault();

          if (swiper.isEnd && !swiper.params.loop) {
            return;
          }

          swiper.slideNext();
        },
        init: function init() {
          var swiper = this;
          var params = swiper.params.navigation;

          if (!(params.nextEl || params.prevEl)) {
            return;
          }

          var $nextEl;
          var $prevEl;

          if (params.nextEl) {
            $nextEl = $(params.nextEl);

            if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
              $nextEl = swiper.$el.find(params.nextEl);
            }
          }

          if (params.prevEl) {
            $prevEl = $(params.prevEl);

            if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
              $prevEl = swiper.$el.find(params.prevEl);
            }
          }

          if ($nextEl && $nextEl.length > 0) {
            $nextEl.on('click', swiper.navigation.onNextClick);
          }

          if ($prevEl && $prevEl.length > 0) {
            $prevEl.on('click', swiper.navigation.onPrevClick);
          }

          Utils.extend(swiper.navigation, {
            $nextEl: $nextEl,
            nextEl: $nextEl && $nextEl[0],
            $prevEl: $prevEl,
            prevEl: $prevEl && $prevEl[0]
          });
        },
        destroy: function destroy() {
          var swiper = this;
          var ref = swiper.navigation;
          var $nextEl = ref.$nextEl;
          var $prevEl = ref.$prevEl;

          if ($nextEl && $nextEl.length) {
            $nextEl.off('click', swiper.navigation.onNextClick);
            $nextEl.removeClass(swiper.params.navigation.disabledClass);
          }

          if ($prevEl && $prevEl.length) {
            $prevEl.off('click', swiper.navigation.onPrevClick);
            $prevEl.removeClass(swiper.params.navigation.disabledClass);
          }
        }
      };
      var Navigation$1 = {
        name: 'navigation',
        params: {
          navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: false,
            disabledClass: 'swiper-button-disabled',
            hiddenClass: 'swiper-button-hidden',
            lockClass: 'swiper-button-lock'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            navigation: {
              init: Navigation.init.bind(swiper),
              update: Navigation.update.bind(swiper),
              destroy: Navigation.destroy.bind(swiper),
              onNextClick: Navigation.onNextClick.bind(swiper),
              onPrevClick: Navigation.onPrevClick.bind(swiper)
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;
            swiper.navigation.init();
            swiper.navigation.update();
          },
          toEdge: function toEdge() {
            var swiper = this;
            swiper.navigation.update();
          },
          fromEdge: function fromEdge() {
            var swiper = this;
            swiper.navigation.update();
          },
          destroy: function destroy() {
            var swiper = this;
            swiper.navigation.destroy();
          },
          click: function click(e) {
            var swiper = this;
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;

            if (swiper.params.navigation.hideOnClick && !$(e.target).is($prevEl) && !$(e.target).is($nextEl)) {
              var isHidden;

              if ($nextEl) {
                isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
              } else if ($prevEl) {
                isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
              }

              if (isHidden === true) {
                swiper.emit('navigationShow', swiper);
              } else {
                swiper.emit('navigationHide', swiper);
              }

              if ($nextEl) {
                $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
              }

              if ($prevEl) {
                $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
              }
            }
          }
        }
      };
      var Pagination = {
        update: function update() {
          // Render || Update Pagination bullets/items
          var swiper = this;
          var rtl = swiper.rtl;
          var params = swiper.params.pagination;

          if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
            return;
          }

          var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
          var $el = swiper.pagination.$el; // Current/Total

          var current;
          var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.loop) {
            current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

            if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
              current -= slidesLength - swiper.loopedSlides * 2;
            }

            if (current > total - 1) {
              current -= total;
            }

            if (current < 0 && swiper.params.paginationType !== 'bullets') {
              current = total + current;
            }
          } else if (typeof swiper.snapIndex !== 'undefined') {
            current = swiper.snapIndex;
          } else {
            current = swiper.activeIndex || 0;
          } // Types


          if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
            var bullets = swiper.pagination.bullets;
            var firstIndex;
            var lastIndex;
            var midIndex;

            if (params.dynamicBullets) {
              swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
              $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

              if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

                if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                  swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
                } else if (swiper.pagination.dynamicBulletIndex < 0) {
                  swiper.pagination.dynamicBulletIndex = 0;
                }
              }

              firstIndex = current - swiper.pagination.dynamicBulletIndex;
              lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
              midIndex = (lastIndex + firstIndex) / 2;
            }

            bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

            if ($el.length > 1) {
              bullets.each(function (index, bullet) {
                var $bullet = $(bullet);
                var bulletIndex = $bullet.index();

                if (bulletIndex === current) {
                  $bullet.addClass(params.bulletActiveClass);
                }

                if (params.dynamicBullets) {
                  if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                    $bullet.addClass(params.bulletActiveClass + "-main");
                  }

                  if (bulletIndex === firstIndex) {
                    $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                  }

                  if (bulletIndex === lastIndex) {
                    $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                  }
                }
              });
            } else {
              var $bullet = bullets.eq(current);
              var bulletIndex = $bullet.index();
              $bullet.addClass(params.bulletActiveClass);

              if (params.dynamicBullets) {
                var $firstDisplayedBullet = bullets.eq(firstIndex);
                var $lastDisplayedBullet = bullets.eq(lastIndex);

                for (var i = firstIndex; i <= lastIndex; i += 1) {
                  bullets.eq(i).addClass(params.bulletActiveClass + "-main");
                }

                if (swiper.params.loop) {
                  if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                    for (var i$1 = params.dynamicMainBullets; i$1 >= 0; i$1 -= 1) {
                      bullets.eq(bullets.length - i$1).addClass(params.bulletActiveClass + "-main");
                    }

                    bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
                  } else {
                    $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                    $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                  }
                } else {
                  $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                  $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                }
              }
            }

            if (params.dynamicBullets) {
              var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
              var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
              var offsetProp = rtl ? 'right' : 'left';
              bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
            }
          }

          if (params.type === 'fraction') {
            $el.find("." + params.currentClass).text(params.formatFractionCurrent(current + 1));
            $el.find("." + params.totalClass).text(params.formatFractionTotal(total));
          }

          if (params.type === 'progressbar') {
            var progressbarDirection;

            if (params.progressbarOpposite) {
              progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
            } else {
              progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
            }

            var scale = (current + 1) / total;
            var scaleX = 1;
            var scaleY = 1;

            if (progressbarDirection === 'horizontal') {
              scaleX = scale;
            } else {
              scaleY = scale;
            }

            $el.find("." + params.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
          }

          if (params.type === 'custom' && params.renderCustom) {
            $el.html(params.renderCustom(swiper, current + 1, total));
            swiper.emit('paginationRender', swiper, $el[0]);
          } else {
            swiper.emit('paginationUpdate', swiper, $el[0]);
          }

          $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        },
        render: function render() {
          // Render Container
          var swiper = this;
          var params = swiper.params.pagination;

          if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
            return;
          }

          var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
          var $el = swiper.pagination.$el;
          var paginationHTML = '';

          if (params.type === 'bullets') {
            var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

            for (var i = 0; i < numberOfBullets; i += 1) {
              if (params.renderBullet) {
                paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
              } else {
                paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
              }
            }

            $el.html(paginationHTML);
            swiper.pagination.bullets = $el.find("." + params.bulletClass);
          }

          if (params.type === 'fraction') {
            if (params.renderFraction) {
              paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
            } else {
              paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + "<span class=\"" + params.totalClass + "\"></span>";
            }

            $el.html(paginationHTML);
          }

          if (params.type === 'progressbar') {
            if (params.renderProgressbar) {
              paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
            } else {
              paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
            }

            $el.html(paginationHTML);
          }

          if (params.type !== 'custom') {
            swiper.emit('paginationRender', swiper.pagination.$el[0]);
          }
        },
        init: function init() {
          var swiper = this;
          var params = swiper.params.pagination;

          if (!params.el) {
            return;
          }

          var $el = $(params.el);

          if ($el.length === 0) {
            return;
          }

          if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && swiper.$el.find(params.el).length === 1) {
            $el = swiper.$el.find(params.el);
          }

          if (params.type === 'bullets' && params.clickable) {
            $el.addClass(params.clickableClass);
          }

          $el.addClass(params.modifierClass + params.type);

          if (params.type === 'bullets' && params.dynamicBullets) {
            $el.addClass("" + params.modifierClass + params.type + "-dynamic");
            swiper.pagination.dynamicBulletIndex = 0;

            if (params.dynamicMainBullets < 1) {
              params.dynamicMainBullets = 1;
            }
          }

          if (params.type === 'progressbar' && params.progressbarOpposite) {
            $el.addClass(params.progressbarOppositeClass);
          }

          if (params.clickable) {
            $el.on('click', "." + params.bulletClass, function onClick(e) {
              e.preventDefault();
              var index = $(this).index() * swiper.params.slidesPerGroup;

              if (swiper.params.loop) {
                index += swiper.loopedSlides;
              }

              swiper.slideTo(index);
            });
          }

          Utils.extend(swiper.pagination, {
            $el: $el,
            el: $el[0]
          });
        },
        destroy: function destroy() {
          var swiper = this;
          var params = swiper.params.pagination;

          if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
            return;
          }

          var $el = swiper.pagination.$el;
          $el.removeClass(params.hiddenClass);
          $el.removeClass(params.modifierClass + params.type);

          if (swiper.pagination.bullets) {
            swiper.pagination.bullets.removeClass(params.bulletActiveClass);
          }

          if (params.clickable) {
            $el.off('click', "." + params.bulletClass);
          }
        }
      };
      var Pagination$1 = {
        name: 'pagination',
        params: {
          pagination: {
            el: null,
            bulletElement: 'span',
            clickable: false,
            hideOnClick: false,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: false,
            type: 'bullets',
            // 'bullets' or 'progressbar' or 'fraction' or 'custom'
            dynamicBullets: false,
            dynamicMainBullets: 1,
            formatFractionCurrent: function formatFractionCurrent(number) {
              return number;
            },
            formatFractionTotal: function formatFractionTotal(number) {
              return number;
            },
            bulletClass: 'swiper-pagination-bullet',
            bulletActiveClass: 'swiper-pagination-bullet-active',
            modifierClass: 'swiper-pagination-',
            // NEW
            currentClass: 'swiper-pagination-current',
            totalClass: 'swiper-pagination-total',
            hiddenClass: 'swiper-pagination-hidden',
            progressbarFillClass: 'swiper-pagination-progressbar-fill',
            progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
            clickableClass: 'swiper-pagination-clickable',
            // NEW
            lockClass: 'swiper-pagination-lock'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            pagination: {
              init: Pagination.init.bind(swiper),
              render: Pagination.render.bind(swiper),
              update: Pagination.update.bind(swiper),
              destroy: Pagination.destroy.bind(swiper),
              dynamicBulletIndex: 0
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;
            swiper.pagination.init();
            swiper.pagination.render();
            swiper.pagination.update();
          },
          activeIndexChange: function activeIndexChange() {
            var swiper = this;

            if (swiper.params.loop) {
              swiper.pagination.update();
            } else if (typeof swiper.snapIndex === 'undefined') {
              swiper.pagination.update();
            }
          },
          snapIndexChange: function snapIndexChange() {
            var swiper = this;

            if (!swiper.params.loop) {
              swiper.pagination.update();
            }
          },
          slidesLengthChange: function slidesLengthChange() {
            var swiper = this;

            if (swiper.params.loop) {
              swiper.pagination.render();
              swiper.pagination.update();
            }
          },
          snapGridLengthChange: function snapGridLengthChange() {
            var swiper = this;

            if (!swiper.params.loop) {
              swiper.pagination.render();
              swiper.pagination.update();
            }
          },
          destroy: function destroy() {
            var swiper = this;
            swiper.pagination.destroy();
          },
          click: function click(e) {
            var swiper = this;

            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(e.target).hasClass(swiper.params.pagination.bulletClass)) {
              var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

              if (isHidden === true) {
                swiper.emit('paginationShow', swiper);
              } else {
                swiper.emit('paginationHide', swiper);
              }

              swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
            }
          }
        }
      };
      var Scrollbar = {
        setTranslate: function setTranslate() {
          var swiper = this;

          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
            return;
          }

          var scrollbar = swiper.scrollbar;
          var rtl = swiper.rtlTranslate;
          var progress = swiper.progress;
          var dragSize = scrollbar.dragSize;
          var trackSize = scrollbar.trackSize;
          var $dragEl = scrollbar.$dragEl;
          var $el = scrollbar.$el;
          var params = swiper.params.scrollbar;
          var newSize = dragSize;
          var newPos = (trackSize - dragSize) * progress;

          if (rtl) {
            newPos = -newPos;

            if (newPos > 0) {
              newSize = dragSize - newPos;
              newPos = 0;
            } else if (-newPos + dragSize > trackSize) {
              newSize = trackSize + newPos;
            }
          } else if (newPos < 0) {
            newSize = dragSize + newPos;
            newPos = 0;
          } else if (newPos + dragSize > trackSize) {
            newSize = trackSize - newPos;
          }

          if (swiper.isHorizontal()) {
            $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
            $dragEl[0].style.width = newSize + "px";
          } else {
            $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
            $dragEl[0].style.height = newSize + "px";
          }

          if (params.hide) {
            clearTimeout(swiper.scrollbar.timeout);
            $el[0].style.opacity = 1;
            swiper.scrollbar.timeout = setTimeout(function () {
              $el[0].style.opacity = 0;
              $el.transition(400);
            }, 1000);
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;

          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
            return;
          }

          swiper.scrollbar.$dragEl.transition(duration);
        },
        updateSize: function updateSize() {
          var swiper = this;

          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
            return;
          }

          var scrollbar = swiper.scrollbar;
          var $dragEl = scrollbar.$dragEl;
          var $el = scrollbar.$el;
          $dragEl[0].style.width = '';
          $dragEl[0].style.height = '';
          var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
          var divider = swiper.size / swiper.virtualSize;
          var moveDivider = divider * (trackSize / swiper.size);
          var dragSize;

          if (swiper.params.scrollbar.dragSize === 'auto') {
            dragSize = trackSize * divider;
          } else {
            dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
          }

          if (swiper.isHorizontal()) {
            $dragEl[0].style.width = dragSize + "px";
          } else {
            $dragEl[0].style.height = dragSize + "px";
          }

          if (divider >= 1) {
            $el[0].style.display = 'none';
          } else {
            $el[0].style.display = '';
          }

          if (swiper.params.scrollbar.hide) {
            $el[0].style.opacity = 0;
          }

          Utils.extend(scrollbar, {
            trackSize: trackSize,
            divider: divider,
            moveDivider: moveDivider,
            dragSize: dragSize
          });
          scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        },
        getPointerPosition: function getPointerPosition(e) {
          var swiper = this;

          if (swiper.isHorizontal()) {
            return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
          }

          return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
        },
        setDragPosition: function setDragPosition(e) {
          var swiper = this;
          var scrollbar = swiper.scrollbar;
          var rtl = swiper.rtlTranslate;
          var $el = scrollbar.$el;
          var dragSize = scrollbar.dragSize;
          var trackSize = scrollbar.trackSize;
          var dragStartPos = scrollbar.dragStartPos;
          var positionRatio;
          positionRatio = (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
          positionRatio = Math.max(Math.min(positionRatio, 1), 0);

          if (rtl) {
            positionRatio = 1 - positionRatio;
          }

          var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
          swiper.updateProgress(position);
          swiper.setTranslate(position);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        },
        onDragStart: function onDragStart(e) {
          var swiper = this;
          var params = swiper.params.scrollbar;
          var scrollbar = swiper.scrollbar;
          var $wrapperEl = swiper.$wrapperEl;
          var $el = scrollbar.$el;
          var $dragEl = scrollbar.$dragEl;
          swiper.scrollbar.isTouched = true;
          swiper.scrollbar.dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
          e.preventDefault();
          e.stopPropagation();
          $wrapperEl.transition(100);
          $dragEl.transition(100);
          scrollbar.setDragPosition(e);
          clearTimeout(swiper.scrollbar.dragTimeout);
          $el.transition(0);

          if (params.hide) {
            $el.css('opacity', 1);
          }

          if (swiper.params.cssMode) {
            swiper.$wrapperEl.css('scroll-snap-type', 'none');
          }

          swiper.emit('scrollbarDragStart', e);
        },
        onDragMove: function onDragMove(e) {
          var swiper = this;
          var scrollbar = swiper.scrollbar;
          var $wrapperEl = swiper.$wrapperEl;
          var $el = scrollbar.$el;
          var $dragEl = scrollbar.$dragEl;

          if (!swiper.scrollbar.isTouched) {
            return;
          }

          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }

          scrollbar.setDragPosition(e);
          $wrapperEl.transition(0);
          $el.transition(0);
          $dragEl.transition(0);
          swiper.emit('scrollbarDragMove', e);
        },
        onDragEnd: function onDragEnd(e) {
          var swiper = this;
          var params = swiper.params.scrollbar;
          var scrollbar = swiper.scrollbar;
          var $wrapperEl = swiper.$wrapperEl;
          var $el = scrollbar.$el;

          if (!swiper.scrollbar.isTouched) {
            return;
          }

          swiper.scrollbar.isTouched = false;

          if (swiper.params.cssMode) {
            swiper.$wrapperEl.css('scroll-snap-type', '');
            $wrapperEl.transition('');
          }

          if (params.hide) {
            clearTimeout(swiper.scrollbar.dragTimeout);
            swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
              $el.css('opacity', 0);
              $el.transition(400);
            }, 1000);
          }

          swiper.emit('scrollbarDragEnd', e);

          if (params.snapOnRelease) {
            swiper.slideToClosest();
          }
        },
        enableDraggable: function enableDraggable() {
          var swiper = this;

          if (!swiper.params.scrollbar.el) {
            return;
          }

          var scrollbar = swiper.scrollbar;
          var touchEventsTouch = swiper.touchEventsTouch;
          var touchEventsDesktop = swiper.touchEventsDesktop;
          var params = swiper.params;
          var $el = scrollbar.$el;
          var target = $el[0];
          var activeListener = Support.passiveListener && params.passiveListeners ? {
            passive: false,
            capture: false
          } : false;
          var passiveListener = Support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;

          if (!Support.touch) {
            target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
            doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
            doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
          } else {
            target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
            target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
            target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
          }
        },
        disableDraggable: function disableDraggable() {
          var swiper = this;

          if (!swiper.params.scrollbar.el) {
            return;
          }

          var scrollbar = swiper.scrollbar;
          var touchEventsTouch = swiper.touchEventsTouch;
          var touchEventsDesktop = swiper.touchEventsDesktop;
          var params = swiper.params;
          var $el = scrollbar.$el;
          var target = $el[0];
          var activeListener = Support.passiveListener && params.passiveListeners ? {
            passive: false,
            capture: false
          } : false;
          var passiveListener = Support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;

          if (!Support.touch) {
            target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
            doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
            doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
          } else {
            target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
            target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
            target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
          }
        },
        init: function init() {
          var swiper = this;

          if (!swiper.params.scrollbar.el) {
            return;
          }

          var scrollbar = swiper.scrollbar;
          var $swiperEl = swiper.$el;
          var params = swiper.params.scrollbar;
          var $el = $(params.el);

          if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
            $el = $swiperEl.find(params.el);
          }

          var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);

          if ($dragEl.length === 0) {
            $dragEl = $("<div class=\"" + swiper.params.scrollbar.dragClass + "\"></div>");
            $el.append($dragEl);
          }

          Utils.extend(scrollbar, {
            $el: $el,
            el: $el[0],
            $dragEl: $dragEl,
            dragEl: $dragEl[0]
          });

          if (params.draggable) {
            scrollbar.enableDraggable();
          }
        },
        destroy: function destroy() {
          var swiper = this;
          swiper.scrollbar.disableDraggable();
        }
      };
      var Scrollbar$1 = {
        name: 'scrollbar',
        params: {
          scrollbar: {
            el: null,
            dragSize: 'auto',
            hide: false,
            draggable: false,
            snapOnRelease: true,
            lockClass: 'swiper-scrollbar-lock',
            dragClass: 'swiper-scrollbar-drag'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            scrollbar: {
              init: Scrollbar.init.bind(swiper),
              destroy: Scrollbar.destroy.bind(swiper),
              updateSize: Scrollbar.updateSize.bind(swiper),
              setTranslate: Scrollbar.setTranslate.bind(swiper),
              setTransition: Scrollbar.setTransition.bind(swiper),
              enableDraggable: Scrollbar.enableDraggable.bind(swiper),
              disableDraggable: Scrollbar.disableDraggable.bind(swiper),
              setDragPosition: Scrollbar.setDragPosition.bind(swiper),
              getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
              onDragStart: Scrollbar.onDragStart.bind(swiper),
              onDragMove: Scrollbar.onDragMove.bind(swiper),
              onDragEnd: Scrollbar.onDragEnd.bind(swiper),
              isTouched: false,
              timeout: null,
              dragTimeout: null
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;
            swiper.scrollbar.init();
            swiper.scrollbar.updateSize();
            swiper.scrollbar.setTranslate();
          },
          update: function update() {
            var swiper = this;
            swiper.scrollbar.updateSize();
          },
          resize: function resize() {
            var swiper = this;
            swiper.scrollbar.updateSize();
          },
          observerUpdate: function observerUpdate() {
            var swiper = this;
            swiper.scrollbar.updateSize();
          },
          setTranslate: function setTranslate() {
            var swiper = this;
            swiper.scrollbar.setTranslate();
          },
          setTransition: function setTransition(duration) {
            var swiper = this;
            swiper.scrollbar.setTransition(duration);
          },
          destroy: function destroy() {
            var swiper = this;
            swiper.scrollbar.destroy();
          }
        }
      };
      var Parallax = {
        setTransform: function setTransform(el, progress) {
          var swiper = this;
          var rtl = swiper.rtl;
          var $el = $(el);
          var rtlFactor = rtl ? -1 : 1;
          var p = $el.attr('data-swiper-parallax') || '0';
          var x = $el.attr('data-swiper-parallax-x');
          var y = $el.attr('data-swiper-parallax-y');
          var scale = $el.attr('data-swiper-parallax-scale');
          var opacity = $el.attr('data-swiper-parallax-opacity');

          if (x || y) {
            x = x || '0';
            y = y || '0';
          } else if (swiper.isHorizontal()) {
            x = p;
            y = '0';
          } else {
            y = p;
            x = '0';
          }

          if (x.indexOf('%') >= 0) {
            x = parseInt(x, 10) * progress * rtlFactor + "%";
          } else {
            x = x * progress * rtlFactor + "px";
          }

          if (y.indexOf('%') >= 0) {
            y = parseInt(y, 10) * progress + "%";
          } else {
            y = y * progress + "px";
          }

          if (typeof opacity !== 'undefined' && opacity !== null) {
            var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
            $el[0].style.opacity = currentOpacity;
          }

          if (typeof scale === 'undefined' || scale === null) {
            $el.transform("translate3d(" + x + ", " + y + ", 0px)");
          } else {
            var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
            $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
          }
        },
        setTranslate: function setTranslate() {
          var swiper = this;
          var $el = swiper.$el;
          var slides = swiper.slides;
          var progress = swiper.progress;
          var snapGrid = swiper.snapGrid;
          $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (index, el) {
            swiper.parallax.setTransform(el, progress);
          });
          slides.each(function (slideIndex, slideEl) {
            var slideProgress = slideEl.progress;

            if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
              slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
            }

            slideProgress = Math.min(Math.max(slideProgress, -1), 1);
            $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (index, el) {
              swiper.parallax.setTransform(el, slideProgress);
            });
          });
        },
        setTransition: function setTransition(duration) {
          if (duration === void 0) duration = this.params.speed;
          var swiper = this;
          var $el = swiper.$el;
          $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (index, parallaxEl) {
            var $parallaxEl = $(parallaxEl);
            var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;

            if (duration === 0) {
              parallaxDuration = 0;
            }

            $parallaxEl.transition(parallaxDuration);
          });
        }
      };
      var Parallax$1 = {
        name: 'parallax',
        params: {
          parallax: {
            enabled: false
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            parallax: {
              setTransform: Parallax.setTransform.bind(swiper),
              setTranslate: Parallax.setTranslate.bind(swiper),
              setTransition: Parallax.setTransition.bind(swiper)
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;

            if (!swiper.params.parallax.enabled) {
              return;
            }

            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
          },
          init: function init() {
            var swiper = this;

            if (!swiper.params.parallax.enabled) {
              return;
            }

            swiper.parallax.setTranslate();
          },
          setTranslate: function setTranslate() {
            var swiper = this;

            if (!swiper.params.parallax.enabled) {
              return;
            }

            swiper.parallax.setTranslate();
          },
          setTransition: function setTransition(duration) {
            var swiper = this;

            if (!swiper.params.parallax.enabled) {
              return;
            }

            swiper.parallax.setTransition(duration);
          }
        }
      };
      var Zoom = {
        // Calc Scale From Multi-touches
        getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
          if (e.targetTouches.length < 2) {
            return 1;
          }

          var x1 = e.targetTouches[0].pageX;
          var y1 = e.targetTouches[0].pageY;
          var x2 = e.targetTouches[1].pageX;
          var y2 = e.targetTouches[1].pageY;
          var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          return distance;
        },
        // Events
        onGestureStart: function onGestureStart(e) {
          var swiper = this;
          var params = swiper.params.zoom;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;
          zoom.fakeGestureTouched = false;
          zoom.fakeGestureMoved = false;

          if (!Support.gestures) {
            if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
              return;
            }

            zoom.fakeGestureTouched = true;
            gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
          }

          if (!gesture.$slideEl || !gesture.$slideEl.length) {
            gesture.$slideEl = $(e.target).closest('.swiper-slide');

            if (gesture.$slideEl.length === 0) {
              gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            }

            gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
            gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

            if (gesture.$imageWrapEl.length === 0) {
              gesture.$imageEl = undefined;
              return;
            }
          }

          gesture.$imageEl.transition(0);
          swiper.zoom.isScaling = true;
        },
        onGestureChange: function onGestureChange(e) {
          var swiper = this;
          var params = swiper.params.zoom;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;

          if (!Support.gestures) {
            if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
              return;
            }

            zoom.fakeGestureMoved = true;
            gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
          }

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            return;
          }

          if (Support.gestures) {
            zoom.scale = e.scale * zoom.currentScale;
          } else {
            zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
          }

          if (zoom.scale > gesture.maxRatio) {
            zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
          }

          if (zoom.scale < params.minRatio) {
            zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
          }

          gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
        },
        onGestureEnd: function onGestureEnd(e) {
          var swiper = this;
          var params = swiper.params.zoom;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;

          if (!Support.gestures) {
            if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
              return;
            }

            if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android) {
              return;
            }

            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
          }

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            return;
          }

          zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
          gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
          zoom.currentScale = zoom.scale;
          zoom.isScaling = false;

          if (zoom.scale === 1) {
            gesture.$slideEl = undefined;
          }
        },
        onTouchStart: function onTouchStart(e) {
          var swiper = this;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;
          var image = zoom.image;

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            return;
          }

          if (image.isTouched) {
            return;
          }

          if (Device.android) {
            e.preventDefault();
          }

          image.isTouched = true;
          image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        },
        onTouchMove: function onTouchMove(e) {
          var swiper = this;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;
          var image = zoom.image;
          var velocity = zoom.velocity;

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            return;
          }

          swiper.allowClick = false;

          if (!image.isTouched || !gesture.$slideEl) {
            return;
          }

          if (!image.isMoved) {
            image.width = gesture.$imageEl[0].offsetWidth;
            image.height = gesture.$imageEl[0].offsetHeight;
            image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
            image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
            gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
            gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
            gesture.$imageWrapEl.transition(0);

            if (swiper.rtl) {
              image.startX = -image.startX;
              image.startY = -image.startY;
            }
          } // Define if we need image drag


          var scaledWidth = image.width * zoom.scale;
          var scaledHeight = image.height * zoom.scale;

          if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) {
            return;
          }

          image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
          image.maxX = -image.minX;
          image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
          image.maxY = -image.minY;
          image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

          if (!image.isMoved && !zoom.isScaling) {
            if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
              image.isTouched = false;
              return;
            }

            if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
              image.isTouched = false;
              return;
            }
          }

          e.preventDefault();
          e.stopPropagation();
          image.isMoved = true;
          image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
          image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

          if (image.currentX < image.minX) {
            image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
          }

          if (image.currentX > image.maxX) {
            image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
          }

          if (image.currentY < image.minY) {
            image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
          }

          if (image.currentY > image.maxY) {
            image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
          } // Velocity


          if (!velocity.prevPositionX) {
            velocity.prevPositionX = image.touchesCurrent.x;
          }

          if (!velocity.prevPositionY) {
            velocity.prevPositionY = image.touchesCurrent.y;
          }

          if (!velocity.prevTime) {
            velocity.prevTime = Date.now();
          }

          velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
          velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;

          if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) {
            velocity.x = 0;
          }

          if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) {
            velocity.y = 0;
          }

          velocity.prevPositionX = image.touchesCurrent.x;
          velocity.prevPositionY = image.touchesCurrent.y;
          velocity.prevTime = Date.now();
          gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
        },
        onTouchEnd: function onTouchEnd() {
          var swiper = this;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;
          var image = zoom.image;
          var velocity = zoom.velocity;

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            return;
          }

          if (!image.isTouched || !image.isMoved) {
            image.isTouched = false;
            image.isMoved = false;
            return;
          }

          image.isTouched = false;
          image.isMoved = false;
          var momentumDurationX = 300;
          var momentumDurationY = 300;
          var momentumDistanceX = velocity.x * momentumDurationX;
          var newPositionX = image.currentX + momentumDistanceX;
          var momentumDistanceY = velocity.y * momentumDurationY;
          var newPositionY = image.currentY + momentumDistanceY; // Fix duration

          if (velocity.x !== 0) {
            momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
          }

          if (velocity.y !== 0) {
            momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
          }

          var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
          image.currentX = newPositionX;
          image.currentY = newPositionY; // Define if we need image drag

          var scaledWidth = image.width * zoom.scale;
          var scaledHeight = image.height * zoom.scale;
          image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
          image.maxX = -image.minX;
          image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
          image.maxY = -image.minY;
          image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
          image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
          gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
        },
        onTransitionEnd: function onTransitionEnd() {
          var swiper = this;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;

          if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
            gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
            gesture.$imageWrapEl.transform('translate3d(0,0,0)');
            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$slideEl = undefined;
            gesture.$imageEl = undefined;
            gesture.$imageWrapEl = undefined;
          }
        },
        // Toggle Zoom
        toggle: function toggle(e) {
          var swiper = this;
          var zoom = swiper.zoom;

          if (zoom.scale && zoom.scale !== 1) {
            // Zoom Out
            zoom.out();
          } else {
            // Zoom In
            zoom["in"](e);
          }
        },
        "in": function in$1(e) {
          var swiper = this;
          var zoom = swiper.zoom;
          var params = swiper.params.zoom;
          var gesture = zoom.gesture;
          var image = zoom.image;

          if (!gesture.$slideEl) {
            gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
            gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
          }

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            return;
          }

          gesture.$slideEl.addClass("" + params.zoomedSlideClass);
          var touchX;
          var touchY;
          var offsetX;
          var offsetY;
          var diffX;
          var diffY;
          var translateX;
          var translateY;
          var imageWidth;
          var imageHeight;
          var scaledWidth;
          var scaledHeight;
          var translateMinX;
          var translateMinY;
          var translateMaxX;
          var translateMaxY;
          var slideWidth;
          var slideHeight;

          if (typeof image.touchesStart.x === 'undefined' && e) {
            touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
            touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
          } else {
            touchX = image.touchesStart.x;
            touchY = image.touchesStart.y;
          }

          zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
          zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

          if (e) {
            slideWidth = gesture.$slideEl[0].offsetWidth;
            slideHeight = gesture.$slideEl[0].offsetHeight;
            offsetX = gesture.$slideEl.offset().left;
            offsetY = gesture.$slideEl.offset().top;
            diffX = offsetX + slideWidth / 2 - touchX;
            diffY = offsetY + slideHeight / 2 - touchY;
            imageWidth = gesture.$imageEl[0].offsetWidth;
            imageHeight = gesture.$imageEl[0].offsetHeight;
            scaledWidth = imageWidth * zoom.scale;
            scaledHeight = imageHeight * zoom.scale;
            translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
            translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
            translateMaxX = -translateMinX;
            translateMaxY = -translateMinY;
            translateX = diffX * zoom.scale;
            translateY = diffY * zoom.scale;

            if (translateX < translateMinX) {
              translateX = translateMinX;
            }

            if (translateX > translateMaxX) {
              translateX = translateMaxX;
            }

            if (translateY < translateMinY) {
              translateY = translateMinY;
            }

            if (translateY > translateMaxY) {
              translateY = translateMaxY;
            }
          } else {
            translateX = 0;
            translateY = 0;
          }

          gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
          gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
        },
        out: function out() {
          var swiper = this;
          var zoom = swiper.zoom;
          var params = swiper.params.zoom;
          var gesture = zoom.gesture;

          if (!gesture.$slideEl) {
            gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
            gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
          }

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            return;
          }

          zoom.scale = 1;
          zoom.currentScale = 1;
          gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
          gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
          gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
          gesture.$slideEl = undefined;
        },
        // Attach/Detach Events
        enable: function enable() {
          var swiper = this;
          var zoom = swiper.zoom;

          if (zoom.enabled) {
            return;
          }

          zoom.enabled = true;
          var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          var activeListenerWithCapture = Support.passiveListener ? {
            passive: false,
            capture: true
          } : true; // Scale image

          if (Support.gestures) {
            swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
            swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
          } else if (swiper.touchEvents.start === 'touchstart') {
            swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, activeListenerWithCapture);
            swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);

            if (swiper.touchEvents.cancel) {
              swiper.$wrapperEl.on(swiper.touchEvents.cancel, '.swiper-slide', zoom.onGestureEnd, passiveListener);
            }
          } // Move image


          swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
        },
        disable: function disable() {
          var swiper = this;
          var zoom = swiper.zoom;

          if (!zoom.enabled) {
            return;
          }

          swiper.zoom.enabled = false;
          var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          var activeListenerWithCapture = Support.passiveListener ? {
            passive: false,
            capture: true
          } : true; // Scale image

          if (Support.gestures) {
            swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
            swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
          } else if (swiper.touchEvents.start === 'touchstart') {
            swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, activeListenerWithCapture);
            swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);

            if (swiper.touchEvents.cancel) {
              swiper.$wrapperEl.off(swiper.touchEvents.cancel, '.swiper-slide', zoom.onGestureEnd, passiveListener);
            }
          } // Move image


          swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
        }
      };
      var Zoom$1 = {
        name: 'zoom',
        params: {
          zoom: {
            enabled: false,
            maxRatio: 3,
            minRatio: 1,
            toggle: true,
            containerClass: 'swiper-zoom-container',
            zoomedSlideClass: 'swiper-slide-zoomed'
          }
        },
        create: function create() {
          var swiper = this;
          var zoom = {
            enabled: false,
            scale: 1,
            currentScale: 1,
            isScaling: false,
            gesture: {
              $slideEl: undefined,
              slideWidth: undefined,
              slideHeight: undefined,
              $imageEl: undefined,
              $imageWrapEl: undefined,
              maxRatio: 3
            },
            image: {
              isTouched: undefined,
              isMoved: undefined,
              currentX: undefined,
              currentY: undefined,
              minX: undefined,
              minY: undefined,
              maxX: undefined,
              maxY: undefined,
              width: undefined,
              height: undefined,
              startX: undefined,
              startY: undefined,
              touchesStart: {},
              touchesCurrent: {}
            },
            velocity: {
              x: undefined,
              y: undefined,
              prevPositionX: undefined,
              prevPositionY: undefined,
              prevTime: undefined
            }
          };
          'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(function (methodName) {
            zoom[methodName] = Zoom[methodName].bind(swiper);
          });
          Utils.extend(swiper, {
            zoom: zoom
          });
          var scale = 1;
          Object.defineProperty(swiper.zoom, 'scale', {
            get: function get() {
              return scale;
            },
            set: function set(value) {
              if (scale !== value) {
                var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
                var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
                swiper.emit('zoomChange', value, imageEl, slideEl);
              }

              scale = value;
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;

            if (swiper.params.zoom.enabled) {
              swiper.zoom.enable();
            }
          },
          destroy: function destroy() {
            var swiper = this;
            swiper.zoom.disable();
          },
          touchStart: function touchStart(e) {
            var swiper = this;

            if (!swiper.zoom.enabled) {
              return;
            }

            swiper.zoom.onTouchStart(e);
          },
          touchEnd: function touchEnd(e) {
            var swiper = this;

            if (!swiper.zoom.enabled) {
              return;
            }

            swiper.zoom.onTouchEnd(e);
          },
          doubleTap: function doubleTap(e) {
            var swiper = this;

            if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
              swiper.zoom.toggle(e);
            }
          },
          transitionEnd: function transitionEnd() {
            var swiper = this;

            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
              swiper.zoom.onTransitionEnd();
            }
          },
          slideChange: function slideChange() {
            var swiper = this;

            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
              swiper.zoom.onTransitionEnd();
            }
          }
        }
      };
      var Lazy = {
        loadInSlide: function loadInSlide(index, loadInDuplicate) {
          if (loadInDuplicate === void 0) loadInDuplicate = true;
          var swiper = this;
          var params = swiper.params.lazy;

          if (typeof index === 'undefined') {
            return;
          }

          if (swiper.slides.length === 0) {
            return;
          }

          var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + index + "\"]") : swiper.slides.eq(index);
          var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");

          if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
            $images = $images.add($slideEl[0]);
          }

          if ($images.length === 0) {
            return;
          }

          $images.each(function (imageIndex, imageEl) {
            var $imageEl = $(imageEl);
            $imageEl.addClass(params.loadingClass);
            var background = $imageEl.attr('data-background');
            var src = $imageEl.attr('data-src');
            var srcset = $imageEl.attr('data-srcset');
            var sizes = $imageEl.attr('data-sizes');
            swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
              if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) {
                return;
              }

              if (background) {
                $imageEl.css('background-image', "url(\"" + background + "\")");
                $imageEl.removeAttr('data-background');
              } else {
                if (srcset) {
                  $imageEl.attr('srcset', srcset);
                  $imageEl.removeAttr('data-srcset');
                }

                if (sizes) {
                  $imageEl.attr('sizes', sizes);
                  $imageEl.removeAttr('data-sizes');
                }

                if (src) {
                  $imageEl.attr('src', src);
                  $imageEl.removeAttr('data-src');
                }
              }

              $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
              $slideEl.find("." + params.preloaderClass).remove();

              if (swiper.params.loop && loadInDuplicate) {
                var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

                if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                  var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + swiper.params.slideDuplicateClass + ")");
                  swiper.lazy.loadInSlide(originalSlide.index(), false);
                } else {
                  var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]");
                  swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                }
              }

              swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
            });
            swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
          });
        },
        load: function load() {
          var swiper = this;
          var $wrapperEl = swiper.$wrapperEl;
          var swiperParams = swiper.params;
          var slides = swiper.slides;
          var activeIndex = swiper.activeIndex;
          var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
          var params = swiperParams.lazy;
          var slidesPerView = swiperParams.slidesPerView;

          if (slidesPerView === 'auto') {
            slidesPerView = 0;
          }

          function slideExist(index) {
            if (isVirtual) {
              if ($wrapperEl.children("." + swiperParams.slideClass + "[data-swiper-slide-index=\"" + index + "\"]").length) {
                return true;
              }
            } else if (slides[index]) {
              return true;
            }

            return false;
          }

          function slideIndex(slideEl) {
            if (isVirtual) {
              return $(slideEl).attr('data-swiper-slide-index');
            }

            return $(slideEl).index();
          }

          if (!swiper.lazy.initialImageLoaded) {
            swiper.lazy.initialImageLoaded = true;
          }

          if (swiper.params.watchSlidesVisibility) {
            $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function (elIndex, slideEl) {
              var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
              swiper.lazy.loadInSlide(index);
            });
          } else if (slidesPerView > 1) {
            for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
              if (slideExist(i)) {
                swiper.lazy.loadInSlide(i);
              }
            }
          } else {
            swiper.lazy.loadInSlide(activeIndex);
          }

          if (params.loadPrevNext) {
            if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
              var amount = params.loadPrevNextAmount;
              var spv = slidesPerView;
              var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
              var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

              for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
                if (slideExist(i$1)) {
                  swiper.lazy.loadInSlide(i$1);
                }
              } // Prev Slides


              for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
                if (slideExist(i$2)) {
                  swiper.lazy.loadInSlide(i$2);
                }
              }
            } else {
              var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);

              if (nextSlide.length > 0) {
                swiper.lazy.loadInSlide(slideIndex(nextSlide));
              }

              var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);

              if (prevSlide.length > 0) {
                swiper.lazy.loadInSlide(slideIndex(prevSlide));
              }
            }
          }
        }
      };
      var Lazy$1 = {
        name: 'lazy',
        params: {
          lazy: {
            enabled: false,
            loadPrevNext: false,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: false,
            elementClass: 'swiper-lazy',
            loadingClass: 'swiper-lazy-loading',
            loadedClass: 'swiper-lazy-loaded',
            preloaderClass: 'swiper-lazy-preloader'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            lazy: {
              initialImageLoaded: false,
              load: Lazy.load.bind(swiper),
              loadInSlide: Lazy.loadInSlide.bind(swiper)
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;

            if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
              swiper.params.preloadImages = false;
            }
          },
          init: function init() {
            var swiper = this;

            if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
              swiper.lazy.load();
            }
          },
          scroll: function scroll() {
            var swiper = this;

            if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
              swiper.lazy.load();
            }
          },
          resize: function resize() {
            var swiper = this;

            if (swiper.params.lazy.enabled) {
              swiper.lazy.load();
            }
          },
          scrollbarDragMove: function scrollbarDragMove() {
            var swiper = this;

            if (swiper.params.lazy.enabled) {
              swiper.lazy.load();
            }
          },
          transitionStart: function transitionStart() {
            var swiper = this;

            if (swiper.params.lazy.enabled) {
              if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
                swiper.lazy.load();
              }
            }
          },
          transitionEnd: function transitionEnd() {
            var swiper = this;

            if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
              swiper.lazy.load();
            }
          },
          slideChange: function slideChange() {
            var swiper = this;

            if (swiper.params.lazy.enabled && swiper.params.cssMode) {
              swiper.lazy.load();
            }
          }
        }
      };
      /* eslint no-bitwise: ["error", { "allow": [">>"] }] */

      var Controller = {
        LinearSpline: function LinearSpline(x, y) {
          var binarySearch = function search() {
            var maxIndex;
            var minIndex;
            var guess;
            return function (array, val) {
              minIndex = -1;
              maxIndex = array.length;

              while (maxIndex - minIndex > 1) {
                guess = maxIndex + minIndex >> 1;

                if (array[guess] <= val) {
                  minIndex = guess;
                } else {
                  maxIndex = guess;
                }
              }

              return maxIndex;
            };
          }();

          this.x = x;
          this.y = y;
          this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
          // (x1,y1) is the known point before given value,
          // (x3,y3) is the known point after given value.

          var i1;
          var i3;

          this.interpolate = function interpolate(x2) {
            if (!x2) {
              return 0;
            } // Get the indexes of x1 and x3 (the array indexes before and after given x2):


            i3 = binarySearch(this.x, x2);
            i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
            // y2 := ((x2x1)  (y3y1))  (x3x1) + y1

            return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
          };

          return this;
        },
        // xxx: for now i will just save one spline function to to
        getInterpolateFunction: function getInterpolateFunction(c) {
          var swiper = this;

          if (!swiper.controller.spline) {
            swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
          }
        },
        setTranslate: function setTranslate(setTranslate$1, byController) {
          var swiper = this;
          var controlled = swiper.controller.control;
          var multiplier;
          var controlledTranslate;

          function setControlledTranslate(c) {
            // this will create an Interpolate function based on the snapGrids
            // x is the Grid of the scrolled scroller and y will be the controlled scroller
            // it makes sense to create this only once and recall it for the interpolation
            // the function does a lot of value caching for performance
            var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

            if (swiper.params.controller.by === 'slide') {
              swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
              // but it did not work out

              controlledTranslate = -swiper.controller.spline.interpolate(-translate);
            }

            if (!controlledTranslate || swiper.params.controller.by === 'container') {
              multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
              controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
            }

            if (swiper.params.controller.inverse) {
              controlledTranslate = c.maxTranslate() - controlledTranslate;
            }

            c.updateProgress(controlledTranslate);
            c.setTranslate(controlledTranslate, swiper);
            c.updateActiveIndex();
            c.updateSlidesClasses();
          }

          if (Array.isArray(controlled)) {
            for (var i = 0; i < controlled.length; i += 1) {
              if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                setControlledTranslate(controlled[i]);
              }
            }
          } else if (controlled instanceof Swiper && byController !== controlled) {
            setControlledTranslate(controlled);
          }
        },
        setTransition: function setTransition(duration, byController) {
          var swiper = this;
          var controlled = swiper.controller.control;
          var i;

          function setControlledTransition(c) {
            c.setTransition(duration, swiper);

            if (duration !== 0) {
              c.transitionStart();

              if (c.params.autoHeight) {
                Utils.nextTick(function () {
                  c.updateAutoHeight();
                });
              }

              c.$wrapperEl.transitionEnd(function () {
                if (!controlled) {
                  return;
                }

                if (c.params.loop && swiper.params.controller.by === 'slide') {
                  c.loopFix();
                }

                c.transitionEnd();
              });
            }
          }

          if (Array.isArray(controlled)) {
            for (i = 0; i < controlled.length; i += 1) {
              if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                setControlledTransition(controlled[i]);
              }
            }
          } else if (controlled instanceof Swiper && byController !== controlled) {
            setControlledTransition(controlled);
          }
        }
      };
      var Controller$1 = {
        name: 'controller',
        params: {
          controller: {
            control: undefined,
            inverse: false,
            by: 'slide' // or 'container'

          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            controller: {
              control: swiper.params.controller.control,
              getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
              setTranslate: Controller.setTranslate.bind(swiper),
              setTransition: Controller.setTransition.bind(swiper)
            }
          });
        },
        on: {
          update: function update() {
            var swiper = this;

            if (!swiper.controller.control) {
              return;
            }

            if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline;
            }
          },
          resize: function resize() {
            var swiper = this;

            if (!swiper.controller.control) {
              return;
            }

            if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline;
            }
          },
          observerUpdate: function observerUpdate() {
            var swiper = this;

            if (!swiper.controller.control) {
              return;
            }

            if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline;
            }
          },
          setTranslate: function setTranslate(translate, byController) {
            var swiper = this;

            if (!swiper.controller.control) {
              return;
            }

            swiper.controller.setTranslate(translate, byController);
          },
          setTransition: function setTransition(duration, byController) {
            var swiper = this;

            if (!swiper.controller.control) {
              return;
            }

            swiper.controller.setTransition(duration, byController);
          }
        }
      };
      var a11y = {
        makeElFocusable: function makeElFocusable($el) {
          $el.attr('tabIndex', '0');
          return $el;
        },
        addElRole: function addElRole($el, role) {
          $el.attr('role', role);
          return $el;
        },
        addElLabel: function addElLabel($el, label) {
          $el.attr('aria-label', label);
          return $el;
        },
        disableEl: function disableEl($el) {
          $el.attr('aria-disabled', true);
          return $el;
        },
        enableEl: function enableEl($el) {
          $el.attr('aria-disabled', false);
          return $el;
        },
        onEnterKey: function onEnterKey(e) {
          var swiper = this;
          var params = swiper.params.a11y;

          if (e.keyCode !== 13) {
            return;
          }

          var $targetEl = $(e.target);

          if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
            if (!(swiper.isEnd && !swiper.params.loop)) {
              swiper.slideNext();
            }

            if (swiper.isEnd) {
              swiper.a11y.notify(params.lastSlideMessage);
            } else {
              swiper.a11y.notify(params.nextSlideMessage);
            }
          }

          if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
            if (!(swiper.isBeginning && !swiper.params.loop)) {
              swiper.slidePrev();
            }

            if (swiper.isBeginning) {
              swiper.a11y.notify(params.firstSlideMessage);
            } else {
              swiper.a11y.notify(params.prevSlideMessage);
            }
          }

          if (swiper.pagination && $targetEl.is("." + swiper.params.pagination.bulletClass)) {
            $targetEl[0].click();
          }
        },
        notify: function notify(message) {
          var swiper = this;
          var notification = swiper.a11y.liveRegion;

          if (notification.length === 0) {
            return;
          }

          notification.html('');
          notification.html(message);
        },
        updateNavigation: function updateNavigation() {
          var swiper = this;

          if (swiper.params.loop) {
            return;
          }

          var ref = swiper.navigation;
          var $nextEl = ref.$nextEl;
          var $prevEl = ref.$prevEl;

          if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
              swiper.a11y.disableEl($prevEl);
            } else {
              swiper.a11y.enableEl($prevEl);
            }
          }

          if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
              swiper.a11y.disableEl($nextEl);
            } else {
              swiper.a11y.enableEl($nextEl);
            }
          }
        },
        updatePagination: function updatePagination() {
          var swiper = this;
          var params = swiper.params.a11y;

          if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
              var $bulletEl = $(bulletEl);
              swiper.a11y.makeElFocusable($bulletEl);
              swiper.a11y.addElRole($bulletEl, 'button');
              swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
            });
          }
        },
        init: function init() {
          var swiper = this;
          swiper.$el.append(swiper.a11y.liveRegion); // Navigation

          var params = swiper.params.a11y;
          var $nextEl;
          var $prevEl;

          if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
          }

          if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
          }

          if ($nextEl) {
            swiper.a11y.makeElFocusable($nextEl);
            swiper.a11y.addElRole($nextEl, 'button');
            swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
            $nextEl.on('keydown', swiper.a11y.onEnterKey);
          }

          if ($prevEl) {
            swiper.a11y.makeElFocusable($prevEl);
            swiper.a11y.addElRole($prevEl, 'button');
            swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
            $prevEl.on('keydown', swiper.a11y.onEnterKey);
          } // Pagination


          if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.$el.on('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
          }
        },
        destroy: function destroy() {
          var swiper = this;

          if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) {
            swiper.a11y.liveRegion.remove();
          }

          var $nextEl;
          var $prevEl;

          if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
          }

          if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
          }

          if ($nextEl) {
            $nextEl.off('keydown', swiper.a11y.onEnterKey);
          }

          if ($prevEl) {
            $prevEl.off('keydown', swiper.a11y.onEnterKey);
          } // Pagination


          if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.$el.off('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
          }
        }
      };
      var A11y = {
        name: 'a11y',
        params: {
          a11y: {
            enabled: true,
            notificationClass: 'swiper-notification',
            prevSlideMessage: 'Previous slide',
            nextSlideMessage: 'Next slide',
            firstSlideMessage: 'This is the first slide',
            lastSlideMessage: 'This is the last slide',
            paginationBulletMessage: 'Go to slide {{index}}'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            a11y: {
              liveRegion: $("<span class=\"" + swiper.params.a11y.notificationClass + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")
            }
          });
          Object.keys(a11y).forEach(function (methodName) {
            swiper.a11y[methodName] = a11y[methodName].bind(swiper);
          });
        },
        on: {
          init: function init() {
            var swiper = this;

            if (!swiper.params.a11y.enabled) {
              return;
            }

            swiper.a11y.init();
            swiper.a11y.updateNavigation();
          },
          toEdge: function toEdge() {
            var swiper = this;

            if (!swiper.params.a11y.enabled) {
              return;
            }

            swiper.a11y.updateNavigation();
          },
          fromEdge: function fromEdge() {
            var swiper = this;

            if (!swiper.params.a11y.enabled) {
              return;
            }

            swiper.a11y.updateNavigation();
          },
          paginationUpdate: function paginationUpdate() {
            var swiper = this;

            if (!swiper.params.a11y.enabled) {
              return;
            }

            swiper.a11y.updatePagination();
          },
          destroy: function destroy() {
            var swiper = this;

            if (!swiper.params.a11y.enabled) {
              return;
            }

            swiper.a11y.destroy();
          }
        }
      };
      var History = {
        init: function init() {
          var swiper = this;

          if (!swiper.params.history) {
            return;
          }

          if (!win.history || !win.history.pushState) {
            swiper.params.history.enabled = false;
            swiper.params.hashNavigation.enabled = true;
            return;
          }

          var history = swiper.history;
          history.initialized = true;
          history.paths = History.getPathValues();

          if (!history.paths.key && !history.paths.value) {
            return;
          }

          history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);

          if (!swiper.params.history.replaceState) {
            win.addEventListener('popstate', swiper.history.setHistoryPopState);
          }
        },
        destroy: function destroy() {
          var swiper = this;

          if (!swiper.params.history.replaceState) {
            win.removeEventListener('popstate', swiper.history.setHistoryPopState);
          }
        },
        setHistoryPopState: function setHistoryPopState() {
          var swiper = this;
          swiper.history.paths = History.getPathValues();
          swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
        },
        getPathValues: function getPathValues() {
          var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) {
            return part !== '';
          });
          var total = pathArray.length;
          var key = pathArray[total - 2];
          var value = pathArray[total - 1];
          return {
            key: key,
            value: value
          };
        },
        setHistory: function setHistory(key, index) {
          var swiper = this;

          if (!swiper.history.initialized || !swiper.params.history.enabled) {
            return;
          }

          var slide = swiper.slides.eq(index);
          var value = History.slugify(slide.attr('data-history'));

          if (!win.location.pathname.includes(key)) {
            value = key + "/" + value;
          }

          var currentState = win.history.state;

          if (currentState && currentState.value === value) {
            return;
          }

          if (swiper.params.history.replaceState) {
            win.history.replaceState({
              value: value
            }, null, value);
          } else {
            win.history.pushState({
              value: value
            }, null, value);
          }
        },
        slugify: function slugify(text) {
          return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
        },
        scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
          var swiper = this;

          if (value) {
            for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
              var slide = swiper.slides.eq(i);
              var slideHistory = History.slugify(slide.attr('data-history'));

              if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                var index = slide.index();
                swiper.slideTo(index, speed, runCallbacks);
              }
            }
          } else {
            swiper.slideTo(0, speed, runCallbacks);
          }
        }
      };
      var History$1 = {
        name: 'history',
        params: {
          history: {
            enabled: false,
            replaceState: false,
            key: 'slides'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            history: {
              init: History.init.bind(swiper),
              setHistory: History.setHistory.bind(swiper),
              setHistoryPopState: History.setHistoryPopState.bind(swiper),
              scrollToSlide: History.scrollToSlide.bind(swiper),
              destroy: History.destroy.bind(swiper)
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;

            if (swiper.params.history.enabled) {
              swiper.history.init();
            }
          },
          destroy: function destroy() {
            var swiper = this;

            if (swiper.params.history.enabled) {
              swiper.history.destroy();
            }
          },
          transitionEnd: function transitionEnd() {
            var swiper = this;

            if (swiper.history.initialized) {
              swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
            }
          },
          slideChange: function slideChange() {
            var swiper = this;

            if (swiper.history.initialized && swiper.params.cssMode) {
              swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
            }
          }
        }
      };
      var HashNavigation = {
        onHashCange: function onHashCange() {
          var swiper = this;
          var newHash = doc.location.hash.replace('#', '');
          var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

          if (newHash !== activeSlideHash) {
            var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-hash=\"" + newHash + "\"]").index();

            if (typeof newIndex === 'undefined') {
              return;
            }

            swiper.slideTo(newIndex);
          }
        },
        setHash: function setHash() {
          var swiper = this;

          if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) {
            return;
          }

          if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
            win.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr('data-hash') || false);
          } else {
            var slide = swiper.slides.eq(swiper.activeIndex);
            var hash = slide.attr('data-hash') || slide.attr('data-history');
            doc.location.hash = hash || '';
          }
        },
        init: function init() {
          var swiper = this;

          if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) {
            return;
          }

          swiper.hashNavigation.initialized = true;
          var hash = doc.location.hash.replace('#', '');

          if (hash) {
            var speed = 0;

            for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
              var slide = swiper.slides.eq(i);
              var slideHash = slide.attr('data-hash') || slide.attr('data-history');

              if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                var index = slide.index();
                swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
              }
            }
          }

          if (swiper.params.hashNavigation.watchState) {
            $(win).on('hashchange', swiper.hashNavigation.onHashCange);
          }
        },
        destroy: function destroy() {
          var swiper = this;

          if (swiper.params.hashNavigation.watchState) {
            $(win).off('hashchange', swiper.hashNavigation.onHashCange);
          }
        }
      };
      var HashNavigation$1 = {
        name: 'hash-navigation',
        params: {
          hashNavigation: {
            enabled: false,
            replaceState: false,
            watchState: false
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            hashNavigation: {
              initialized: false,
              init: HashNavigation.init.bind(swiper),
              destroy: HashNavigation.destroy.bind(swiper),
              setHash: HashNavigation.setHash.bind(swiper),
              onHashCange: HashNavigation.onHashCange.bind(swiper)
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;

            if (swiper.params.hashNavigation.enabled) {
              swiper.hashNavigation.init();
            }
          },
          destroy: function destroy() {
            var swiper = this;

            if (swiper.params.hashNavigation.enabled) {
              swiper.hashNavigation.destroy();
            }
          },
          transitionEnd: function transitionEnd() {
            var swiper = this;

            if (swiper.hashNavigation.initialized) {
              swiper.hashNavigation.setHash();
            }
          },
          slideChange: function slideChange() {
            var swiper = this;

            if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
              swiper.hashNavigation.setHash();
            }
          }
        }
      };
      /* eslint no-underscore-dangle: "off" */

      var Autoplay = {
        run: function run() {
          var swiper = this;
          var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
          var delay = swiper.params.autoplay.delay;

          if ($activeSlideEl.attr('data-swiper-autoplay')) {
            delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
          }

          clearTimeout(swiper.autoplay.timeout);
          swiper.autoplay.timeout = Utils.nextTick(function () {
            if (swiper.params.autoplay.reverseDirection) {
              if (swiper.params.loop) {
                swiper.loopFix();
                swiper.slidePrev(swiper.params.speed, true, true);
                swiper.emit('autoplay');
              } else if (!swiper.isBeginning) {
                swiper.slidePrev(swiper.params.speed, true, true);
                swiper.emit('autoplay');
              } else if (!swiper.params.autoplay.stopOnLastSlide) {
                swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                swiper.emit('autoplay');
              } else {
                swiper.autoplay.stop();
              }
            } else if (swiper.params.loop) {
              swiper.loopFix();
              swiper.slideNext(swiper.params.speed, true, true);
              swiper.emit('autoplay');
            } else if (!swiper.isEnd) {
              swiper.slideNext(swiper.params.speed, true, true);
              swiper.emit('autoplay');
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              swiper.slideTo(0, swiper.params.speed, true, true);
              swiper.emit('autoplay');
            } else {
              swiper.autoplay.stop();
            }

            if (swiper.params.cssMode && swiper.autoplay.running) {
              swiper.autoplay.run();
            }
          }, delay);
        },
        start: function start() {
          var swiper = this;

          if (typeof swiper.autoplay.timeout !== 'undefined') {
            return false;
          }

          if (swiper.autoplay.running) {
            return false;
          }

          swiper.autoplay.running = true;
          swiper.emit('autoplayStart');
          swiper.autoplay.run();
          return true;
        },
        stop: function stop() {
          var swiper = this;

          if (!swiper.autoplay.running) {
            return false;
          }

          if (typeof swiper.autoplay.timeout === 'undefined') {
            return false;
          }

          if (swiper.autoplay.timeout) {
            clearTimeout(swiper.autoplay.timeout);
            swiper.autoplay.timeout = undefined;
          }

          swiper.autoplay.running = false;
          swiper.emit('autoplayStop');
          return true;
        },
        pause: function pause(speed) {
          var swiper = this;

          if (!swiper.autoplay.running) {
            return;
          }

          if (swiper.autoplay.paused) {
            return;
          }

          if (swiper.autoplay.timeout) {
            clearTimeout(swiper.autoplay.timeout);
          }

          swiper.autoplay.paused = true;

          if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
            swiper.autoplay.paused = false;
            swiper.autoplay.run();
          } else {
            swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
            swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
          }
        }
      };
      var Autoplay$1 = {
        name: 'autoplay',
        params: {
          autoplay: {
            enabled: false,
            delay: 3000,
            waitForTransition: true,
            disableOnInteraction: true,
            stopOnLastSlide: false,
            reverseDirection: false
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            autoplay: {
              running: false,
              paused: false,
              run: Autoplay.run.bind(swiper),
              start: Autoplay.start.bind(swiper),
              stop: Autoplay.stop.bind(swiper),
              pause: Autoplay.pause.bind(swiper),
              onVisibilityChange: function onVisibilityChange() {
                if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
                  swiper.autoplay.pause();
                }

                if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
                  swiper.autoplay.run();
                  swiper.autoplay.paused = false;
                }
              },
              onTransitionEnd: function onTransitionEnd(e) {
                if (!swiper || swiper.destroyed || !swiper.$wrapperEl) {
                  return;
                }

                if (e.target !== this) {
                  return;
                }

                swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
                swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
                swiper.autoplay.paused = false;

                if (!swiper.autoplay.running) {
                  swiper.autoplay.stop();
                } else {
                  swiper.autoplay.run();
                }
              }
            }
          });
        },
        on: {
          init: function init() {
            var swiper = this;

            if (swiper.params.autoplay.enabled) {
              swiper.autoplay.start();
              document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
            }
          },
          beforeTransitionStart: function beforeTransitionStart(speed, internal) {
            var swiper = this;

            if (swiper.autoplay.running) {
              if (internal || !swiper.params.autoplay.disableOnInteraction) {
                swiper.autoplay.pause(speed);
              } else {
                swiper.autoplay.stop();
              }
            }
          },
          sliderFirstMove: function sliderFirstMove() {
            var swiper = this;

            if (swiper.autoplay.running) {
              if (swiper.params.autoplay.disableOnInteraction) {
                swiper.autoplay.stop();
              } else {
                swiper.autoplay.pause();
              }
            }
          },
          touchEnd: function touchEnd() {
            var swiper = this;

            if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
              swiper.autoplay.run();
            }
          },
          destroy: function destroy() {
            var swiper = this;

            if (swiper.autoplay.running) {
              swiper.autoplay.stop();
            }

            document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
          }
        }
      };
      var Fade = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var slides = swiper.slides;

          for (var i = 0; i < slides.length; i += 1) {
            var $slideEl = swiper.slides.eq(i);
            var offset = $slideEl[0].swiperSlideOffset;
            var tx = -offset;

            if (!swiper.params.virtualTranslate) {
              tx -= swiper.translate;
            }

            var ty = 0;

            if (!swiper.isHorizontal()) {
              ty = tx;
              tx = 0;
            }

            var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
            $slideEl.css({
              opacity: slideOpacity
            }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          var slides = swiper.slides;
          var $wrapperEl = swiper.$wrapperEl;
          slides.transition(duration);

          if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false;
            slides.transitionEnd(function () {
              if (eventTriggered) {
                return;
              }

              if (!swiper || swiper.destroyed) {
                return;
              }

              eventTriggered = true;
              swiper.animating = false;
              var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

              for (var i = 0; i < triggerEvents.length; i += 1) {
                $wrapperEl.trigger(triggerEvents[i]);
              }
            });
          }
        }
      };
      var EffectFade = {
        name: 'effect-fade',
        params: {
          fadeEffect: {
            crossFade: false
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            fadeEffect: {
              setTranslate: Fade.setTranslate.bind(swiper),
              setTransition: Fade.setTransition.bind(swiper)
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;

            if (swiper.params.effect !== 'fade') {
              return;
            }

            swiper.classNames.push(swiper.params.containerModifierClass + "fade");
            var overwriteParams = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: true
            };
            Utils.extend(swiper.params, overwriteParams);
            Utils.extend(swiper.originalParams, overwriteParams);
          },
          setTranslate: function setTranslate() {
            var swiper = this;

            if (swiper.params.effect !== 'fade') {
              return;
            }

            swiper.fadeEffect.setTranslate();
          },
          setTransition: function setTransition(duration) {
            var swiper = this;

            if (swiper.params.effect !== 'fade') {
              return;
            }

            swiper.fadeEffect.setTransition(duration);
          }
        }
      };
      var Cube = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var $el = swiper.$el;
          var $wrapperEl = swiper.$wrapperEl;
          var slides = swiper.slides;
          var swiperWidth = swiper.width;
          var swiperHeight = swiper.height;
          var rtl = swiper.rtlTranslate;
          var swiperSize = swiper.size;
          var params = swiper.params.cubeEffect;
          var isHorizontal = swiper.isHorizontal();
          var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          var wrapperRotate = 0;
          var $cubeShadowEl;

          if (params.shadow) {
            if (isHorizontal) {
              $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

              if ($cubeShadowEl.length === 0) {
                $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                $wrapperEl.append($cubeShadowEl);
              }

              $cubeShadowEl.css({
                height: swiperWidth + "px"
              });
            } else {
              $cubeShadowEl = $el.find('.swiper-cube-shadow');

              if ($cubeShadowEl.length === 0) {
                $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                $el.append($cubeShadowEl);
              }
            }
          }

          for (var i = 0; i < slides.length; i += 1) {
            var $slideEl = slides.eq(i);
            var slideIndex = i;

            if (isVirtual) {
              slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
            }

            var slideAngle = slideIndex * 90;
            var round = Math.floor(slideAngle / 360);

            if (rtl) {
              slideAngle = -slideAngle;
              round = Math.floor(-slideAngle / 360);
            }

            var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            var tx = 0;
            var ty = 0;
            var tz = 0;

            if (slideIndex % 4 === 0) {
              tx = -round * 4 * swiperSize;
              tz = 0;
            } else if ((slideIndex - 1) % 4 === 0) {
              tx = 0;
              tz = -round * 4 * swiperSize;
            } else if ((slideIndex - 2) % 4 === 0) {
              tx = swiperSize + round * 4 * swiperSize;
              tz = swiperSize;
            } else if ((slideIndex - 3) % 4 === 0) {
              tx = -swiperSize;
              tz = 3 * swiperSize + swiperSize * 4 * round;
            }

            if (rtl) {
              tx = -tx;
            }

            if (!isHorizontal) {
              ty = tx;
              tx = 0;
            }

            var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";

            if (progress <= 1 && progress > -1) {
              wrapperRotate = slideIndex * 90 + progress * 90;

              if (rtl) {
                wrapperRotate = -slideIndex * 90 - progress * 90;
              }
            }

            $slideEl.transform(transform);

            if (params.slideShadows) {
              // Set shadows
              var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
              var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

              if (shadowBefore.length === 0) {
                shadowBefore = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
                $slideEl.append(shadowBefore);
              }

              if (shadowAfter.length === 0) {
                shadowAfter = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
                $slideEl.append(shadowAfter);
              }

              if (shadowBefore.length) {
                shadowBefore[0].style.opacity = Math.max(-progress, 0);
              }

              if (shadowAfter.length) {
                shadowAfter[0].style.opacity = Math.max(progress, 0);
              }
            }
          }

          $wrapperEl.css({
            '-webkit-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
            '-moz-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
            '-ms-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
            'transform-origin': "50% 50% -" + swiperSize / 2 + "px"
          });

          if (params.shadow) {
            if (isHorizontal) {
              $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
            } else {
              var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
              var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
              var scale1 = params.shadowScale;
              var scale2 = params.shadowScale / multiplier;
              var offset = params.shadowOffset;
              $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
            }
          }

          var zFactor = Browser.isSafari || Browser.isUiWebView ? -swiperSize / 2 : 0;
          $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          var $el = swiper.$el;
          var slides = swiper.slides;
          slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

          if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
            $el.find('.swiper-cube-shadow').transition(duration);
          }
        }
      };
      var EffectCube = {
        name: 'effect-cube',
        params: {
          cubeEffect: {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            cubeEffect: {
              setTranslate: Cube.setTranslate.bind(swiper),
              setTransition: Cube.setTransition.bind(swiper)
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;

            if (swiper.params.effect !== 'cube') {
              return;
            }

            swiper.classNames.push(swiper.params.containerModifierClass + "cube");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              resistanceRatio: 0,
              spaceBetween: 0,
              centeredSlides: false,
              virtualTranslate: true
            };
            Utils.extend(swiper.params, overwriteParams);
            Utils.extend(swiper.originalParams, overwriteParams);
          },
          setTranslate: function setTranslate() {
            var swiper = this;

            if (swiper.params.effect !== 'cube') {
              return;
            }

            swiper.cubeEffect.setTranslate();
          },
          setTransition: function setTransition(duration) {
            var swiper = this;

            if (swiper.params.effect !== 'cube') {
              return;
            }

            swiper.cubeEffect.setTransition(duration);
          }
        }
      };
      var Flip = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var slides = swiper.slides;
          var rtl = swiper.rtlTranslate;

          for (var i = 0; i < slides.length; i += 1) {
            var $slideEl = slides.eq(i);
            var progress = $slideEl[0].progress;

            if (swiper.params.flipEffect.limitRotation) {
              progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            }

            var offset = $slideEl[0].swiperSlideOffset;
            var rotate = -180 * progress;
            var rotateY = rotate;
            var rotateX = 0;
            var tx = -offset;
            var ty = 0;

            if (!swiper.isHorizontal()) {
              ty = tx;
              tx = 0;
              rotateX = -rotateY;
              rotateY = 0;
            } else if (rtl) {
              rotateY = -rotateY;
            }

            $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

            if (swiper.params.flipEffect.slideShadows) {
              // Set shadows
              var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
              var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

              if (shadowBefore.length === 0) {
                shadowBefore = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>");
                $slideEl.append(shadowBefore);
              }

              if (shadowAfter.length === 0) {
                shadowAfter = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>");
                $slideEl.append(shadowAfter);
              }

              if (shadowBefore.length) {
                shadowBefore[0].style.opacity = Math.max(-progress, 0);
              }

              if (shadowAfter.length) {
                shadowAfter[0].style.opacity = Math.max(progress, 0);
              }
            }

            $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          var slides = swiper.slides;
          var activeIndex = swiper.activeIndex;
          var $wrapperEl = swiper.$wrapperEl;
          slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

          if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false; // eslint-disable-next-line

            slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
              if (eventTriggered) {
                return;
              }

              if (!swiper || swiper.destroyed) {
                return;
              } // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;


              eventTriggered = true;
              swiper.animating = false;
              var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

              for (var i = 0; i < triggerEvents.length; i += 1) {
                $wrapperEl.trigger(triggerEvents[i]);
              }
            });
          }
        }
      };
      var EffectFlip = {
        name: 'effect-flip',
        params: {
          flipEffect: {
            slideShadows: true,
            limitRotation: true
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            flipEffect: {
              setTranslate: Flip.setTranslate.bind(swiper),
              setTransition: Flip.setTransition.bind(swiper)
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;

            if (swiper.params.effect !== 'flip') {
              return;
            }

            swiper.classNames.push(swiper.params.containerModifierClass + "flip");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: true
            };
            Utils.extend(swiper.params, overwriteParams);
            Utils.extend(swiper.originalParams, overwriteParams);
          },
          setTranslate: function setTranslate() {
            var swiper = this;

            if (swiper.params.effect !== 'flip') {
              return;
            }

            swiper.flipEffect.setTranslate();
          },
          setTransition: function setTransition(duration) {
            var swiper = this;

            if (swiper.params.effect !== 'flip') {
              return;
            }

            swiper.flipEffect.setTransition(duration);
          }
        }
      };
      var Coverflow = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var swiperWidth = swiper.width;
          var swiperHeight = swiper.height;
          var slides = swiper.slides;
          var $wrapperEl = swiper.$wrapperEl;
          var slidesSizesGrid = swiper.slidesSizesGrid;
          var params = swiper.params.coverflowEffect;
          var isHorizontal = swiper.isHorizontal();
          var transform = swiper.translate;
          var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
          var rotate = isHorizontal ? params.rotate : -params.rotate;
          var translate = params.depth; // Each slide offset from center

          for (var i = 0, length = slides.length; i < length; i += 1) {
            var $slideEl = slides.eq(i);
            var slideSize = slidesSizesGrid[i];
            var slideOffset = $slideEl[0].swiperSlideOffset;
            var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
            var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
            var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

            var translateZ = -translate * Math.abs(offsetMultiplier);
            var translateY = isHorizontal ? 0 : params.stretch * offsetMultiplier;
            var translateX = isHorizontal ? params.stretch * offsetMultiplier : 0; // Fix for ultra small values

            if (Math.abs(translateX) < 0.001) {
              translateX = 0;
            }

            if (Math.abs(translateY) < 0.001) {
              translateY = 0;
            }

            if (Math.abs(translateZ) < 0.001) {
              translateZ = 0;
            }

            if (Math.abs(rotateY) < 0.001) {
              rotateY = 0;
            }

            if (Math.abs(rotateX) < 0.001) {
              rotateX = 0;
            }

            var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
            $slideEl.transform(slideTransform);
            $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

            if (params.slideShadows) {
              // Set shadows
              var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
              var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

              if ($shadowBeforeEl.length === 0) {
                $shadowBeforeEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
                $slideEl.append($shadowBeforeEl);
              }

              if ($shadowAfterEl.length === 0) {
                $shadowAfterEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
                $slideEl.append($shadowAfterEl);
              }

              if ($shadowBeforeEl.length) {
                $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
              }

              if ($shadowAfterEl.length) {
                $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
              }
            }
          } // Set correct perspective for IE10


          if (Support.pointerEvents || Support.prefixedPointerEvents) {
            var ws = $wrapperEl[0].style;
            ws.perspectiveOrigin = center + "px 50%";
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        }
      };
      var EffectCoverflow = {
        name: 'effect-coverflow',
        params: {
          coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            modifier: 1,
            slideShadows: true
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            coverflowEffect: {
              setTranslate: Coverflow.setTranslate.bind(swiper),
              setTransition: Coverflow.setTransition.bind(swiper)
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;

            if (swiper.params.effect !== 'coverflow') {
              return;
            }

            swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
          },
          setTranslate: function setTranslate() {
            var swiper = this;

            if (swiper.params.effect !== 'coverflow') {
              return;
            }

            swiper.coverflowEffect.setTranslate();
          },
          setTransition: function setTransition(duration) {
            var swiper = this;

            if (swiper.params.effect !== 'coverflow') {
              return;
            }

            swiper.coverflowEffect.setTransition(duration);
          }
        }
      };
      var Thumbs = {
        init: function init() {
          var swiper = this;
          var ref = swiper.params;
          var thumbsParams = ref.thumbs;
          var SwiperClass = swiper.constructor;

          if (thumbsParams.swiper instanceof SwiperClass) {
            swiper.thumbs.swiper = thumbsParams.swiper;
            Utils.extend(swiper.thumbs.swiper.originalParams, {
              watchSlidesProgress: true,
              slideToClickedSlide: false
            });
            Utils.extend(swiper.thumbs.swiper.params, {
              watchSlidesProgress: true,
              slideToClickedSlide: false
            });
          } else if (Utils.isObject(thumbsParams.swiper)) {
            swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
              watchSlidesVisibility: true,
              watchSlidesProgress: true,
              slideToClickedSlide: false
            }));
            swiper.thumbs.swiperCreated = true;
          }

          swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
          swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
        },
        onThumbClick: function onThumbClick() {
          var swiper = this;
          var thumbsSwiper = swiper.thumbs.swiper;

          if (!thumbsSwiper) {
            return;
          }

          var clickedIndex = thumbsSwiper.clickedIndex;
          var clickedSlide = thumbsSwiper.clickedSlide;

          if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) {
            return;
          }

          if (typeof clickedIndex === 'undefined' || clickedIndex === null) {
            return;
          }

          var slideToIndex;

          if (thumbsSwiper.params.loop) {
            slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
          } else {
            slideToIndex = clickedIndex;
          }

          if (swiper.params.loop) {
            var currentIndex = swiper.activeIndex;

            if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
              swiper.loopFix(); // eslint-disable-next-line

              swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
              currentIndex = swiper.activeIndex;
            }

            var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
            var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();

            if (typeof prevIndex === 'undefined') {
              slideToIndex = nextIndex;
            } else if (typeof nextIndex === 'undefined') {
              slideToIndex = prevIndex;
            } else if (nextIndex - currentIndex < currentIndex - prevIndex) {
              slideToIndex = nextIndex;
            } else {
              slideToIndex = prevIndex;
            }
          }

          swiper.slideTo(slideToIndex);
        },
        update: function update(initial) {
          var swiper = this;
          var thumbsSwiper = swiper.thumbs.swiper;

          if (!thumbsSwiper) {
            return;
          }

          var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

          if (swiper.realIndex !== thumbsSwiper.realIndex) {
            var currentThumbsIndex = thumbsSwiper.activeIndex;
            var newThumbsIndex;

            if (thumbsSwiper.params.loop) {
              if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                thumbsSwiper.loopFix(); // eslint-disable-next-line

                thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                currentThumbsIndex = thumbsSwiper.activeIndex;
              } // Find actual thumbs index to slide to


              var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();
              var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();

              if (typeof prevThumbsIndex === 'undefined') {
                newThumbsIndex = nextThumbsIndex;
              } else if (typeof nextThumbsIndex === 'undefined') {
                newThumbsIndex = prevThumbsIndex;
              } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
                newThumbsIndex = currentThumbsIndex;
              } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                newThumbsIndex = nextThumbsIndex;
              } else {
                newThumbsIndex = prevThumbsIndex;
              }
            } else {
              newThumbsIndex = swiper.realIndex;
            }

            if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
              if (thumbsSwiper.params.centeredSlides) {
                if (newThumbsIndex > currentThumbsIndex) {
                  newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                } else {
                  newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                }
              } else if (newThumbsIndex > currentThumbsIndex) {
                newThumbsIndex = newThumbsIndex - slidesPerView + 1;
              }

              thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
            }
          } // Activate thumbs


          var thumbsToActivate = 1;
          var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

          if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
            thumbsToActivate = swiper.params.slidesPerView;
          }

          thumbsSwiper.slides.removeClass(thumbActiveClass);

          if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
            for (var i = 0; i < thumbsToActivate; i += 1) {
              thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]").addClass(thumbActiveClass);
            }
          } else {
            for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
              thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
            }
          }
        }
      };
      var Thumbs$1 = {
        name: 'thumbs',
        params: {
          thumbs: {
            swiper: null,
            slideThumbActiveClass: 'swiper-slide-thumb-active',
            thumbsContainerClass: 'swiper-container-thumbs'
          }
        },
        create: function create() {
          var swiper = this;
          Utils.extend(swiper, {
            thumbs: {
              swiper: null,
              init: Thumbs.init.bind(swiper),
              update: Thumbs.update.bind(swiper),
              onThumbClick: Thumbs.onThumbClick.bind(swiper)
            }
          });
        },
        on: {
          beforeInit: function beforeInit() {
            var swiper = this;
            var ref = swiper.params;
            var thumbs = ref.thumbs;

            if (!thumbs || !thumbs.swiper) {
              return;
            }

            swiper.thumbs.init();
            swiper.thumbs.update(true);
          },
          slideChange: function slideChange() {
            var swiper = this;

            if (!swiper.thumbs.swiper) {
              return;
            }

            swiper.thumbs.update();
          },
          update: function update() {
            var swiper = this;

            if (!swiper.thumbs.swiper) {
              return;
            }

            swiper.thumbs.update();
          },
          resize: function resize() {
            var swiper = this;

            if (!swiper.thumbs.swiper) {
              return;
            }

            swiper.thumbs.update();
          },
          observerUpdate: function observerUpdate() {
            var swiper = this;

            if (!swiper.thumbs.swiper) {
              return;
            }

            swiper.thumbs.update();
          },
          setTransition: function setTransition(duration) {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;

            if (!thumbsSwiper) {
              return;
            }

            thumbsSwiper.setTransition(duration);
          },
          beforeDestroy: function beforeDestroy() {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;

            if (!thumbsSwiper) {
              return;
            }

            if (swiper.thumbs.swiperCreated && thumbsSwiper) {
              thumbsSwiper.destroy();
            }
          }
        }
      }; // Swiper Class

      var components = [Device$1, Support$1, Browser$1, Resize, Observer$1, Virtual$1, Keyboard$1, Mousewheel$1, Navigation$1, Pagination$1, Scrollbar$1, Parallax$1, Zoom$1, Lazy$1, Controller$1, A11y, History$1, HashNavigation$1, Autoplay$1, EffectFade, EffectCube, EffectFlip, EffectCoverflow, Thumbs$1];

      if (typeof Swiper.use === 'undefined') {
        Swiper.use = Swiper.Class.use;
        Swiper.installModule = Swiper.Class.installModule;
      }

      Swiper.use(components);
      return Swiper;
    });
    /***/

  },

  /***/
  "./resources/assets/vendor/libs/swiper/swiper.js":
  /*!*******************************************************!*\
    !*** ./resources/assets/vendor/libs/swiper/swiper.js ***!
    \*******************************************************/

  /*! exports provided: Swiper */

  /***/
  function resourcesAssetsVendorLibsSwiperSwiperJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var swiper_js_swiper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! swiper/js/swiper.js */
    "./node_modules/swiper/js/swiper.js");
    /* harmony import */


    var swiper_js_swiper_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(swiper_js_swiper_js__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony reexport (module object) */


    __webpack_require__.d(__webpack_exports__, "Swiper", function () {
      return swiper_js_swiper_js__WEBPACK_IMPORTED_MODULE_0__;
    });
    /***/

  },

  /***/
  110:
  /*!*************************************************************!*\
    !*** multi ./resources/assets/vendor/libs/swiper/swiper.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(
    /*! C:\xampp\htdocs\blog-beta\resources\assets\vendor\libs\swiper\swiper.js */
    "./resources/assets/vendor/libs/swiper/swiper.js");
    /***/
  }
  /******/

}));

/***/ }),

/***/ 123:
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./resources/assets/libs/datatables/datatables.js ./resources/assets/libs/swiper/swiper.js ./resources/assets/libs/sweetalert2/sweetalert2.js ./resources/assets/libs/growl/growl.js ./resources/assets/libs/bootstrap-select/bootstrap-select.js ./resources/assets/libs/select2/select2.js ./resources/assets/libs/bootstrap-tagsinput/bootstrap-tagsinput.js ./resources/assets/libs/summernote-bs4/summernote-bs4.min.js ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\datatables\datatables.js */"./resources/assets/libs/datatables/datatables.js");
__webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\swiper\swiper.js */"./resources/assets/libs/swiper/swiper.js");
__webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\sweetalert2\sweetalert2.js */"./resources/assets/libs/sweetalert2/sweetalert2.js");
__webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\growl\growl.js */"./resources/assets/libs/growl/growl.js");
__webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\bootstrap-select\bootstrap-select.js */"./resources/assets/libs/bootstrap-select/bootstrap-select.js");
__webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\select2\select2.js */"./resources/assets/libs/select2/select2.js");
__webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\bootstrap-tagsinput\bootstrap-tagsinput.js */"./resources/assets/libs/bootstrap-tagsinput/bootstrap-tagsinput.js");
module.exports = __webpack_require__(/*! D:\Program\xampp\htdocs\shikhun-backend\resources\assets\libs\summernote-bs4\summernote-bs4.min.js */"./resources/assets/libs/summernote-bs4/summernote-bs4.min.js");


/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window["jQuery"]; }());

/***/ })

/******/ })));